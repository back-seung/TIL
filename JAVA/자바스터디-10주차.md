# 목표

자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.



# 학습할 것 (필수)

*   Thread 클래스와 Runnable 인터페이스
*   쓰레드의 상태
*   쓰레드의 우선순위
*   Main 쓰레드
*   동기화
*   데드락



## Thread 클래스와 Runnable 인터페이스

### 프로세스란

*   프로그램은 하나의 프로세스이다.

*   프로그램을 실행하면 운영체제로부터 자원을 할당받아 프로세스가 된다. 

*   프로세스는 프로그램을 실행하는데 필요한 **자원**과 **스레드**로 구성되어 있다.

    

### 쓰레드란

*   프로세스의 자원을 이용해서 실제 작업을 수행하는 것
*   모든 프로세스에는 하나 이상의 스레드가 존재한다. 둘 이상의 쓰레드를 가진 프로세스를 `멀티쓰레드 프로세스`라고 한다.
*   가장 작은 실행 단위이다.



현재 우리가 사용하고 있는 대부분의 OS는 멀티 태스킹을 지원하기 떄문에 여럭 개의 프로세스가 동시에 실행될 수 있다. 마찬가지로 멀티쓰레딩은 하나의 프로세스 내에서 여러 쓰레드가 동시에 작업을 수행하는 것이다. 

멀티쓰레딩의 장점은 다음과 같다.

| 멀티 스레딩의 장점                     |
| -------------------------------------- |
| CPU의 사용률을 향상시킨다.             |
| 자원을 보다 효율적으로 사용할 수 있다. |
| 사용자에 대한 응답성이 향상된다.       |
| 작업이 분리되어 코드가 더 간결해진다.  |



### Thread 클래스와 Runnable 인터페이스

쓰레드를 구현하는 방법은 `Thread 클래스를 상속`받는 방법과 `Runnable 인터페이스`를 구현하는 방법 모두 두 가지가 있다.

Thread 클래스를 상속 받으면 다른 클래스를 상속 받을 수 없기 때문에 Runnable 인터페이스를 구현하는 방법이 일반적이다.

**Runnable 인터페이스를 구현하는 방법은 재사용성이 높고, 코드의 일관성을 유지할 수 있기 때문에 보다 객체지향적인 방법이다.**

Thread 클래스를 상속받은 경우와 Runnable 인터페이스를 구현한 경우의 인스턴스 생성 방법이 다르다.

```java
ThreadExample t1 = new ThreadExample();				// Thread의 자손 클래스의 인스턴스를 생성

Runnable r = new ThreadExample();					// Runnable을 구현한 클래스의 인스턴스를 생성
Thread t2 = new Thread(r);							// 생성자 Thread(Runnable Target)

Thraed t2 = new Thread(new ThreadExample());		// 위의 두 줄을 한 줄로 간단히
```



*    `Runnable Example 예제`

    ```java
    package week_10;
    
    public class RunnableExample implements Runnable {
        @Override
        public void run() {
            System.out.println("This is Runnable Example run()");
        }
    }
    ```

    

*    `Thread Example 예제`

    ```java
    package week_10;
    
    public class ThreadExample extends Thread {
        @Override
        public void run() {
            System.out.println("This is Thread Example run()");
        }
    }
    ```



*   실행 - `start()`

쓰레드를 생성헀다고 해서 자동으로 실행되는 것은 아니다. start() 메서드릃 호출해야만 쓰레드가 실행된다. 

```java
t1.start();	// 쓰레드 t1 실행
t2.start(); // 쓰레드 t2 실행
```

사실은 start()가 호출되었다고 해서 바로 실행되는 것이 아니라 일단 실행대기 상태에 있다가 자신의 차례가 되어야 실행된다. 물론 실행대기 중인 쓰레드가 하나도 없으면 바로 실행상태가 된다. 

또한 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다. start()가 한 번만 호출될 수 있다는 뜻이다.  두 번 이상 호출하면 `IllegalThreadStateException`이 발생한다.

>   *쓰레드의 실행순서는 OS의 스케줄러가 작성한 스케줄에 의해 결정된다.*



*   start()와 run()

run() 아닌 start()를 호출하는 이유는 무엇일까? main 메서드에서 run()을 호출하는 것은 단순히 클래스에 선언된 메서드를 실행하는 것일 뿐이다.

반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성한 다음에 run()을 호출해서 생성도니 호출 스택에 run()이 첫 번째로 올라가게 한다.

모든 쓰레드는 독립적인 작업을 수행하기 위해서 자신만의 호출스택을 필요로 하기 때문에 새로운 쓰레드를 생성하고 실행시킬 때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다.



*    `선언 및 실행 예제`

     ```java
     package week_10;
     
     public class ExecuteExample {
         public static void main(String[] args) {
     
             // Runnable을 사용하여 Thread 생성
             RunnableExample runnable = new RunnableExample();
             new Thread(runnable).start();
             
             // Runnable은 다음과 같이 생성이 가능하다
             Thread thread = new Thread(new Runnable() {
              	@Override
                 public void run() {
                     System.out.println("This is Runnable Example run()");
                 }
             });
     
             // Runnable은 Lambda를 통해서도 생성이 가능하다.
             Thread thread = new Thread( () -> {
                System.out.println("This is Runnable Example run()")
             });
                   
             // Thread를 사용하여 Thread 생성
             ThreadExample thread = new ThreadExample();
             thread.start();
     
         }
     }
     ```

*   실행 결과

>   This is Runnable Example run()
>   This is Thread Example run()
>
>   Process finished with exit code 0



*   ThreadExameple 수정

```java
package week_10;

public class ThreadExample extends Thread {
    public ThreadExample(String valueOf) {
    }

    @Override
    public void run() {
        System.out.println("This is Thread Example run() \t And My Name is \t" + this.getName());
    }
}
```



*   Thread 배열을 선언하고 순서대로 실행되는지 확인하는 예제

```java
package week_10;

public class ThreadOrderExample {
    public static void main(String[] args) {
        Thread[] tArr = new ThreadExample[50];
        
        for (int i = 0; i < 50; i++) {
            Thread t = new ThreadExample(String.valueOf(i + 1));
            tArr[i] = t;
        }

        for (Thread thread : tArr) {
            thread.start();
        }
    }
}
```

*   출력결과

```
This is Thread Example run() 	 And My Name is 	Thread-1
This is Thread Example run() 	 And My Name is 	Thread-6
This is Thread Example run() 	 And My Name is 	Thread-13
This is Thread Example run() 	 And My Name is 	Thread-8
This is Thread Example run() 	 And My Name is 	Thread-21
.
.

This is Thread Example run() 	 And My Name is 	Thread-38
This is Thread Example run() 	 And My Name is 	Thread-44
This is Thread Example run() 	 And My Name is 	Thread-42

```

>   순서대로 실행되지 않는다는 것을 알 수 있다. Thread는 실행할 때 먼저 대기 상태로 진입하며 OS의 스케쥴링에 따라 실행되고, 컴퓨터의 성능에 따라 달리지기 때문이다.



## 쓰레드의 상태

>   스레드 객체를 생서하고 start() 메서드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만 실행대기 상태가 된다.

### 실행대기란 ?

*   아직 스케줄링이 되지 않아서 실행을 기다리는 상태이다.
*   실행대기 상태에 있는 스레드 중에서 스케줄링으로 선택된 스레드가 비로소 CPU를 점유하고 run() 메소드를 실행한다. 이때를 실행상태라고 한다.
*   실행 상태 스레드는 메서드를 모두 실행하기 전에 다시 실행 대기 상태로 돌아갈 수 있다. 그리고 실행 대기 상태에 있는 다른 실행 대기 스레드가 선택되어 실행 상태가 된다. 이런식으로 번갈아가면서 자신의 run() 메서드를 실행하고 모든  run()메서드가 종료되면 종료 상태가 되는 것이다.

###  경우에 따라서는 대기 상태로 가지 않을수도 있다.

## 쓰레드의 우선순위

쓰레드는 우선순위라는 속성을 가지고 있는데 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다. 쓰레드가 수행하는 작업의 주요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.

### 쓰레드의 우선순위 지정하기

쓰레드의 우선순위와 관련된 메서드와 상수는 다음과 같다.

```java
void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다.
int getPriority()

public static final int MAX_PRIORITY = 10 	// 최대 우선 순위
public static final int MIN_PRIORITY = 1	// 최소 우선 순위
public static final int NORM_PRIORITY = 5	// 보통 우선 순위
```

쓰레드가 가질 수 있는 우선순위의 범위는 1 ~ 10 사이이며 숫자가 높을수록 우선순위가 높다. 쓰레드의 우선 순위는 생성한 쓰레드로부터 상속 받는다. main 메서드를 수행하는 쓰레드는 우선순위가 5이므로 main 메서드 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5가 된다.



```java
```



## Main 쓰레드

main 메서드의 작업을 수행하는 것도 쓰레드이며 이를 main 쓰레드라고 한다. 프로그램이 실행되기 위해서는 작업을 수행하는 쓰레드가 최소한 하나가 필요하다. 그래서 프로그램을 실행하면 기본적으로 하나의 쓰레드를 생성하고 그 쓰레드가 main 메서드를 호출해서 작업이 수행되도록 하는 것이다.



```java
package week_10.main;

class ThreadEx2 {
    public static void main(String[] args) throws Exception {
        ThreadEx2_1 t1 = new ThreadEx2_1();
        t1.start();
    }
}

class ThreadEx2_1 extends Thread {
    @Override
    public void run() {
        throwException();
    }

    public void throwException() {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```
>> 실행결과

java.lang.Exception
	at week_10.main.ThreadEx2_1.throwException(ThreadEx2.java:18)
	at week_10.main.ThreadEx2_1.run(ThreadEx2.java:13)

Process finished with exit code 0
```

호출스택의 첫 번째 메서드가 main 메서드가 아니라 run 메서드이다. main 쓰레드의 호출스택이 없는 것은 main쓰레드가 이미 종료되었기 때문이다.

> **한 쓰레드가 예외가 발생해서 종료되어도 다른 쓰레드의 실행에는 영향을 미치지 않는다.**



```java
package week_10.main;

class ThreadEx3 {
    public static void main(String[] args) throws Exception{
        ThreadEx3_1 t1 = new ThreadEx3_1();
        t1.run();
    }
}

class ThreadEx3_1 extends Thread {
    @Override
    public void run() {
        throwException();
    }

    public void throwException() {
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```
>> 실행결과

java.lang.Exception
	at week_10.main.ThreadEx3_1.throwException(ThreadEx3.java:18)
	at week_10.main.ThreadEx3_1.run(ThreadEx3.java:13)
	at week_10.main.ThreadEx3.main(ThreadEx3.java:6)

Process finished with exit code 0
```

단순히 run()이 호출되었기 때문에 쓰레드가 생성되지 않았다. 

## 동기화



## 데드락



