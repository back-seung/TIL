# 지네릭스(Generics) - since JDK 1.5

## 지네릭스란?

> 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문의 객체의 **타입 안정성을 높이고 형변환의 번거로움을 줄인다.**



### 지네릭스의 장점 

1. 타입 안정성을 제공한다.

   의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입을 잘못 형변환되어 발생할 수 있는 오류를 줄여준다.

2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.



## 지네릭 클래스의 선언

> 지네릭 타입은 클래스와 메서드에 선언할 수 있다.

```java
// 일반 클래스
public class OldBox {
    Object item;

    void setItem(Object item) {
        this.item = item;
    }

    Object getItem() {
        return this.item;
    }
}

// 지네릭 클래스
public class Box<T> {
    private T item;

    void setItem(T item) {
        this.item = item;
    }
    
    T getItem() {
        return item;
    }
}
```

OldBox는 Object를 사용하는 반면에, Box 클래스는 클래스명 옆에 <T>를 붙히고 Object를 모두 T로 바꾸었다.

`T`를 타입 변수(type variable)라고 하며 T가 아닌 다른 것을 사용해도 된다. 가능하다면 상황에 맞게 의미있는 문자를 사용하는 것이 좋다(ArrayList<E>는 Element를 의미하고 Map<K,V>는 Key, Value를 의미한다.)

지네릭은 기호의 종류만 다를 뿐 임의의 참조형 타입을 의미한다는 것은 모두 같다.

지네릭 클래스가 된 Box의 객체를 생성할 때는 `T`라는 타입 대신에 실제로 사용될 타입을 지정해주어야 한다.

```java
Box<String> box = new Box<String>();
box.setItem("hello");		// OK
box.setItem(new Object());	// 에러 String 이외의 타입은 지정 불가.
String item = box.getItem(); 	// 형변환이 필요 없음
```

위의 코드에서 타입 T 대신 String으로 타입을 지정했으므로 지네릭 클래스 Box는 다음과 같이 정의된 것과 같다.

```java
public class Box {
    private String item;

    void setItem(String item) {
        this.item = item;
    }
    
    String getItem() {
        return item;
    }
}
```



타입을 지정하지 않는 예전의 방식으로 객체를 생성하는 것이 허용되지만 안전하지 않다는 경고가 발생한다. 이는 지네릭스가 도입되기 이전의 코드와 호환성을 유지하기 위해서 허용하는 것일 뿐, 지네릭 클래스를 사용할 때는 반드시 타입을 지정해서 관련 경고가 나오지 않도록 하자.



### 지네릭스의 용어

> class Box<T> {}
>
> * Box<T> - 지네릭 클래스.
> * T - 타입 변수 또는 타입 매개변수(T는 타입문자)
> * Box - 원시 타입(raw type)

```java
Box<String> box = new Box<String>();	// 지네릭 타입 호출
```

타입문자 T는 지네릭 클래스 Box<T>의 타입 변수 또는 타입 매개변수라고 한다. 위와 같이 타입 매개변수에 타입을 지정하는 것을 `지네릭 타입 호출`이라고 하고, 지정된 타입 String을 매개변수화된 타입(parameterized type)이라고 한다. 

컴파일 후에 Box<String>은 원시타입인 Box로 바뀐다.(지네릭 타입이 제거된다)



### 지네릭스의 제한

Box의 객체를 생성할 때 객체별로 다른 타입을 지정하는 것은 적절하다. 인스턴스별로 다르게 동작하도록 하려고 만든 기능이기 때문이다.

```java
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
```

그러나 모든 객체에 대해 동일하게 동작해야 하는 `static`멤버에 타입 변수 T를 사용할 수 없다. T는 인스턴스변수로 간주된다. **static멤버는 타입 변수에 지정된 타입의 종류에 관계없이 동일한 것이어야 하기 때문에 인스턴스변수를 참조할 수 없다.**

```java
class Box<T> {
	static T item;	// 에러
  static int compare(T t1, T t2) { ... } 	// 에러
  ...
}
```

또한 지네릭 타입의 배열도 생성할 수 없다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 `new T[10]`과 같은 배열 선언은 안된다. 이는 new 연산자 때문인데 이 연산자는 컴파일 시점에 T가 뭔지 정확히 알아야 한다. 하지만 컴파일 시점에서 Box<T>의 T가 어떤 타입이 될지 전혀 알 수 없다. instanceof 연산자도 같은 이유로 사용할 수 없다.

꼭 지네릭 배열을 생성해야 할 필요가 있을 때는 `Reflection API`의 `newInstance()`와 같이 동적으로  객체를 생성하는 메서드로 배열을 생성하거나 Object 배열을 생성해서 복사한 다음 `T[]`로 형변환하는 방법 등을 사용한다.



## 지네릭 클래스의 객체 생성과 사용

```java
class Box<T> {
  ArrayList<T> list = new ArrayList<T>();
  
  void add(T item) {	list. add(item); }
  T get(int i) { return list.get(i); }
  ArrayList<T> getList() { return list; }
  int size() { return list.size(); }
  public String toString() { return list.toString(); }
}
```

위 처럼 정의된 Box<T>의 객체에는 한 가지 종류, T타입의 객체만 저장할 수 있다.

객체를 생성할 때는 다음과 같이 한다. 참조 변수와 생성자에 대입된 타입이 일치해야 한다. 일치하지 않으면 에러가 발생한다.

```java
Box<Apple> appleBox = new Box<Apple>(); 	// OK
Box<Apple> appleBox = new Box<Grape>();		// Error
```

두 타입이 상속관계에 있어도 마찬가지다. Apple이 Fruit의 자손이라고 가정한다.

```java
Box<Fruit> appleBox = new Box<Apple>();		// Error. 대입된 타입이 다르다.
```

단 지네릭 클래스의 타입이 상속관계에 있고 대입된 타입이 같은 것은 괜찮다.

```java
Box<apple> appleBox = new FruitBox<apple>();	// OK 다형성
```

JDK 1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다. 참조 변수의 타입으로부터 Box가 Apple의 객체만 저장한다는 것을 알 수 있기 때문에 생성자에 따로 타입을 지정해주지 않아도 된다.

```java
Box<Apple> appleBox = new Box<>();
```

생성된 Box<T>의 객체에 void add(T item)으로 객체를 추가할 때 대입된 타입과 다른 타입의 객체는 추가할 수 없다. 그러나 타입 T가 Fruit인 경우 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다. Apple이 Fruit의 자손이라고 가정한다.

```java
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());		// OK
fruitBox.add(new Apple());		// OK
```



## 제한된 지네릭 클래스

> 타입 문자로 사용할 타입을 명시하면 한 종류의 타입만 저장할 수 있도록 제한할 수 있지만 여전히 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없다.
>
> **이 때, 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한할 수 있는 방법은 `extends`를 사용하는 것이다.**

```java
class FruitBox<T extends Fruit> {	// Fruit의 자손만 타입으로 지정가능
  ArrayList<T> list = new ArrayList<T>();
  ...
}
```

여전히 한 종류의 타입만 담을 수 있지만 Fruit클래스와 그 자손들만 담을 수 있다는 제한이 더 추가되었다. 

add()메서드의 매개변수 T 또한 Fruit과 그 자손들을 담을 수 있게 된다. 다형성에서 조상타입의 참조변수로 자손타입의 객체를 가리킬 수 있는 것처럼 매개변수화된 타입의 자손 타입도 가능한 것이다. 만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면 이때도 extends를 사용한다. **implements가 아니다.**

```java
interface Eatable {}
class FruitBox<T extends Eatable> { ... }
```

클래스 Fruit의 자손이면서 Eatable을 구현해야 한다면 `&`기호를 사용한다.

```java
class FruitBox<T extends Fruit & Eatable> { ... }
```



## 와일드 카드

> 가정 : 매개변수에 과일박스를 대입하면 주스를 만들어서 반환하는 Juicer라는 클래스가 있고, 이 클래스에는 과일을 주스로 만들어 반환하는 makeJuice()라는 static 메서드가 다음과 같이 정의되어있다.

```java
class Juicer {	// 지네릭 클래스가 아님
	static Juice makeJuice(FruitBox<Fruit> box) {
  	String tmp = "";
    for(Fruit f : box.getList()) {
      tmp += f + " ";
      return new Juice(tmp);
    }
  }
}
```

Juicer 클래스는 지네릭 클래스가 아닌데다, 지네릭 클래스라고 해도 static 메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로 아예 지네릭스를 적용하지 않던가 위와 같이 타입 매개변수 대신, 특정 타입을 지정해줘야 한다. 

그러면 Fruit으로 지정해둔 T의 타입을 같은 이름의 메서드로 오버로딩하여 Apple, Grape 등으로 만들어 두면 괜찮지 않을까? 

```java
static Juice makeJuice(FruitBox<Fruit> box) { // Fruit로 타입 지정
  	String tmp = "";
    for(Fruit f : box.getList()) {
      tmp += f + " ";
      return new Juice(tmp);
    }
}

static Juice makeJuice(FruitBox<Apple> box) { // Apple로 타입 지정
  	String tmp = "";
    for(Fruit f : box.getList()) {
      tmp += f + " ";
      return new Juice(tmp);
    }
}
```

오버로딩을 하면 컴파일 에러가 발생한다. 왜냐면 **지네릭 타입이 다른 것만으로는 오버로딩이 성립되지 않기 때문이다.** 지네릭 타입은 컴파일때만 사용하고 이후에는 제거해버린다. 그러면 위 메서드 2개는 오버로딩이 아니라 메서드 중복인 것이다. 이럴 때 와일드 카드를 사용한다. 와일드 카드는 `?`기호로 표현하는데 어떠한 타입도 될 수 있다는 것을 의미한다.



`?`만으로는 Object와 다를게 없으므로 extends, super로 상한과 하한을 제한할 수 있다.

> * <? extends T> - 와일드 카드의 상한 제한. T와 그 자손들만 가능
> * <? super T> - 와일드 카드의 하한 제한. T와 그 조상들만 가능
> * <?> - 제한 없음. 모든 타입이 가능 <? extends Object>와 동일

와일드 카드를 사용해서 makeJuice()의 매개변수 타입을 FruitBox<Fruit>에서 FruitBox<? extends Fruit>으로 바꾸면 다음과 같이 된다.

```java
static Juice makeJuice(FruitBox<? extends Fruit> box) {
  	String tmp = "";
    for(Fruit f : box.getList()) {
      tmp += f + " ";
      return new Juice(tmp);
    }
}
```

매개변수의 타입을 <? extends Object>로 했을 때는 모든 종류의 FruitBox가 매개변수로 가능하다. 하지만 for문에서 box의 요소가 Fruit의 자손이라는 보장이 없기 때문에 Fruit타입의 참조변수가 받지 못하는데 컴파일은 문제 없이 된다. 이는 지네릭 클래스 FruitBox를 <T extends Fruit>로 제한했기 때문이다.
