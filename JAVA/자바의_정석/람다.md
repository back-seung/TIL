# 람다

## 람다식(Lambda Expression)이란

자바는 처음 등장한 이후 두 번의 큰 변화를 겪었는데 이 중 하나가 람다이다. 람다식은 JDK1.8부터 등장했으며 자바는 객체지향 언어임과 동시에 함수형 프로그래밍 언어가 되었다.

람다식은 익명함수라고도 하는데 이는 람다식을 사용하게 되면 메서드명과 리턴값이 없기 때문이다.

```java
int[] arr = new int[5];

// 람다 미적용 - 메서드명 있음, 리턴값 있음
int method() {
	return (int) (Math.random() * 5) +1; 
}

// 람다 적용 - 메서드명 없음, 리턴값 없음
Arrays.setAll(arr, (i) -> (int) (Math.random() * 5) +1);
```

람다는 메서드를 위한 클래스를 새로 만들고, 메서드를 위한 객체를 생성하는 일련의 과정들이 필요하지 않다. 

또한 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고 메서드의 결과로도 반환될 수 있다.



## 람다식 작성

반환타입과 메서드이름을 제거하고 매개변수 선언부와 구현부 사이에 `->` 를 추가한다.

```java
// 람다 미적용
반환타입 메서드이름(매개변수 선언) {
    문장들
}

// 람다 적용
(매개변수 선언) -> {
    문장들
}
```



### 예제

```java
int max(int a, int b) {
    return a > b ? a : b;
}

(int a, int b) -> {
	a > b ? a : b;
}
```

리턴값이 있는 경우 return문 대신 식을 활용할 수 있다. 식의 연산결과가 자동으로 리턴값이 된다. 이 때는 문장이 아닌 식이므로 `;`를 붙히지 않는다. 



### 매개변수가 하나인 경우

* 매개변수가 하나인 경우에는 ()를 생략할 수 있다. 단, 매개변수에 타입이 있으면 생략이 불가능하다.
* 마찬가지로 구현부에 문장이 하나일 경우에는 {}를 생략할 수 있다. 이때 문장 끝에 세미콜론을 붙히면 안된다. 하지만 return이 있는 경우에는 {}를 생략할 수 없다.

```java
a -> a * a // (O) 
int a -> a * a // (X)
(int a) -> a * a // (O)
    
// BEFORE
(String name, int i) -> {
    System.out.println(name + "=" + i) 
}

// AFTER
(String name, int i) -> System.out.println(name + "=" + i)
   
// ERROR CASE
(int a, int b) -> { return a > b ? a : b; } // (O)
(int a, int b) -> return a > b ? a : b; // (X)
```



### 메서드를 람다식으로 표현한다면

* CASE 1 - method

```java
int max(int a, int b) {
    return a > b ? a : b;
}
```

* CASE 1 - lambda

```java
// 1.
(int a, int b) -> {
    return a > b ? a : b;
}

// 2.
(int a, int b) -> a > b ? a : b 

// 3.
(a, b) -> a > b ? a : b 
```



* CASE 2 - method

```java
void printVar(String name, int i) {
    System.out.println(name + " = " + i);
}
```

* CASE 2 - lambda

```java
// 1. 
(String name, int i) -> {
    System.out.println(name + " = " + i);
}

// 2.
(name, i) -> {
    System.out.println(name + " = " + i)
}

// 3.
(name, i) -> System.out.println(name + " = " + i)
```



* CASE 3 - method

```java
int square(int x) {
    return x * x;
}
```

* CASE 3- lambda

```java
// 1.
(int x) -> { return x * x; }

// 2.
(x) -> x * x
    
// 3.
x -> x * x
```



* CASE 4 - method

```java
int roll() {
    return (int) (Maht.random() * 6);
}
```

* CASE 4 - lambda

```java
// 1.
() -> { return (int) (Maht.random() * 6); }

```



* CASE 5 - method

```java
int sumAll(int[] arr) {
	int sum = 0;
    for(int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```

* CASE 5 - lambda

```java
// 1.
(int[] arr) -> {
	int sum = 0;
    for(int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```



## 함수형 인터페이스(Functional Interface)

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데 람다식은 익명 클래스의 객체와 동등하다.

```java
(int a, int b) -> a > b ? a : b
    
// <->
    
new Object() {
    int max(int a, int b) {
	    return a > b ? a : b;
    }
}
```



참조변수가 있어야 정의된 익명 객체의 메서드를 호출할 수 있다. 이 익명 객체의 주소를 f라는 참조변수에 저장해보자.

```java
타입 f = (int a, int b) -> a > b ? a : b;		// 참조변수의 타입을 뭘로 해야 할까?
```

참조변수 f의 타입은 무엇이 되어야할까? 참조형이니까 클래스 || 인터페이스여야 가능하다. 또한 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다. 그래야만 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.



### max()라는 메서드가 정의된 MyFunction 클래스가 있다.

* 인터페이스

```java
interface MyFunction {
    public abstract int max(int a, int b);
}
```

* 구현 객체

```java
MyFunction f = new MyFunction() {
    				public int max(int a, int b) {
                        return a > b ? a : b;
                    }
				};
```

MyFunction 인터페이스에 정의된 메서드 max()는 람다식 `(int a, int b) -> a > b ? a : b;	`과 메서드의 선언부가 일치한다. 그래서 위 코드의 익명 객체를 람다식으로 대체할 수 있다.

* 람다식

```java
MyFunction f = (int a, int b) -> a > b ? a : b; // 익명 객체를 람다식으로 대체
int big = f.max(5, 3); 	// 익명 객체의 메서드를 호출
```

이처럼 인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는 람다식도 하나의 익명 객체이고 MyFunction 인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.

* 함수형 인터페이스

```java
@FunctionalInterface
interface MyFunction {	// 함수형 인터페이스 정의
    public abstract int max(int a, int b);
}
```

단, 함수형 인터페이스는 **단 하나의 추상 메서드만을 정의하고 있어야 한다.** 그래야 람다식과 메서드가 1:1 관계로 연결될 수 있다. static, default 메서드는 개수제한이 없다.



### 함수형 인터페이스 타입의 매개변수와 반환 타입

* MyFunction

```java
@FunctionalInterface
interface MyFunction {	// 함수형 인터페이스 정의
	void myMethod();		// 추상 메서드
}
```

* 메서드의 매개변수가 MyFunction 타입이면 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야 한다는 뜻이다.

```java
void aMethod(MyFunction f) {	// 매개변수의 타입이 함수형 인터페이스
    f.myMethod();				// MyFunction에 정의된 메서드 호출
}
	...
MyFunction f = () -> System.out.println("myMethod()");	// 추상 메서드 구현
aMethod(f);
```

* 참조변수 없이 직접 람다식을 매개변수로 지정하는 방법

```java
MyFunction f = () -> System.out.println("myMethod()");	// 람다식이 매개변수
```

람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 변수처럼 메서드를 주고받는 것이 가능해진다.



### 예제

```java
package lambda;

@FunctionalInterface
interface MyFunction {
    void run(); // public abstract void run()
}

public class LambdaEx1 {
    static void execute(MyFunction f) {
        f.run();
    }

    static MyFunction getMyFunction() {
        MyFunction f = () -> System.out.println("f3.run()");
        return f;
    }

    public static void main(String[] args) {
        // 람다식으로 MyFunction run() 구현
        MyFunction f1 = () -> System.out.println("f1.run()");

        MyFunction f2 = new MyFunction() {
            @Override
            public void run() {
                System.out.println("f2.run()");
            }
        };

        MyFunction f3 = getMyFunction();

        f1.run();
        f2.run();
        f3.run();

        execute(f1);
        execute(() -> {
            System.out.println("run()");
        });
    }
}
```



### 람다식의 타입과 형변환

함수형 인터페이스로 람다식을 참조할 수 있는 것일 뿐, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아니다. 람다식은 익명 객체이고, 익명 객체는 타입이 없다(정확히는 타입이 있지만 컴파일러가 이름을 마음대로 정한다).

그래서 대입 연산자의 양변의 타입을 일치시키기 위해 아래와 같이 형변환이 필요하다.

```java
MyFunction f = (MyFunction) (() -> {}); // 양변의 타입이 다르므로 형변환이 필요하다.
```

람다식은 MyFunction 인터페이스를 직접 구현하지 않았지만 이 인터페이스를 구현한 클래스의 객체와 완전히 동일하기 때문에 위와 같은 형변환을 허용한다. 그리고 이 형변환은 **생략이 가능하다.**



람다식은 오직 함수형 인터페이스로만 형변환이 가능하다.

```java
Object obj = (Object) (() -> {});	// 에러. 함수형 인터페이스로만 형변환 가능
```

하지만 해결법도 있는 법이다.

```java
Object obj = (Object)(MyFunction) (() -> {});
String str = ((Object)(MyFunction) (() -> {})).toString();
```



### 예제 - 형변환

```java
package lambda;

@FunctionalInterface
interface MyFunction2 {
    void myMethod();
}

public class LambdaEx2 {
    public static void main(String[] args) {
        MyFunction f = (() -> {});
        f = (MyFunction) (()-> {});
        Object obj = (Object) (MyFunction) (() -> {});
        String str = ((Object) (MyFunction) (() -> {})).toString();

        System.out.println(f);
        System.out.println(obj);
        System.out.println(str);

        System.out.println((MyFunction) (() -> {}));
        System.out.println((Object) (MyFunction) (()->{}));
    }
}
```

* 실행 결과

```
lambda.LambdaEx2$$Lambda$2/2093631819@58372a00
lambda.LambdaEx2$$Lambda$3/2074407503@4dd8dc3
lambda.LambdaEx2$$Lambda$4/999966131@7699a589
lambda.LambdaEx2$$Lambda$5/1828972342@568db2f2
lambda.LambdaEx2$$Lambda$6/931919113@5fd0d5ae
```

익명 객체라면 `외부클래스이름$번호`와 같은 형식으로 타입이 결정되었을 텐데, 람다식의 타입은 `외부클래스타입$$Lambda$번호`와와 같은 형식으로 되어있다.



### 외부 변수를 참조하는 람다식

```java
package lambda;

@FunctionalInterface
interface MyFunction3 {
    void myMethod();
}

public class Outer {
    int val = 10;

    class Inner {
        int val = 20;

        void method(int i) {
            int val = 30;
//            i = 10; // 에러. 상수의 값을 변경할 수 없음

            MyFunction3  f = () -> {
                System.out.println("            i : " + i);
                System.out.println("            val : " + val);
                System.out.println("            this.val : " + ++this.val);
                System.out.println("            Outer.this.val : " + ++Outer.this.val);
            };

            f.myMethod();
        }
    }
}

class LambdaEx3 {
    public static void main(String[] args) {
        Outer outer = new Outer();
        Outer.Inner inner = outer.new Inner();
        inner.method(100);
    }
}
```

* 실행결과

```
            i : 100
            val : 30
            this.val : 21
            Outer.this.val : 11
```

이 에제는 람다식 내에서 외부에 선언된 변수에 접근하는 방법을 보여준다. 람다식 내에서 참조하는 지역변수는 final이 붙지 않아도 상수로 간주된다. 람다식 내에서 지역변수 i와 val을 참조하고 있으므로 람다식 내에서나 다른 어느 곳에서도 이 변수들의 값을 변경하는 일은 허용되지 않는다.

반면에 Inner 클래스, Outer클래스의 인스턴스 변수인 this.val, Outer.this.val은 상수로 간주되지 않으므로 값을 변경해도 된다.

그리고 외부 지역변수와 같은 이름의 람다식 매개변수는 허용되지 않는다.

