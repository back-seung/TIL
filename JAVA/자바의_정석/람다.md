# 람다

## 람다식(Lambda Expression)이란

자바는 처음 등장한 이후 두 번의 큰 변화를 겪었는데 이 중 하나가 람다이다. 람다식은 JDK1.8부터 등장했으며 자바는 객체지향 언어임과 동시에 함수형 프로그래밍 언어가 되었다.

람다식은 익명함수라고도 하는데 이는 람다식을 사용하게 되면 메서드명과 리턴값이 없기 때문이다.

```java
int[] arr = new int[5];

// 람다 미적용 - 메서드명 있음, 리턴값 있음
int method() {
	return (int) (Math.random() * 5) +1; 
}

// 람다 적용 - 메서드명 없음, 리턴값 없음
Arrays.setAll(arr, (i) -> (int) (Math.random() * 5) +1);
```

람다는 메서드를 위한 클래스를 새로 만들고, 메서드를 위한 객체를 생성하는 일련의 과정들이 필요하지 않다. 

또한 람다식은 메서드의 매개변수로 전달되어지는 것이 가능하고 메서드의 결과로도 반환될 수 있다.



## 람다식 작성

반환타입과 메서드이름을 제거하고 매개변수 선언부와 구현부 사이에 `->` 를 추가한다.

```java
// 람다 미적용
반환타입 메서드이름(매개변수 선언) {
    문장들
}

// 람다 적용
(매개변수 선언) -> {
    문장들
}
```



### 예제

```java
int max(int a, int b) {
    return a > b ? a : b;
}

(int a, int b) -> {
	a > b ? a : b;
}
```

리턴값이 있는 경우 return문 대신 식을 활용할 수 있다. 식의 연산결과가 자동으로 리턴값이 된다. 이 때는 문장이 아닌 식이므로 `;`를 붙히지 않는다. 



### 매개변수가 하나인 경우

* 매개변수가 하나인 경우에는 ()를 생략할 수 있다. 단, 매개변수에 타입이 있으면 생략이 불가능하다.
* 마찬가지로 구현부에 문장이 하나일 경우에는 {}를 생략할 수 있다. 이때 문장 끝에 세미콜론을 붙히면 안된다. 하지만 return이 있는 경우에는 {}를 생략할 수 없다.

```java
a -> a * a // (O) 
int a -> a * a // (X)
(int a) -> a * a // (O)
    
// BEFORE
(String name, int i) -> {
    System.out.println(name + "=" + i) 
}

// AFTER
(String name, int i) -> System.out.println(name + "=" + i)
   
// ERROR CASE
(int a, int b) -> { return a > b ? a : b; } // (O)
(int a, int b) -> return a > b ? a : b; // (X)
```



### 메서드를 람다식으로 표현한다면

* CASE 1 - method

```java
int max(int a, int b) {
    return a > b ? a : b;
}
```

* CASE 1 - lambda

```java
// 1.
(int a, int b) -> {
    return a > b ? a : b;
}

// 2.
(int a, int b) -> a > b ? a : b 

// 3.
(a, b) -> a > b ? a : b 
```



* CASE 2 - method

```java
void printVar(String name, int i) {
    System.out.println(name + " = " + i);
}
```

* CASE 2 - lambda

```java
// 1. 
(String name, int i) -> {
    System.out.println(name + " = " + i);
}

// 2.
(name, i) -> {
    System.out.println(name + " = " + i)
}

// 3.
(name, i) -> System.out.println(name + " = " + i)
```



* CASE 3 - method

```java
int square(int x) {
    return x * x;
}
```

* CASE 3- lambda

```java
// 1.
(int x) -> { return x * x; }

// 2.
(x) -> x * x
    
// 3.
x -> x * x
```



* CASE 4 - method

```java
int roll() {
    return (int) (Maht.random() * 6);
}
```

* CASE 4 - lambda

```java
// 1.
() -> { return (int) (Maht.random() * 6); }

```



* CASE 5 - method

```java
int sumAll(int[] arr) {
	int sum = 0;
    for(int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```

* CASE 5 - lambda

```java
// 1.
(int[] arr) -> {
	int sum = 0;
    for(int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}
```



## 함수형 인터페이스(Functional Interface)

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데 람다식은 익명 클래스의 객체와 동등하다.

```java
(int a, int b) -> a > b ? a : b
    
// <->
    
new Object() {
    int max(int a, int b) {
	    return a > b ? a : b;
    }
}
```



참조변수가 있어야 정의된 익명 객체의 메서드를 호출할 수 있다. 이 익명 객체의 주소를 f라는 참조변수에 저장해보자.

```java
타입 f = (int a, int b) -> a > b ? a : b;		// 참조변수의 타입을 뭘로 해야 할까?
```

참조변수 f의 타입은 무엇이 되어야할까? 참조형이니까 클래스 || 인터페이스여야 가능하다. 또한 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다. 그래야만 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.



### max()라는 메서드가 정의된 MyFunction 클래스가 있다.

* 인터페이스

```java
interface MyFunction {
    public abstract int max(int a, int b);
}
```

* 구현 객체

```java
MyFunction f = new MyFunction() {
    				public int max(int a, int b) {
                        return a > b ? a : b;
                    }
				};
```

MyFunction 인터페이스에 정의된 메서드 max()는 람다식 `(int a, int b) -> a > b ? a : b;	`과 메서드의 선언부가 일치한다. 그래서 위 코드의 익명 객체를 람다식으로 대체할 수 있다.

* 람다식

```java
MyFunction f = (int a, int b) -> a > b ? a : b; // 익명 객체를 람다식으로 대체
int big = f.max(5, 3); 	// 익명 객체의 메서드를 호출
```

이처럼 인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는 람다식도 하나의 익명 객체이고 MyFunction 인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.

* 함수형 인터페이스

```java
@FunctionalInterface
interface MyFunction {	// 함수형 인터페이스 정의
    public abstract int max(int a, int b);
}
```

단, 함수형 인터페이스는 **단 하나의 추상 메서드만을 정의하고 있어야 한다.** 그래야 람다식과 메서드가 1:1 관계로 연결될 수 있다. static, default 메서드는 개수제한이 없다.



### 함수형 인터페이스 타입의 매개변수와 반환 타입

* MyFunction

```java
@FunctionalInterface
interface MyFunction {	// 함수형 인터페이스 정의
	void myMethod();		// 추상 메서드
}
```

* 메서드의 매개변수가 MyFunction 타입이면 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야 한다는 뜻이다.

```java
void aMethod(MyFunction f) {	// 매개변수의 타입이 함수형 인터페이스
    f.myMethod();				// MyFunction에 정의된 메서드 호출
}
	...
MyFunction f = () -> System.out.println("myMethod()");	// 추상 메서드 구현
aMethod(f);
```

* 참조변수 없이 직접 람다식을 매개변수로 지정하는 방법

```java
MyFunction f = () -> System.out.println("myMethod()");	// 람다식이 매개변수
```

람다식을 참조변수로 다룰 수 있다는 것은 메서드를 통해 람다식을 주고받을 수 있다는 것을 의미한다. 변수처럼 메서드를 주고받는 것이 가능해진다.



### 예제

```java
package lambda;

@FunctionalInterface
interface MyFunction {
    void run(); // public abstract void run()
}

public class LambdaEx1 {
    static void execute(MyFunction f) {
        f.run();
    }

    static MyFunction getMyFunction() {
        MyFunction f = () -> System.out.println("f3.run()");
        return f;
    }

    public static void main(String[] args) {
        // 람다식으로 MyFunction run() 구현
        MyFunction f1 = () -> System.out.println("f1.run()");

        MyFunction f2 = new MyFunction() {
            @Override
            public void run() {
                System.out.println("f2.run()");
            }
        };

        MyFunction f3 = getMyFunction();

        f1.run();
        f2.run();
        f3.run();

        execute(f1);
        execute(() -> {
            System.out.println("run()");
        });
    }
}
```

