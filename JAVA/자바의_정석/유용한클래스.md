# java.lang 패키지와 유용한 클래스



## java.lang 패키지

>   자바 프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다. 그렇기 때문에 java.lang 패키지의 클래스들은 import문 없이도 사용할 수 있게 되어 있다. 

그동안 우리가 String 클래스나 System 클래스를 import문 없이 사용할 수 있었던 이유가 바로 java.lang 패키지에 속한 클래스들이기 때문이다. 

자주 사용되는 클래스 몇 가지를 알아보자.

## Object 클래스

>   Object 클래스는 모든 클래스의 최고 조상이기 때문에 자바의 모든 클래스는 Object 멤버를 바로 사용할 수 있다.

### Object 클래스의 메서드

>   Object 클래스는 멤버변수는 없고 오직 11개의 메서드만 가지고 있다.

| Object 클래스의 메서드                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| protected Object clone()                                     | 객체 자신의 복사본을 반환한다.                               |
| public boolean equals(Object obj)                            | 객체 자신과 obj가 같은 객체인지 알려준다(같으면 true)        |
| protected void finalize()                                    | 객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야 하는 코드가 있을 때 오버라이딩 (거의 사용안함) |
| public Class getClass()                                      | 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환한다. |
| public  int hashcode()                                       | 객체 자신의 해시코드를 반환한다.                             |
| public String toString()                                     | 객체 자신의 정보를 문자열로 반환한다.                        |
| public void notify()                                         | 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.      |
| public void notifyAll()                                      | 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.        |
| public void wait()<br />public void wait(long timeout)<br />public void wait(long timeout, int nanos) | 다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간 동안 기다리게 한다. |

위 메서드 중 내가 잘 모르는 것을 책을 보며 다시 정리해본다.

*   hashcode()

    *   해싱기법에 사용되는 해시함수를 구현한 것이다. 해싱은 데이터 관리 기법 중의 하나인데 **다량의 데이터를 저장하고 검색하는 데 유용**하다. 해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.
    *   해시코드가 같은 두 객체가 존재하는 것이 가능하지만, Object 클래스에 정의된 hashCode 메서드는 두 객체의 주소값으로 해시코드를 만들어 반환하기 때문에 32bit  JVM에서는 같은 해시코드를 가질 수 없었지만, 64bit에서는 JVM에서는 8 byte 주소값으로 해시코드(4 byte)를 만들기 때문에 해시코드가 중복될 수 있다.

    ```java
    class HashCodeEx1 {
    	public static void main(String[] args) {
            String str1 =  new String("abc");
            String str2 =  new String("abc");
            
            System.out.println(str1.equals(str2));
            System.out.println(str1.hashCode());
            System.out.println(str2.hashCode());
            System.out.println(System.identityHashCode(str1));
            System.out.println(System.identityHashCode(str2));
    	}
    }
    ```

    ```java
    >> 실행결과
    true
    96354
    96354
    2133927002
    1836019240
    ```

    1.   String 클래스는 문자열의 내용이 같으면 같은 해시코드를 반환한다.
    2.   System.identityHashCode(Object x)는 Object 클래스의 hashCode 메서드처럼 객체의 주소값으로 해시코드를 생성하기 때문에 모든 객체에 대해 항상 다른 해시코드값을 반환할 것을 보장한다.



*   clone()

    *   자신을 복제하여 새로운 인스턴스를 생성한다. 

    *   어떤 인스턴스에 대해 작업을 할 때 원래의 인스턴스는 보존하고 clone 메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업 이전의 값이 보존되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경되기 전의 값을 참고하는데 도움이 된다.

    *   Object 클래스에 정의된 `clone()` 메서드는 단순히 인스턴스 변수의 값만 복사하기 때문에 참조타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다. 

    *   clone()을 사용하려면 Cloneable 인터페이스를 구현해야하고, clone()을 오버라이딩함녀서 접근자를 public으로 변경한다. 그래야만 상속관계가 없는 다른 클래스에서 호출 할 수 있다. 

        ```java
        public class Object {
            ...
          protected native Object clone() throws CloneNotSupportedException;
            ...
        }
        ```

        ```java
        class Point implements Cloneable { // Cloneable 인터페이스 구현, 인스턴스의 데이터를 복제하기 위함임.
            ...
            public Object clone() { // 접근 제어자를 public 으로 변경
                Object obj = null;
                try {
                    obj = super.clone();	// try - catch 내에서 조상클래스 clone() 호출
                } catch (CloneNotSupportedException e) {}
                return obj;
            }
        }
        ```

    *   공변 반환타입

        : 조상 메서드의 반환타입을 자손 클래스의 타입으로 변경을 허용하는 것이다. 

        ```java
        public Point clone() { // 반환타입을 Point 로 변경
         	Object obj = null;
            try  {
                obj = super.clone();
        	} catch (CloneNotSupportedException) {
                
            }
            return (Point)obj; // Point 타입으로 형변환한다.
        }
        ```

        공변 반환타입을 사용하면 조상의 타입이 아닌 실제로 반환되는 자손 객체의 타입으로 반환할 수 있어서 번거로운 형변환이 줄어든다는 장점이 있다.

        
