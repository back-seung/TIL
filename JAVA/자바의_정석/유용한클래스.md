# java.lang 패키지와 유용한 클래스



## java.lang 패키지

>   자바 프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다. 그렇기 때문에 java.lang 패키지의 클래스들은 import문 없이도 사용할 수 있게 되어 있다. 

그동안 우리가 String 클래스나 System 클래스를 import문 없이 사용할 수 있었던 이유가 바로 java.lang 패키지에 속한 클래스들이기 때문이다. 

자주 사용되는 클래스 몇 가지를 알아보자.

## Object 클래스

>   Object 클래스는 모든 클래스의 최고 조상이기 때문에 자바의 모든 클래스는 Object 멤버를 바로 사용할 수 있다.

### Object 클래스의 메서드

>   Object 클래스는 멤버변수는 없고 오직 11개의 메서드만 가지고 있다.

| Object 클래스의 메서드                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| protected Object clone()                                     | 객체 자신의 복사본을 반환한다.                               |
| public boolean equals(Object obj)                            | 객체 자신과 obj가 같은 객체인지 알려준다(같으면 true)        |
| protected void finalize()                                    | 객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야 하는 코드가 있을 때 오버라이딩 (거의 사용안함) |
| public Class getClass()                                      | 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환한다. |
| public  int hashcode()                                       | 객체 자신의 해시코드를 반환한다.                             |
| public String toString()                                     | 객체 자신의 정보를 문자열로 반환한다.                        |
| public void notify()                                         | 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.      |
| public void notifyAll()                                      | 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.        |
| public void wait()<br />public void wait(long timeout)<br />public void wait(long timeout, int nanos) | 다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간 동안 기다리게 한다. |

위 메서드 중 내가 잘 모르는 것을 책을 보며 다시 정리해본다.

### hashcode()

*   해싱기법에 사용되는 해시함수를 구현한 것이다. 해싱은 데이터 관리 기법 중의 하나인데 **다량의 데이터를 저장하고 검색하는 데 유용**하다. 해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.
*   해시코드가 같은 두 객체가 존재하는 것이 가능하지만, Object 클래스에 정의된 hashCode 메서드는 두 객체의 주소값으로 해시코드를 만들어 반환하기 때문에 32bit  JVM에서는 같은 해시코드를 가질 수 없었지만, 64bit에서는 JVM에서는 8 byte 주소값으로 해시코드(4 byte)를 만들기 때문에 해시코드가 중복될 수 있다.

```java
class HashCodeEx1 {
	public static void main(String[] args) {
        String str1 =  new String("abc");
        String str2 =  new String("abc");
        
        System.out.println(str1.equals(str2));
        System.out.println(str1.hashCode());
        System.out.println(str2.hashCode());
        System.out.println(System.identityHashCode(str1));
        System.out.println(System.identityHashCode(str2));
	}
}
```

```java
>> 실행결과
true
96354
96354
2133927002
1836019240
```

1.   String 클래스는 문자열의 내용이 같으면 같은 해시코드를 반환한다.
2.   System.identityHashCode(Object x)는 Object 클래스의 hashCode 메서드처럼 객체의 주소값으로 해시코드를 생성하기 때문에 모든 객체에 대해 항상 다른 해시코드값을 반환할 것을 보장한다.



### clone()

*   자신을 복제하여 새로운 인스턴스를 생성한다. 

*   어떤 인스턴스에 대해 작업을 할 때 원래의 인스턴스는 보존하고 clone 메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업 이전의 값이 보존되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경되기 전의 값을 참고하는데 도움이 된다.

*   Object 클래스에 정의된 `clone()` 메서드는 단순히 인스턴스 변수의 값만 복사하기 때문에 참조타입의 인스턴스 변수가 있는 클래스는 완전한 인스턴스 복제가 이루어지지 않는다. 

*   clone()을 사용하려면 Cloneable 인터페이스를 구현해야하고, clone()을 오버라이딩함녀서 접근자를 public으로 변경한다. 그래야만 상속관계가 없는 다른 클래스에서 호출 할 수 있다. 

    ```java
    public class Object {
        ...
      protected native Object clone() throws CloneNotSupportedException;
        ...
    }
    ```

    ```java
    class Point implements Cloneable { // Cloneable 인터페이스 구현, 인스턴스의 데이터를 복제하기 위함임.
        ...
        public Object clone() { // 접근 제어자를 public 으로 변경
            Object obj = null;
            try {
                obj = super.clone();	// try - catch 내에서 조상클래스 clone() 호출
            } catch (CloneNotSupportedException e) {}
            return obj;
        }
    }
    ```

### 공변 반환타입

: 조상 메서드의 반환타입을 자손 클래스의 타입으로 변경을 허용하는 것이다. 

```java
public Point clone() { // 반환타입을 Point 로 변경
 	Object obj = null;
    try  {
        obj = super.clone();
	} catch (CloneNotSupportedException) {
        
    }
    return (Point)obj; // Point 타입으로 형변환한다.
}
```

공변 반환타입을 사용하면 조상의 타입이 아닌 실제로 반환되는 자손 객체의 타입으로 반환할 수 있어서 번거로운 형변환이 줄어든다는 장점이 있다.



### 얕은 복사와 깊은 복사

*   얕은 복사

    clone()은 단순히 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복제하지는 않는다. 원본과 복제본이 같은 객체를 공유하므로 완전한 복제라고 보기 어렵다. 

*   깊은 복사

    원본이 참조하고 있는 객체까지 복제하는 것을 깊은 복사라고 하며 깊은 복사에서는 원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본의 변경이 복사본에 영향을 미치지 않는다. 

*   예제

```java
class Circle implements Cloneable {
    Point p; // 원점 - 참조변수
    double r; // 반지름
    
    Circle(Point p, double r) {
        this.p = p;
        this.r = r;
    }
    
    public Circle clone() {
        Object obj = null;
        
        try {
            obj = super.clone();
        } catch(CloneNotSupported e) {}
        return (Circle)obj;
    }
}
```

```java
Circle c1 = new Circle(new Point(1, 1), 2.0);
Circle c2 = c1.clone();	// 얕은 복사
```

![스크린샷 2022-05-27 00.55.56](https://tva1.sinaimg.cn/large/e6c9d24egy1h2m8wv7mczj20t50an74s.jpg)

예제에서는 얕은 복사를 하고 있다. 그러면 어떻게 해야 깊은 복사가 될 수 있을까 ?

```java
class Circle implements Cloneable {
    Point p; // 원점 - 참조변수
    double r; // 반지름
    
    Circle(Point p, double r) {
        this.p = p;
        this.r = r;
    }
    
    public Circle swallowCopy() { // 얕은 복사
        Object obj = null;
        
        try {
            obj = super.clone();
        } catch(CloneNotSupported e) {}
        return (Circle)obj;
    }
    
    public Circle deepCopy() { // 깊은 복사
 		Object obj = null;
        
        try {
            obj = super.clone();
        } catch(CloneNotSupportedException e) {}
        Circle c = (Circle)obj;
        c.p = new Point(this.p.x, this.p.y);
        
        return c;
    }
    
    public String toString() {
        return "[p=" + p + ", r=" + r + "]";
    }
}

class Point {
    int x, y;
    
    Point(int x, int y) {
        this.x = x;
        this.y= y;
    }
    
    public String toString() {
        return "("+ x + ", "+ y + ")";
    }
}

class swallowDeepCopy {
    public static void main(String[] args) {
        Circle c1 = new Circle(new Point(1, 1), 2.0);
        Circle c2 = c1.swallowCopy();
        Circle c3 = c1.deepCopy();
        
        System.out.println("c1=" +c1);
        System.out.println("c2=" +c2);        
        System.out.println("c3=" +c3);
        
        c1.p.x = 9;
        c1.p.y = 9;

        System.out.println("== c1 값 변경 후 ==")
        System.out.println("c1=" +c1);
        System.out.println("c2=" +c2);        
        System.out.println("c3=" +c3);        
    }
}
```

>   *   swallowCopy() 는 단순히 Object의 clone() 을 호출한다. 원본 객체가 가지고 있는 값만 그대로 복사하는 것이다.
>   *   deepCopy() 는 새로운 Point 인스턴스를 참조하도록헀다. 원본이 참조하고 있는 객체까지 복사한 것이다.



