{% raw %}

# 컬렉션 프레임워크

## 컬렉션 프레임워크란

>   **데이터 군을 저장하는 클래스들을 표준화한 설계.**
>
>   JDK1.2 이전까지는 Vector, Hashtable, Properties와 같은 컬렉션 클래스 등 서로 다른 각자의 방식으로 다수의 데이터를 처리해야 했으나, 1.2부터는 컬렉션 프레임워크가 추가되어 표준화된 방식으로 다룰 수 있도록 체계화되었다.

### 장점

*   인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 사용법을 익히기 편하다.
*   재사용성이 높은 코드를 작성할 수 있다.

## 컬렉션 프레임웍의 핵심 인터페이스

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wa2jm8gcj20dx053746.jpg" alt="creen Shot 2022-06-04 at 17.11.43" style="zoom:50%;"/>

>   List와 Set은 공통부분이 많이 있어서 공통된 부분을 다시 뽑아서 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.



### 각 인터페이스 특징

>   컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중 하나를 구현한다. 이 세가지의 특징을 잘 이해해야 한다.

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있는 데이터의 집합, 중복 허용                         |
| Set        | 순서가 없는 데이터의 집합, 중복을 허용하지 않는다.           |
| Map        | 키(key)와 값(value)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않고, 값은 중복을 허용한다. |



### Collection 인터페이스

>   Collection 인터페이스는 List, Set의 조상 인터페이스이다.

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean add(Object e)<br />boolean addAll(Collection c)      | 지정된 객체(o)또는 Collection의 객체들을 Collection에 추가한다. |
| void clear()                                                 | Collection의 모든 객체를 삭제한다.                           |
| boolean contains(Object o)<br />boolean containsAll(Collection c) | 지정도니 객체(o)또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Object o)                                     | 동일한 Collection인지 비교한다.                              |
| int hashCode()                                               | Collection의 해시코드를 반환한다.                            |
| boolean isEmpty()                                            | Collection이 비어있는지 확인한다.                            |
| Iterator iterator()                                          | Collection의 Iterator를 얻어서 반환한다.                     |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean removeAll(Collection c)                              | 지정된 Collection에 포함된 객체들을 삭제한다.                |
| boolean retainAll(Collection c)                              | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. 이 작업으로 인해 Collection에 변화가 있으면 true, 아니면 false를 반환한다. |
| int size()                                                   | Collection의 길이를 반환한다.                                |
| Object[] toArray()                                           | Collection에 저장된 객체를 객체배열(Object[])로 반환한다.    |
| Object[] toArray(Object[] a)                                 | 지정된 배열에 Collection의 객체를 저장해서 반환한다.         |



### List 인터페이스

>   **중복을 허용**하면서 **저장 순서가 유지되는** 컬렉션을 구현하는데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wbxak1f9j211o0m4wf9.jpg" alt="Screen Shot 2022-06-04 at 18.15.52" style="zoom:25%;" />

*   메서드 및 설명

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void add(int index, Object element)<br />boolean addAll(int index ,Collection c) | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| Object get(int index)                                        | 지정된 위치에 있는 객체를 반환한다.                          |
| int indexOf(Object o)                                        | 지정된 객체의 위치(index)를 반환한다. (List의 첫 번째 요소부터 순방향으로 찾는다.) |
| int lastIndexOf(Object o)                                    | 지정된 객체의 위치(index)를 반환한다. (List의 마지막 요소부터 역방향으로 찾는다.) |
| ListIterator listIterator()<br />ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다.        |
| Object remove(int index)                                     | 위치에 해당하는 객체를 삭제하고, 삭제된 객체를 반환한다.     |
| Obejct set(int index, Object element)                        | 지정된 위치(index)에 객체(element)를 저장한다.               |
| void sort(Comparator c)                                      | 지정된 비교자(comparator)로 List를 정렬한다.                 |
| List subList(int fromIndex, int toIndex)                     | 지정된 범위에 있는 객체를 반환한다.                          |



### Set 인터페이스

>   **중복을 허용하지 않고** **저장 순서가 유지되지 않는** 컬렉션 클래스를 구현하는데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wc6hs3bhj20q80ka74r.jpg" alt="Screen Shot 2022-06-04 at 18.24.44" style="zoom:25%;"/>



### Map 인터페이스

>   키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wc8nons9j214w0kmgmn.jpg" alt="Screen Shot 2022-06-04 at 18.26.48" style="zoom:25%;" />

| 메서드                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void clear()                         | Map의 모든 객체를 삭제한다.                                  |
| boolean containsKey(Object key)      | 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인한다.   |
| boolean containsValue(Object value)  | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. |
| Set entrySet()                       | Map에 저장되어 있는 key - value 쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o)             | 동일한 Map인지 비교한다.                                     |
| Object get(Object key)               | 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.       |
| int hashCode()                       | 해시코드를 반환한다.                                         |
| boolean isEmpty()                    | Map이 비어있는지 확인한다.                                   |
| Set keySet()                         | Map에 저장된 모든 key객체를 반환한다                         |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결하여 저장한다.               |
| void putAll(Map t)                   | 지정된 Map의 모든 key-value쌍을 추가한다.                    |
| Object remove(Object key)            | 지정한 key객체와 일치하는 key - value 객체를 삭제한다.       |
| int size()                           | Map에 저장된 key-value쌍의 개수를 반환한다.                  |
| Collection values()                  | Map에 저장된 모든 value객체를 반환한다.                      |

>   *   keySet()은 중복을 허용하지 않기 때문에 Set으로 반환한다.
>   *   values()는 중복을 허용하기 때문에 Collection타입으로 반환한다.



### Map.Entry 인터페이스

>   Map인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스도 인터페이스를 정의하는 내부 인터페이스(Inner interface)를 정의하는 것이 가능하다. Map에 저잗ㅇ되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해놓았다. 이것은 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스도 함께 구현해야 한다.



| 메서드                        | 설명                                      |
| ----------------------------- | ----------------------------------------- |
| boolean equals(Object o)      | 동일한 Entry인지 비교한다.                |
| Object getKey()               | Entry의 key객체를 반환한다.               |
| Object getValue()             | Entry의 value객체를 반환한다.             |
| int hashCode()                | Entry의 해시코드를 반환한다.              |
| Object setValue(Object value) | Entry의 value객체를 지정된 객체로 바꾼다. |



## ArrayList

>   List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다.
>
>   *   ArrayList는 기존의 Vector를 개선한 것이다.
>   *   ArrayList는 Object 배열을 이용해서 데이터를 순차적으로 저장한다.
>   *   ArrayList는 배열이 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.



```java
public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable {
    ...
    transient Object[] elementData;	// Object 배열 
}
```



>   elementData라는 이름의 Object배열을 멤버 변수로 선언하고 있따는 것을 알 수 있다. 선언된 배열의 타입이 모든 객체의 최고조상인 Object이기 때문에 모든 종류의 객체를 담을 수 있다.

### 메서드 및 설명

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| ArrayList()                              | 크기가 10인 ArrayList를 생성                                 |
| ArrayList(Collection c)                  | 주어진 컬렉션이 저장된 ArrayList를 생성                      |
| ArrayList(int initialCapacity)           | 지정된 초기용량을 갖는 ArrayList를 생성                      |
| boolean add(Object o)                    | ArrayList의 마지막에 객체를 추가. 성공하면 true              |
| void add(int index, Object element)      | 지정된 위치(index)에 객체를 저장                             |
| boolean addAll(Collection c)             | 주어진 컬렉션의 모든 객체를 저장한다.                        |
| boolean addAll(int index, Collection c)  | 지정된 위치부터 주어진 컬렋녀의 모든 객체를 저장한다.        |
| void clear()                             | ArrayList를 완전히 비운다.                                   |
| Object clone()                           | ArraytList를 복제한다.                                       |
| boolean contains(Object o)               | 지정된 객체(o)가 ArrayList에 포함되어 있는지 확인            |
| void ensureCapacity(int minCapacity)     | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.         |
| Object get(int index)                    | 지정된 위치(index)에 저장된 객체를 반환한다.                 |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치를 찾아 반환한다.                   |
| boolean isEmpty()                        | ArrayList가 비어있는지 확인한다.                             |
| Iterator iterator()                      | ArrayList의 iterator객체를 반환                              |
| int lastIndexOf(Object o)                | 객체(o)가 저장된 위치를 끝부터 역방향으로 검색해서 반환      |
| ListIterator listIterator()              | ArrayList의 ListIterator를 반환                              |
| ListIterator listIterator(int index)     | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환     |
| Object remove(int index)                 | 지정된 위치에 있는 객체를 제거한다.                          |
| boolean remove(Object o)                 | 지정한 객체를 제거한다.(성공 true, 실패 false)               |
| boolean removeAll(Collection c)          | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다. |
| boolean retainAll(Collection c)          | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Object element)    | 주어진 객체를 지정된 위치에 저장한다.                        |
| int size()                               | ArrayList에 저장된 객체의 개수를 반환한다.                   |
| void sort(Comparator c)                  | 지정된 정렬기준(c)으로 ArrayList를 정렬                      |
| List subList(int fromIndex, int toIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.          |
| Object[] toArray()                       | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.        |
| Object[] toArray(Object[] a)             | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다. |
| void trimToSize()                        | 용량을 크기에 맞게 줄인다.(빈 공간을 없앤다.)                |

```java
import java.util.ArrayList;
import java.util.Collections;

public class ArrayListEx1 {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList();
        list1.add(new Integer(5));
        list1.add(new Integer(4));
        list1.add(new Integer(2));
        list1.add(new Integer(0));
        list1.add(new Integer(1));
        list1.add(new Integer(3));

        ArrayList list2 = new ArrayList(list1.subList(1, 4));
        print(list1, list2);

        Collections.sort(list1);
        Collections.sort(list2);
        print(list1, list2);

        System.out.println("list1.containsAll(list2) : " + list1.containsAll(list2));

        list2.add("B");
        list2.add("C");
        list2.add(3, "A");
        print(list1, list2);

        System.out.println("list1.retainAll(list2): " + list1.retainAll(list2));
        print(list1, list2);

        for (int i = list2.size() - 1; i >= 0; i--) {
            if (list1.contains(list2.get(i))) {
                list1.remove(i);
            }
        }
        print(list1, list2);  
    }

    static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1" + list1);
        System.out.println("list2" + list2);
        System.out.println();
    }
}
```

*   실행결과

```
list1[5, 4, 2, 0, 1, 3]
list2[4, 2, 0]

list1[0, 1, 2, 3, 4, 5]
list2[0, 2, 4]

list1.containsAll(list2) : true
list1[0, 1, 2, 3, 4, 5]
list2[0, 2, 4, A, B, C]

list1.retainAll(list2): true
list1[0, 2, 4]
list2[0, 2, 4, A, B, C]

list1[0, 2, 4]
list2[A, B, C]
```



## LinkedList

>   배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있다.
>
>   1.   크기를 변경할 수 없다.
>        *   크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야한다.
>        *   실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.
>   2.   비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
>        *   차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르다
>        *   배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터를 복사해서 이동해야 한다.

이러한 단점을 보완하기 위해 LinkedList라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.

```java
class Node {
	Node node;	// 다음 요소의 주소를 저장
    Object obj;	// 데이터를 저장
}
```

*   링크드 리스트의 각 요소들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.

*   데이터 삭제는 간단하다. 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 다음 요소를 참조하도록 변경하면 된다. 배열처럼 데이터를 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다.
*   링크드 리스트는 단방향 구조이기 때문에 다음 요소에 대한 접근은 빠르지만 이전 요소의 접근은 어렵다. 이 점을 보완한 것이 더블 링크드 리스트(Double Linked List)이다. 

```java
class Node {
    Node next;		// 다음 요소의 주소를 저장
    Node previous;	// 이전 요소의 주소를 저장
    Object obj;		// 데이터를 저장
}
```

*   더블 링크드 리스트는 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 많이 사용된다.
*   더블 링크드 리스트의 접근성을 보다 향상시킨 것은 더블 써큘러 링크드 리스트(Double Circular Linked List)이다. 더블 써큘러 링크드 리스트는 단순히 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.
*   실제로 LinkedList 클래스는 이름과는 달리 DoubleLinkedList로 구현되어 있다. 이는 낮은 접근성을 높이기 위한 것이다.

### LinkedList의 메서드와 설명

| 생성자 또는 메서드                       | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| LinkedList()                             | LinkedList객체를 생성                                        |
| LinkedList(Collection c)                 | 주어진 컬렉션을 포함하는 LinkedList 객체를 생성              |
| boolean add(Object o)                    | 지정된 객체(o)를 LinkedList의 끝에 추가한다. 성공시 true, 실패 false |
| void add(int index, Object element)      | 지정된 위치(index)에 객체(element)를 추가                    |
| boolean addAll(Collection c)             | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가한다. 성공시 true, 실패 false |
| boolean addAll(int index, Collection c)  | 지정된 위치(index)에 컬렉션에 포함된 모든 요소를 추가한다. 성공시 true, 실패 false |
| boolean contains(Object o)               | 지정된 객체가 LinkedList에 포함되었는지 알려줌               |
| boolean containsAll(Collection c)        | 지정된 Collection의 모든 요소가 LinkedList에 포함되었는지 알려줌 |
| Object get(int index)                    | 지정된 위치(index)의 객체를 반환                             |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치(앞에서부터)를 반환                 |
| boolean isEmpty()                        | LinkedList가 비어있는지 알려준다. 비어있으면 true            |
| Iterator iterator()                      | Iterator를 반환한다.                                         |
| ListIterator listIterator()              | ListIterator를 반환한다.                                     |
| ListIterator listIterator(int index)     | 지정된 위치에서부터 시작하는 ListIterator를 반환             |
| int lastIndexOf(Object o)                | 지정된 객체의 위치(index)를 반환(끝부터 역순으로 검색)       |
| Object remove(int index)                 | 지정된 위치의 객체를 제거                                    |
| boolean remove(Object o)                 | 지정된 객체를 LinkedList에서 제거. 성공시 true, 실패 false   |
| boolean removeAll(Collection c)          | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제             |
| boolean retainAll(Collection c)          | 지정된 컬렉션의 모든 요소가 포함되어 있는지 확인             |
| Object set(int index, Object element)    | 지정된 위치(index)의 객체를 주어진 객체로 바꿈               |
| int size()                               | LinkedList의 저장된 객체의 수를 반환                         |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 변환                              |
| Object[] toArray()                       | LinkedList에 저장된 객체의 수를 반환                         |
| Object[] toArray(Object[] a)             | LinkedList에 저장된 객체를 주어진 배열에 저장하여 반환       |
| Object element()                         | LinkedList의 첫 번째 요소를 반환                             |
| boolean offer(Object o)                  | 지정된 객체(o)를 LinkedList의 **끝**에 추가. 성공하면 true, 실패하면 false |
| Object peek()                            | LinkedList의 첫 번째 요소를 반환                             |
| Object poll()                            | LinkedList의 첫 번째 요소를 반환. LinkedList에서는 제거된다. |
| Object remove()                          | LinkedList의 첫 번째 요소를 제거                             |
| void addFirst(Object o)                  | LinkedList의 맨 앞에 객체를 추가                             |
| void addLast(Object o)                   | LinkedList의 맨 뒤에 객체를 추가                             |
| Iterator descendingIterator()            | 역순으로 조회하기 위한 DescendingIterator를 반환             |
| Object getFirst()                        | LinkedList의 첫번째 요소를 반환                              |
| Object getLast()                         | LinkedList의 마지막 요소를 반환                              |
| boolean offerFirst(Object o)             | LinkedList의 맨 앞에 객체를 추가. 성공하면 true              |
| boolean offerLast(Object o)              | LinkedList의 맨 뒤에 객체를 추가. 성공하면 true              |
| Object peekFirst()                       | LinkedList의 첫번째 요소를 반환                              |
| Object peekLast()                        | LinkedList의 마지막 요소를 반환                              |
| Object pollFirst()                       | LinkedList의 첫번째 요소를 반환하면서 제거                   |
| Object pollLast()                        | LinkedList의 마지막 요소를 반환하면서 제거                   |
| Object pop()                             | removeFirst()와 동일                                         |
| void push(Object o)                      | addFirst()와 동일                                            |
| Object removeFirst()                     | LinkedList의 첫번째 요소를 제거                              |
| Object removeLast()                      | LinkedList의 마지막 요소를 제거                              |
| boolean removeFirstOccurrence(Object o)  | LinkedList에서 첫번째로 일치하는 객체를 제거                 |
| boolean removeLastOccurrence(Object o)   | LinkedList에서 마지막으로 일치하는 객체를 제거               |

### 예제 - ArrayList와 LinkedList의 성능차이

```java
public class ArrayListLinkedListTest {
    public static void main(String[] args) {
        // 추가할 데이터의 개수를 고려하여 충분히 잡아야 한다.
        ArrayList al = new ArrayList(2000000);
        LinkedList ll = new LinkedList();

        System.out.println(" 순차적으로 추가하기");
        System.out.println("ArrayList : " + add1(al));
        System.out.println("LinkedList : " + add1(ll));
        System.out.println();

        System.out.println("중간에 추가하기");
        System.out.println("ArrayList : " + add2(al));
        System.out.println("LinkedList : " + add2(ll));
        System.out.println();

        System.out.println("중간에서 삭제하기");
        System.out.println("ArrayList : " + remove2(al));
        System.out.println("LinkedList : " + remove2(ll));
        System.out.println();
        
        System.out.println("순차적으로 삭제하기");
        System.out.println("ArrayList : " + remove1(al));
        System.out.println("LinkedList : " + remove1(ll));
    }
	
    public static long add1(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            list.add(i + "");
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long add2(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            list.add(500 + "X");
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long remove1(List list) {
        long start = System.currentTimeMillis();
        for (int i = list.size() - 1; i >= 0; i--) {
            list.remove(i);
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long remove2(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            list.remove(i);
        }
        long end = System.currentTimeMillis();
        return end - start;
    }
}
```

### 실행결과

```java
순차적으로 추가하기
ArrayList : 129
LinkedList : 120

중간에 추가하기
ArrayList : 0
LinkedList : 1

중간에서 삭제하기
ArrayList : 1275
LinkedList : 308

순차적으로 삭제하기
ArrayList : 12
LinkedList : 30

접근 시간 테스트
ArrayList : 0
ArrayList : 325
```

### 결론

1.   **순차적으로 추가/삭제하는 경우는 ArrayList > LinkedList**

     초기에 충분한 초기용량을 확보해서 저장공간이 부족하여 ArrayList를 새로 생성하는 일은 없도록 했다. 만약 공간이 충분하지 않으면 새로운 크기의 ArrayList를 추가해야 하므로 LinkedList가 ArrayList보다 빠를 수 있다. 순차적으로 삭제하는 경우는 마지막부터 역순으로 삭제한다는 것을 의미하며 ArrayList는 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠르다.

2.   **중간 데이터를 추가/삭제하는 경우는 LinkedList > ArrayList**

     LinkedList는 중간에 각 요소간 연결만 변경해주면 되기 때문에 처리속도가 빠르다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈공간을 채워야하기 때문에 처리속도가 늦다.

3.   배열의 경우 만일 인덱스가 n인 요소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결된다.

     인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기

     <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3153a0pr0j20mw04aq36.jpg" alt="Screen Shot 2022-06-08 at 22.07.17" style="zoom:25%;" />

     배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문에 이처럼 간단한 계산으로 요소의 주소를 얻어서 곧바로 읽어올 수 있지만 LinkedList는 불연속적으로 위치한 요소들이 서로 연결된 것이라 차례대로 따라가야만 원하는 값을 얻을 수있다. 따라서 **LinkedList는 데이터의 개수가 많아질수록 접근시간이 길어진다는 단점이 있다.**

4.   정리표

     | 컬렉션     | 읽기(접근시간) | 추가 / 삭제 | 비고                                                    |
     | ---------- | -------------- | ----------- | ------------------------------------------------------- |
     | ArrayList  | 빠르다         | 느리다      | 순차적인 추가삭제는 더 빠름<br />비효율적인 메모리 사용 |
     | LinkedList | 느리다         | 빠르다      | 데이터가 많을수록 접근성이 떨어짐                       |



## Stack과 Queue

### 구조

*   Stack - LIFO(Last In First Out) 구조이다.

    *   0,1,2의 순서로 데이터를 넣었다면 마지막 데이터가 제일 먼저 나오기 때문에 2,1,0의 순서로 빠져나온다. 
    *   `ArrayList가 적합하다` - 스택은 순차적으로 데이터를 추가하고 삭제하기 때문이다.

*   Queue - FIFO(First In FirstOut) 구조이다.

    *   0,1,2의 순서로 데이터를 넣었다면 처음 데이터가 제일 먼저 나오기 때문에 0,1,2의 순서로 빠져나온다.
    *   `LinkedList가 적합하다` - 데이터를 꺼낼때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 ArrayList는 비효율적이다. 따라서 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는게 적합하다.




### Stack - 메서드와 설명

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| boolean empty()          | Stack이 비어있는지 알려준다.                                 |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환한다. pop()과 달리 Stack에서 객체를 꺼내지는 않는다. 비었을 때 `EmptyStackException 발생` |
| Object pop()             | Stack의 맨 위에 저장된 객체를 반환하고 꺼낸다. 비었을 때 `EmptyStackException 발생` |
| Object push(Object item) | Stack에 객체(item)을 저장한다.                               |
| int search(Object o)     | Stack에서 주어진 객체를 찾아서 그 위치를 반환. 못 찾으면 -1을 반환.(배열과 달리 1부터 시작) |



### Queue - 메서드와 설명

| 메서드                  | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 저장공간이 부족하면 `IllegalStateException 발생` |
| Object remove()         | Queue에서 객체를 꺼내 반환. 비어있으면 `NoSuchElementException 발생` |
| Object element()        | 삭제없이 요소를 읽어온다. peek()과 달리  Queue가 비었을 때  `NoSuchElementException 발생` |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true. 실패하면 false를 반환    |
| Object poll()           | Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환         |
| Object peek()           | 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환    |

### Stack & Queue 예제

*   예제

```java
public class StackQueueEx {
    public static void main(String[] args) {
        Stack st = new Stack();
        Queue q = new LinkedList(); // Queue 인터페이스의 구현체인 LinkedList를 사용

        st.push("0");
        st.push("1");
        st.push("2");

        q.offer("0");
        q.offer("1");
        q.offer("2");

        System.out.println("- Stack -");
        while (!st.empty()) {
            System.out.println(st.pop());
        }

        System.out.println("- Queue -");
        while (!q.isEmpty()) {
            System.out.println(q.poll());
        }
    }
}
```

*   실행결과

```java
- Stack -
2
1
0
- Queue -
0
1
2
```

>   *   **스택**
>       *   LIFO 구조기 때문에 0,1,2의 순서로 넣었지만 2,1,0으로 출력된다.
>       *   자바에서 스택을 Stack 클래스로 구현하여 제공한다.
>   *   **큐**
>       *   FIFO 구조기 때문에 0,1,2 순서로 넣고 동일하게 0,1,2로 출력된다.
>       *   Queue는 인터페이스로 정의해 놓았을 뿐 클래스를 제공하고 있지는 않다. 다만 이를 구현한 클래스 중 하나를 선택하여 사용하면 된다.



### Stack 직접 구현하기

>   Stack은 컬렉션 프레임워크 이전부터 존재하던 것이기 때문에  ArrayList가 아닌  Vector로부터 상속받아 구현되었다.

```java
public class MyVector extends Vector {
    public Object push(Object item) {
        addElement(item);
        return item;
    }

    public Object pop() {
        Object obj = peek();
        // 만일 Stack이 비어있으면 peek() 메서드가 EmptyStackException을 발생시킨다.
        // 마지막 요소를 삭제한다. 배열의 index가 0부터 시작하므로 1을 빼준다.
        removeElement(size() - 1);
        return obj;
    }

    public Object peek() {
        int len = size();

        if (len == 0) {
            throw new EmptyStackException();
        }
        // 마지막 요소를 반환한다. 배열의 index가 0부터 시작하므로 1을 빼준다.
        return elementAt(len - 1);
    }

    public boolean empty() {
        return size() == 0;
    }

    public int search(Object o) {
        int i = lastIndexOf(o);     // 끝에서 부터 객체를 찾는다.
                                    // 반환값은 저장도니 위치(배열의 index)이다.
        if (i >= 0) {   // 객체를 찾은 경우
            return size() - i;  // Stack은 맨 위에 저장된 객체의 index를 1로 정의하기 때문에 계산을 통해서 구한다.
        }
        return -1;      // 해당 객체를 찾지 못하면 -1을 반환한다.
    }
}
```



### 스택과 큐의 활용

>   우리가 쉽게 찾아볼 수 있는 예는 다음과 같다. 책에서는 다음을 보고 몇가지를 직접 구현하는 예제를 보여주었다.

*   스택의 활용 예 - 수식게산, 수식괄호검사, 워드프로세서의  undo/redo, 웹브라우저의 뒤로/앞으로
*   큐의 활용 예 - 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)



*   스택 예제, 웹브라우저의 뒤로 / 앞으로

```java
public class StackEx1 {
    public static Stack back = new Stack();
    public static Stack forward = new Stack();

    public static void main(String[] args) {
        goURL("1. 네이트");
        goURL("2. 다음");
        goURL("3. 네이버");
        goURL("4. 야후");

        printStatus();

        goBack();
        System.out.println(" '뒤로' 버튼을 누른 후 =");
        printStatus();

        goBack();
        System.out.println(" '뒤로' 버튼을 누른 후 =");
        printStatus();

        goForward();
        System.out.println(" '앞으로' 버튼을 누른 후 =");
        printStatus();

        goURL("codechobo.com");
        System.out.println("새로운 주소로 이동후");
        printStatus();
    }

    // 각 스택을 출력하고 현재 화면을 알려준다, peek()은 객체를 꺼내지 않고 가져온다.
    public static void printStatus() {
        System.out.println("back : " + back);
        System.out.println("forward : " + forward);
        System.out.println("현재 화면은 '" + back.peek() + "' 입니다.");
        System.out.println();
    }

    // 주소 이동. back 스택에 추가하고 forward가 비어있지 않다면 내용 전체를 clear()로 비운다.
    public static void goURL(String url) {
        back.push(url);
        if (!forward.empty()) {
            forward.clear();
        }
    }
    // 앞으로 가기. forward 스택이 비어있지 않다면 back에 forward의 제일 최근 객체를 꺼내 넣는다.
    public static void goForward() {
        if (!forward.empty()) {
            back.push(forward.pop());
        }
    }

    // 뒤로 가기. back 스택이 비어있지 않다면 forward에 back의 제일 최근 객체를 꺼내 넣는다.
    public static void goBack() {
        if (!back.empty()) {
            forward.push(back.pop());
        }
    }
}
```

*   출력결과

```java
back : [1. 네이트, 2. 다음, 3. 네이버, 4. 야후]
forward : []
현재 화면은 '4. 야후' 입니다.

 '뒤로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음, 3. 네이버]
forward : [4. 야후]
현재 화면은 '3. 네이버' 입니다.

 '뒤로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음]
forward : [4. 야후, 3. 네이버]
현재 화면은 '2. 다음' 입니다.

 '앞으로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음, 3. 네이버]
forward : [4. 야후]
현재 화면은 '3. 네이버' 입니다.

새로운 주소로 이동후
back : [1. 네이트, 2. 다음, 3. 네이버, codechobo.com]
forward : []
현재 화면은 'codechobo.com' 입니다.
```



*   입력한 수식의 괄호가 올바른지 판단하는 예제

```java
public class ExpValidCheck {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage : java ExpValidCheck \"EXPRESSION\"");
            System.out.println("Example : java ExpValidCheck \"((2+3)*1)+3\"");
            System.exit(0);
        }

        Stack st = new Stack();
        String expression = args[0];
        System.out.println("expression : " + expression);

        try {
            for (int i = 0; i < expression.length(); i++) {
                char ch = expression.charAt(i);

                if (ch == '(') {
                    st.push(ch + "");
                } else if (ch == ')') {
                    st.pop();
                }
            }

            if (st.isEmpty()) {
                System.out.println("괄호가 일치합니다.");
            } else {
                System.out.println("괄호가 일치하지 않습니다.");
            }
        } catch (EmptyStackException e) {
            System.out.println("괄호가 일치하지 않습니다.");
        }
    }
}
```

*   출력 결과 (bash에서 실행했다.)

```java
Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java
Usage : java ExpValidCheck "EXPRESSION"
Example : java ExpValidCheck "((2+3)*1)+3"

Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java \(2+3\)*1
expression : (2+3)*1
괄호가 일치합니다.

    
Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java \(2+3\)\)*1
expression : (2+3))*1
괄호가 일치하지 않습니다..
```



## Iterator, ListIterator, Enumeration

>   Iterator를 기준으로 Enumeration은 컬렉션 프레임워크 이전(JDK1.0)에 사용되었던 구버전이고, ListIterator는 단방향인 Iterator의 기능을 개선시킨 것이다.



### Iterator

컬렉션에 저장된 각 요소에 접근하는 기능을 가진  Iterator인터페이스를 정의하고 Collection인터페이스에서는 이를 구현한 Iterator를 반환하는 `iterator()`를 정의하고 있다.



```java
public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
}

public interface Collection {
    ...
    public Iterator iterator();
    ...
}
```

| 메서드            | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| boolean hasNext() | 읽어 올 요소가 남아있는지 확인한다.                          |
| Object next()     | 다음 요소를 읽어 온다                                        |
| void remove()     | next()로 읽어온 요소를 삭제한다. next()를 호출한 다음에 remove()를 호출해야 한다. |



### ListIterator, Enumeration

>   *   Enumeration : Iterator의 구버전
>   *   ListIterator : Iterator에 양방향 조회기능 추가 (List를 구현한 클래스만 가능)





## Arrays

>   배열을 다루는데 유용한 메서드가 정의되어 있다. 모든 기본형 배열과 참조형 배열 별로 하나씩 정의되어 있다.

```java
static String toString(boolean[] a)
static String toString(byte[] a)
static String toString(char[] a)
static String toString(short[] a)
static String toString(int[] a)
static String toString(long a)
static String toString(float[] a)
static String toString(double[] a)
static String toString(Object[] a)    
```



### 배열의 복사

*   copyOf() - 배열 전체를 복사한다.
*   copyOfRange() - 배열의 일부를 복사한다.

```java
int[] arr = {0, 1, 2, 3, 4};
int arr2 = Arrays.copyOf(arr, arr.length); // 0,1,2,3,4
int arr3 = Arrays.copyOf(arr, 3); // 0,1,2
int arr4 = Arrays.copyOf(arr, 7); // 0,1,2,3,4,0,0;
int arr5 = Arrays.copyOfRange(arr, 2, 4);	// 2,3
int arr6 = Arrays.copyOfRange(arr, 0 ,7); 	/ 0,1,2,3,4,0,0
```



### 배열 채우기

*   fill() - 배열의 모든 요소를 지정도니 값으로 채운다.
*   setAll() - 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다. 이 메서드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 람다식을 지정해야 한다.

```java
int[] arr = new int[5];

Arrays.fill(arr, 9); // 9,9,9,9,9
Arrays.setAll(arr, () -> (int) (Math.random() * 5) + 1);
```



### 배열의 정렬과 검색

*   sort() - 배열을 정렬한다. Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬된다.
*   binarySearch() - 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환한다. 단, 반드시 배열이 정렬된 상태여야 올바른 결과를 얻는다. 중복값이 있다면 어떤 것의 위치가 반환될지는 알 수 없다.

```java
int[] arr = { 3, 2, 0, 1, 4 };
int idx = Arrays.binarySearch(arr, 2); // idx = -5 잘못된 결과

Arrays.sort(arr);	// 배열 arr을 정렬한다.
System.out.pritnln(Arrays.toString(arr));
int idx  = Arrays.binarySearch(arr, 2); // idx = 2 올바른 결과
```

 

### 배열의 비교와 출력

*   equals() - 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환한다. 다차원 배열의 경우 deepToEquals()를 사용한다. 

```java
String[][] str2D = new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};
String[][] str2D2 = new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};

System.out.println(Arrays.equals(str2D, str2D2)); 	// false
Syetem.out.println(Arrays.equals(str2D, str2D2));	// true
```

*   toString() - 다차원 배열의 경우 deepToString()을 사용하는데 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성한다.

```java
int[] arr = {0,1,2,3,4};
int[][] arr2D = {{11,12}, {21,22}};

System.out.println(Arrays.toString(arr));	// [0, 1, 2, 3, 4]
System.out.println(Arrays.deepToString(arr2D)); 	// [[11, 12], [21, 22]]
```



### 배열을 List로 변환

*   asList() - 배열을 List에 담아서 반환한다. 매개변수의 타입이 가변인수라서 배열 생성없이 저장할 요소들만 나열하는 것도 가능하다.

    ```java
    List list = Arrays.asList(new Integer[] {1,2,3,4,5});	// list = [1,2,3,4,5]
    List list = Arrays.asList(1,2,3,4,5);	// list = [1,2,3,4,5]
    list.add(6);	// UnsupportedOperationException 발생
    ```

    *    **한가지 주의할 점은 asLIst()가 반환한 List의 크기를 변경할 수 없다는 것이다. 추가 또는 삭제가 불가능하다.**크기를 변경하고자 한다면 다음과 같이 작성하면 된다.

    ```java
    List list = new ArrayList(Arrays.asList(1,2,3,4,5)); 
    ```



### parallelXXX(), spliterator(), stream()

*   parallel로 시작하는 메서드들은 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다.
*   spliterator()는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.
*   stream()은 컬렉션을 스트림으로 변환한다.

```java
public class ArraysEx {
    public static void main(String[] args) {
        int[] arr = {0, 1, 2, 3, 4};
        int[][] arr2D = {{11, 12, 13}, {21, 22, 23}};

        System.out.println("arr = " + Arrays.toString(arr));
        System.out.println("arr2D = " + Arrays.deepToString(arr2D));

        int[] arr2 = Arrays.copyOf(arr, arr.length);
        int[] arr3 = Arrays.copyOf(arr, 3);
        int[] arr4 = Arrays.copyOf(arr, 7);
        int[] arr5 = Arrays.copyOfRange(arr, 2, 4);
        int[] arr6 = Arrays.copyOfRange(arr, 0, 7);

        System.out.println("arr2 = " + Arrays.toString(arr2));
        System.out.println("arr3 = " + Arrays.toString(arr3));
        System.out.println("arr4 = " + Arrays.toString(arr4));
        System.out.println("arr5 = " + Arrays.toString(arr5));
        System.out.println("arr6 = " + Arrays.toString(arr6));

        int[] arr7 = new int[5];
        Arrays.fill(arr7, 9);
        System.out.println("arr7 = " + Arrays.toString(arr7));

        Arrays.setAll(arr7, i -> (int) (Math.random() * 6) + 1);
        System.out.println("arr7 = " + Arrays.toString(arr7));

        for (int i : arr7) {
            char[] graph = new char[i];
            Arrays.fill(graph, '*');
            System.out.println(new String(graph) + i);
        }
        String[][] str2D = new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};
        String[][] str2D2 = new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};

        System.out.println(Arrays.equals(str2D, str2D2));
        System.out.println(Arrays.deepEquals(str2D, str2D2));

        char[] chArr = {'A', 'B', 'C', 'B', 'E'};

        System.out.println("chArr = " + Arrays.toString(chArr));
        System.out.println("index Of B = " + Arrays.binarySearch(chArr, 'B'));
        System.out.println("= After sorting");
        Arrays.sort(chArr);

        System.out.println("chArr = " + Arrays.toString(chArr));
        System.out.println("index Of B = " + Arrays.binarySearch(chArr, 'B'));
    }
}
```

*   실행결과

```java
arr = [0, 1, 2, 3, 4]
arr2D = [[11, 12, 13], [21, 22, 23]]
arr2 = [0, 1, 2, 3, 4]
arr3 = [0, 1, 2]
arr4 = [0, 1, 2, 3, 4, 0, 0]
arr5 = [2, 3]
arr6 = [0, 1, 2, 3, 4, 0, 0]
arr7 = [9, 9, 9, 9, 9]
arr7 = [6, 5, 2, 4, 4]
******6
*****5
**2
****4
****4
false
true
chArr = [A, B, C, B, E]
index Of B = 1
= After sorting
chArr = [A, B, B, C, E]
index Of B = 2
```



## Comparator, Comparable

`Arrays.sort()`를 호출만 하면 컴퓨터가 알아서 배열을 정렬하는 것처럼 보이지만, 사실은 Character클래스의 Comparable의 구현에 의해 정렬되었던 것이다.

*   Comparator와 Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.

*   Comparable을 구현하고 있는 모든 클래스들은 같은 타입의 인스턴스끼리 비교할 수 있는 클래스들, 주로 Integer와 같은 wrapper클래스와 String, Date, File 같은 것들이며, 오름차순으로 정렬되도록 구현되어있다.

*   Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미한다.

>   *   Comparable - 기본 정렬 기준을 구현하는데 사용
>   *   Comparator - 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용

### Comparator, Comparable 실제 소스

```java
public interface Comparator {
    int compare(Object o1, Object o2);
    boolean equals(Object obj);
}

public interface Comparable {
    public int compareTo(Object o);
}
```

*   compare(), compareTo()는 선언형태와 이름이 약간 다를 뿐, 두 객체를 비교한다는 목적은 같다. 비교하는 값이 작으면 음수, 같으면 0, 크면 양수를 반환하게끔 구현해야 한다.

### 예제

```java
public class CompareToEx {
    public static void main(String[] args) {
        String[] strArr = {"cat", "dog", "lion", "tiger"};

        Arrays.sort(strArr);
        System.out.println("strArr = " + Arrays.toString(strArr));

        Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); // 대소문자 구분 X
        System.out.println("strArr = " + Arrays.toString(strArr));

        Arrays.sort(strArr, new Descending());
        System.out.println("strArr = " + Arrays.toString(strArr));
    }
}

class Descending implements Comparator {
    @Override
    public int compare(Object o1, Object o2) {
        if (o1 instanceof Comparable && o2 instanceof Comparable) {
            Comparable c1 = (Comparable) o1;
            Comparable c2 = (Comparable) o2;
            return c1.compareTo(c2) * -1;       // 기본 정렬 방식의 역으로 변경한다.
        }

        return -1;
    }
}
```

*   실행 결과

```java
strArr = [cat, dog, lion, tiger]
strArr = [cat, dog, lion, tiger]
strArr = [tiger, lion, dog, cat]
```



## HashSet

>   Set 인터페이스를 구현한 가장 대표적인 컬렉션이다.
>
>   1.   중복된 요소를 저장하지 않는다.(add(), addAll()을 통해 객체를 추가했을 때, 중복이면 false를 반환)
>   2.   저장순서를 유지하지 않는다(LinkedHashSet을 이용하면 저장순서가 유지된다.)

### 메서드 및 설명

| 생성자 또는 메서드                             | 설명                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| HashSet()                                      | HashSet을 생성한다.                                          |
| HashSet(Collection c)                          | 주어진 컬렉션을 포함하는 HashSet객체를 생성한다.             |
| HashSet(int intialCapacity)                    | 주어진 값을 초기용량으로 하는 HashSet을 생성한다.            |
| HashSet(int initialCapacity, float loadFactor) | 초기용량과 loadFactor를 지정하는 생성자                      |
| boolean add(Object o)                          | 새로운 객체를 저장한다. 중복시 false                         |
| boolean addAll(Collection c)                   | 주어진 컬렉션에 저장된 모든 객체들을 추가한다.(합집합)       |
| void clear()                                   | 저장된 모든 객체를 삭제한다.                                 |
| Object clone()                                 | HashSet을 복제해서 반환한다.(얕은 복사)                      |
| boolean contains(Object o)                     | 지정된 객체를 포함하고 있는지 알려준다.                      |
| boolean contains(Collection c)                 | 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다. |
| boolean isEmpty()                              | HashSet이 비어있는지 알려준다.                               |
| Iterator iterator()                            | Iterator를 반환한다.                                         |
| boolean remove(Object o)                       | 객체를 HashSet에서 삭제한다.                                 |
| boolean removeAll(Collection c)                | 주어진 컬렉션에서 저장된 모든 객체와 동일한 객체를 모두 삭제한다.(차집합) |
| boolean retainAll(Collection c)                | 주어진 컬렉션에 저장된 모든 객체와 동일한 것만 남기고 HashSet에서 모두 삭제한다.(교집합) |
| int size()                                     | 저장된 객체의 개수를 반환한다.                               |
| Object[] toArray()                             | 저장된 객체들은 객체배열의 형태로 반환한다.                  |
| Object[] toArray(Object[] )                    | 저장된 객체들을 주어진 객체배열에 담는다.                    |



*   예제1 - HashSet에는 중복값이 들어갈까?

```java
public class HashSetEx1 {
    public static void main(String[] args) {
        Object[] objArr = {"1", new Integer(1), "2", "2", "3", "3", "4", "4", "4"};
        Set set = new HashSet();

        for (int i = 0; i < objArr.length; i++) {
            set.add(objArr[i]);
        }

        // HashSet에 저장된 요소들을 출력한다.
        System.out.println(set);
    }
}
```

*   출력결과

```java
[1, 1, 2, 3, 4]
```

1이 두 번 출력되었지만 하나는 String, 나머지는 Integer로 생성했기 때문에 서로 다른 인스턴스로 간주되기 때문에 중복이 아니다.



*   예제2 - HashSet 성질을 이용한 로또번호 추출

```java
public class HashSetLotto {
    public static void main(String[] args) {
        Set set = new HashSet();

        for (int i = 0; set.size() < 6; i++) {
            int num = (int) (Math.random() * 45) + 1;
            set.add(new Integer(num));
        }

        List list = new LinkedList<>(set);
        Collections.sort(list);
        System.out.println(list);
    }
}
```

*   출력결과

```java
[1, 20, 21, 25, 33, 39]
```



*   예제3 - HashSet이 두 인스턴스를 서로 다른 것으로 인식하게 하는법

```java
public class HashSetEx4 {
    public static void main(String[] args) {
        Set set = new HashSet();

        set.add(new String("ABC"));
        set.add(new String("ABC"));
        set.add(new Person("David", 10));
        set.add(new Person("David", 10));

        System.out.println(set);
    }
}

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + ":" + age;
    }
}
```

위 예제는 Set에 add()를 통해 같은값의 두 Person 객체를 넣었지만 다른 객체로 인식하여 중복을 허락한다. 이 때 두 인스턴스가 서로 다른 값인 것을 인식시키려면 어떻게 해야할까? 책에서는 다음과 같이 해결했다.



```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Person) {
            Person tmp = (Person) obj;
            return name.equals(tmp.name) && age == tmp.age;
        }

        return false;
    }

// 	  아래의 hashCode()를 주석처리 한 것은 JDK1.8부터 Objects의 hash() 메서드를 보여주기 위함이다. 가능하면 hash() 메서드를 사용하자
//    @Override
//    public int hashCode() {
//        return (name + age).hashCode();
//    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return name + ":" + age;
    }
}
```

> HashSet의 add메서드는 새로운 요소를 추가하기 전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 목적에 맞게 오버라이딩 해야한다.
>
> 따라서 String처럼 문자열이 서로 같다면 true를 반환하게 하였고, hashCode 또한 String 클래스의 hashCode()를 이용해서 구현했다.



### 오버라이딩을 통해 작성된 hashCode()의 3가지 조건

> 1. 실행중인 어플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int값을 반환해야한다. 하지만 실행시마다 동일한 값일 필요는 없다.(단, equals()의 구현에  사용된 멤버변수의 값이 바뀌지 않았다고 가정한다.)
> 2. equals()를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출했을 때 반드시 같은 결과값이 나와야 한다.
> 3. equals()를 호출했을 때 false를 반환하는 두 객체는 hashCode()를 호출할 때 같은 int값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.(서로 다른 객체에 대해 해시코드값이 중복되는 경우가 많아질수록 HashXXX의 검색속도가 떨어진다.)



## TreeSet

> 이진 검색 트리(Binary Search Tree)라는 자료구조 형태로 데이터를 저장하는 컬렉션 클래스.
>
> 정렬, 검색, 범위검색에 높은 성능을 보인다. 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현되어 있다.
>
>   
>
> **중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.**

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3707g4xbaj20j60a8t8s.jpg" alt="Screen Shot 2022-06-13 at 23.50.58"  />

### 이진 트리 노드, 특징?

```java
class TreeNode {
    TreeNode left; 	// 왼쪽 노드
    Object element;	// 객체를 저장하기 위한 참조변수
    TreeNode right;	// 오른쪽 노드
}
```

* 이진 검색 트리는 최대 두 개의 자식노드를 가질 수 있다.
* 부모노드의 왼쪽에는 부모보다 작은 값, 오른쪽에는 부모보다 큰 값이 저장된다.

* 첫번째로 저장되는 값은 루트가 되고, 두 번째 값은 트리의 루트부터 시작해서 값의 크기를 비교하며 트리를 따라 내려간다.
* 컴퓨터는 알아서 값을 비교하지 못하기 때문에 TreeSet에 저장되는 객체가 Comprable을 구현하던가 아니면 TreeSet에게 Comparator를 제공해서 두 객체를 비교할 방법을 알려줘야 한다. 그렇지 않으면 예외가 발생한다.

* 트리는 데이터를 순차적으로 저장하는 것이 아니라 저장 위치를 찾아서 저장해야 하고 **삭제하는 경우 트리의 일부를 재구성해야하므로 LinkedList보다 데이터의 추가/삭제 시간은 더 걸린다.** 대신 검색과 정렬기능이 뛰어나다.



### TreeSet - 메서드 및 설명

| 생성자 또는 메서드                                           | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TreeSet()                                                    | 기본 생성자                                                  |
| TreeSet(Collection c)                                        | 주어진 컬렉션을 저장하는 TreeSet을 생성                      |
| TreeSet(Comparator comp)                                     | 주어진 정렬조건으로 정렬하는 TreeSet을 생성                  |
| TreeSet(SortedSet s)                                         | 주어진 SortedSet을 구현한 컬렉션을 저장하는 TreeSet을 생성   |
| boolean add(Object o)<br />boolean addAll(Collection c)      | 지정된 객체(o)또는 컬렉션(c)의 객체들을 Collection에 추가    |
| Object ceiling(Object o)                                     | 지정된 객체와 같은 객체를 반환. 없으면 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| void clear()                                                 | 저장된 모든 객체를 삭제한다.                                 |
| Object clone()                                               | TreeSet을 복제하여 반환한다.                                 |
| Comparator comparator()                                      | TreeSet의 정렬기준(Comparator)를 반환한다.                   |
| boolean contains(Object o)<br />boolean containsAll(Collection c) | 지정된 객체(o)또는 Collection의 객체들이 포함되어 있는지 확인한다. |
| NavigableSet descendingSet()                                 | TreeSet에 저장된 요소들을 역순으로 정렬해서 반환             |
| Object first()                                               | 정렬된 순서에서 첫 번째 객체를 반환한다.                     |
| Object floor(Object o)                                       | 지정된 객체와 같은 객체를 반환. 없으면 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| SortedSet headSet(Object toElement)                          | 지정된 객체보다 작은 값의 객체들을 반환한다.                 |
| SortedSet tailSet(Object fromElement)                        | 지정된 객체보다 큰 값의 객체들을 반환한다.                   |
| Navigable headSet(Object toElement, boolean inclusive)       | 지정된 객체보다 작은 값의 객체들을 반환 inclusive가 true면 같은 값의 객체도 포함 |
| Object higher(Object o)                                      | 지정된 객체보다 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| boolean isEmpty()                                            | TreeSet이 비어있는지 확인한다.                               |
| Iterator iterator()                                          | TreeSet의 Iterator를 반환한다.                               |
| Object last()                                                | 정렬된 순서에서 마지막 객체를 반환한다.                      |
| Object lower(Object o)                                       | 지정된 객체보다 작은 값은 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| Object pollFirst()                                           | TreeSet의 첫 번째 요소(제일 작은 값의 객쳬)를 반환           |
| Object pollLast()                                            | TreeSet의 마지막 요소(제일 큰 값의 객체)를 반환              |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다. 성공시 true                          |
| boolean retainAll(Collection c)                              | 주어진 컬렉션과 공통된 요소만을 남기고 삭제한다.(교집합)     |
| int size()                                                   | 저장된 객체의 개수를 반환한다.                               |
| Spliterator spliterator()                                    | TreeSet의 Spliterator 반환                                   |
| SortedSet subSet(Object fromElement, Object toElement)       | 범위 검색(fromElement부터 toElement의 바로 직전)의 결과를 반환한다. |
| NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) | 범위 검색(fromElement부터 toElement사이)의 결과를 반환한다. from/toInclusive에 true를 주면 처음/끝 값을 포함시킨다. |
| Object[] toArray()                                           | 저장된 객체를 객체배열로 반환한다.                           |
| Objct[] toArray(Object[] a)                                  | 저장된 객체를 주어진 객체배열에 저장하여 반환한다.)          |



### 예제 HashSet -> TreeSet 로또 번호 생성기

```java
public class TreeSetLotto {
    public static void main(String[] args) {
        Set set = new TreeSet();

        for (int i = 0; set.size() < 6; i++) {
            int num = (int) (Math.random() * 45) + 1;
            set.add(num);
        }

        System.out.println(set);
    }
}
```

HashSet과 다르게 정렬을 하지 않았는데, TreeSet은 이미 저장할 때 정렬이 되기 때문에 읽어올 때 따로 정렬할 필요가 없기 때문이다. 



## HashMap과 Hashtable

> HashMap은 키와 값을 묶어서 하나의 데이터(entry)로 저장하는 Map의 특징을 가지고 있으며 해싱을 사용하기 때문에 대용량의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.
>
> * HashMap은 `key - value`를 각각 Object 타입으로 저장한다.
>   * `key` - 컬렉션 내의 키 중에서 유일한 값이다.
>   * `value` 



### HashMap 실제소스 일부

```java
public class HashMap extends AbstractMap implements Map, Cloneable, Serializable {
    transient Entry[] table;
    ...
    static class Entry implments Map.Entry {
    	final Object key;
        Object value;
        ...
    }
}
```

HashMap은 Entry라는 내부 클래스를 정의하고 다시 Entry타입을 배열로 선언하고 있다. key-value은 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성적 측면에서 더 바람직하다.

* 비객체지향적 코드

```java
Object[] key;
Object[] value;
```

* 객체지향적 코드

```java
Entry[] table;
class Entry {
    Object key;
    Object value;
}
```



### HashMap의 키(Key)와 값(Value)

> * `키(key)` - 컬렉션 내의 키 중에서 유일해야 한다.
>
>   저장된 값을 찾는데 사용되는 것이기 때문에 유일해야 한다. 하나의 키로 검색했을 때 나오는 결과가 단 하나여야 함을 뜻한다. 
>
> * `값(Value)` - 키(key)와 달리 중복을 허용한다.



### HashMap의 메서드 및 설명

| 생성자 또는 메서드                                           | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| HashMap()                                                    | HashMap 객체를 생성                                          |
| HashMap(int intialCapacity)                                  | 지정된 값을 초기용량으로 하는 HashMap 객체를 생성            |
| HashMap(int intialCapacity, float loadFactor)                | 지정된 초기용량과 load factor의 HashMap 객체를 생성          |
| HashMap(Map m)                                               | Map의 모든 요소를 포함하는 HashMap 생성                      |
| void clear()                                                 | HashMap에 저장된 모든 객체를 제거                            |
| Object clone()                                               | 현재 HashMap을 복제해서 반환                                 |
| boolean containsKey(Object key)                              | HashMap에 지정된 키가 포함되어있는지 알려준다(포함되어 있으면 true) |
| boolean containsValue(Object value)                          | HashMap에 지정된 값이 포함되어있는지 알려준다.(포함되어 있으면 true) |
| Set entrySet()                                               | HashMap에 저장된 키와 값을 엔트리의 형태로 Set에 저장해서 반환 |
| Object get(Object key)                                       | 지정된 키(key)의 값을 반환, 못 찾으면 null                   |
| Object getOrDeafault(Object key, Object defaultValue)        | 지정된 키의 값을 반환한다. 키를 못 찾으면 기본값으로 지정된 객체를 반환한다. |
| boolean isEmpty()                                            | HashMap이 비어있는지 알려준다.                               |
| Set keySet()                                                 | HashMap에 저장된 모든 키가 저장된 Set을 반환                 |
| Object put(Object key, Object value)                         | 지정된 키, 값을 저장                                         |
| void putAll(Map m)                                           | Map에 저장된 모든 값을 HashMap에 저장                        |
| Object remove(Object key)                                    | HashMap에서 지정된 키로 저장된 값(객체)를 제거               |
| Object replace(Object key, Object value)                     | 지정된 키의 값을 지정된 객체로 대체                          |
| Object replace(Object key, Object oldValue, Object newValue) | 지정된 키와 객체가 모두 일치하는 경우에만 새로운 객체로 대체 |
| int size()                                                   | HashMap에 저장된 요소의 개수를 반환                          |
| Collection values()                                          | HashMap에 저장된 모든 값을 컬레션의 형태로 변환              |



### HashMap 예제 - 1

```java
import java.util.*;

class HashMapEx1 {
	public static void main(String[] args) {
		HashMap map = new HashMap();
		map.put("myId", "1234");
		map.put("asdf", "1111");
		map.put("asdf", "1234");	// 키 중복 X, 값은 덮어써진다.
		
		Scanner s = new Scanner(System.in);
		
		while(true) {
            System.out.println("id와 password를 입력해주세요");
            System.out.print("id : ");
            String id = s.nextLine().trim();
            
			System.out.print("passWord : ");
            String password = s.nextLine().trim();
            System.out.println();
            
            if(!(map.get(id)).equals(password)) {
                System.out.println("비밀번호가 일치하지 않습니다. 다시 입력해주세요");
            } else {
             	System.out.println("id와 비밀번호가 일치합니다");   
            }
        }
	}
}
```

* 실행결과

```java
id와 password를 입력해주세요
id : asdf
passWord : 1111

비밀번호가 일치하지 않습니다. 다시 입력해주세요
id와 password를 입력해주세요
id : asdf
passWord : 1234

id와 비밀번호가 일치합니다
```



### HashMap 예제 - 2

```java
public class HashMapEx2 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("김자바", new Integer(100));
        map.put("이자바", new Integer(100));
        map.put("박자바", new Integer(80));
        map.put("강자바", new Integer(90));

        Set set = map.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();
            System.out.println("이름 : " + e.getKey() + ", 점수 : " + e.getValue());
        }

        set = map.keySet();
        System.out.println("참가자 명단 : " + set);

        Collection values = map.values();
        it = values.iterator();

        int total = 0;
        while (it.hasNext()) {
            Integer i = (Integer) it.next();
            total += i.intValue();
        }

        System.out.println("총점 : " + total);
        System.out.println("평균 : " + (float)total / set.size());
        System.out.println("최고 점수 : " + Collections.max(values));
        System.out.println("최저 점수 : " + Collections.min(values));
    }
}
```

* 실행결과

```java
이름 : 김자바, 점수 : 100
이름 : 박자바, 점수 : 80
이름 : 강자바, 점수 : 90
이름 : 이자바, 점수 : 100
참가자 명단 : [김자바, 박자바, 강자바, 이자바]
총점 : 370
평균 : 92.5
최고 점수 : 100
최저 점수 : 80
```



### HashMap 예제 - 3

```java
public class HashMapEx3 {
    // TODO 전화번호부로 사용할 HashMap
    static HashMap phoneBook = new HashMap();

    public static void main(String[] args) {
        addPhoneNo("친구", "이자바", "010-1111-1111");
        addPhoneNo("친구", "김자바", "010-2222-2222");
        addPhoneNo("친구", "김자바", "010-3333-3333");
        addPhoneNo("친구", "박자바", "010-4444-4444");
        addPhoneNo("회사", "이대리", "010-5555-5555");
        addPhoneNo("회사", "박과장", "010-6666-6666");
        addPhoneNo("회사", "김차장", "010-7777-7777");
        addPhoneNo("세탁", "010-8888-8888");

        printList();
    }
    // 그룹에 전화번호를 추가하는 메서드
    static void addPhoneNo(String groupName, String name, String tel) {
        addGroup(groupName);
        // 그룹명의 값(value)는 HashMap이다. 해당 그룹명에 전화번호를 추가한다.
        HashMap group = (HashMap) phoneBook.get(groupName);
        group.put(tel, name);
    }

    // 매개변수를 두개 주었을 때, 그룹명은 기타임. (메서드 오버라이딩)
    static void addPhoneNo(String name, String tel) {
        addPhoneNo("기타", name, tel);
    }
    // 그룹을 추가하는 메서드
    static void addGroup(String groupName) {
        if (!phoneBook.containsKey(groupName)) {
            phoneBook.put(groupName, new HashMap());
        }
    }

    static void printList() {
        Set set = phoneBook.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();

            Set subSet = ((HashMap) e.getValue()).entrySet();
            Iterator subIt = subSet.iterator();

            System.out.println(" * " + e.getKey() + "[" + subSet.size() + "]");

            while (subIt.hasNext()) {
                Map.Entry subE = (Map.Entry) subIt.next();
                String telNo = (String) subE.getKey();
                String name = String.valueOf(subE.getValue());
                System.out.println(name + " " + telNo);
            }
            System.out.println();
        }
    }
}
```

* 실행결과

```java
 * 기타[1]
세탁 010-8888-8888

 * 친구[4]
이자바 010-1111-1111
박자바 010-4444-4444
김자바 010-3333-3333
김자바 010-2222-2222

 * 회사[3]
김차장 010-7777-7777
박과장 010-6666-6666
이대리 010-5555-5555


Process finished with exit code 0
```



### HashMap 예제 - 4

```java
package hashMap;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class HashMapEx4 {
    public static void main(String[] args) {
        String[] data = {"A", "K", "A", "K", "D", "K", "A", "K", "K", "K", "Z", "D"};
        HashMap map = new HashMap();

        for (int i = 0; i < data.length; i++) {
            if (map.containsKey(data[i])) {
                Integer value = (Integer) map.get(data[i]);
                map.put(data[i], value.intValue() + 1);
            } else {
                map.put(data[i], new Integer(1));
            }
        }
        Iterator it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value) + " " + value);

        }
    }

    public static String printBar(char c, int value) {
        char[] bar = new char[value];

        for (int i = 0; i < bar.length; i++) {
            bar[i] = c;
        }

        return new String(bar);
    }
}
```

* 실행결과

```
A : ### 3
D : ## 2
Z : # 1
K : ###### 6
```



### 해싱과 해시함수

> * 해싱 - 해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법
> * 해시함수 - 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.



* **해싱에서 사용하는 자료구조는 `배열`과 `링크드리스트`의 조합으로 되어 있다.**
  * 저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 된다

* **HashMap에 저장된 데이터를 찾는 과정**
  1. 검색하고자 하는 값의 키로 해시함수를 호출한다.
  2. 해시함수의 계산결과(해시코드)로 해당 값이 저장되어 있는 링크드 리스트를 찾는다.
  3. 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다.
* **링크드리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 된다.**
  * 반면에 배열은 배열의 크기가 커져도 원하는 요소가 몇 번째에 있는지만 알면 공식(`배열의 인덱스가 n인 요소의 주소 = 배열의 시작주소 + type의 size * n`)에 의해서 빠르게 원하는 값을 찾을 수 있다.
* HashMap에서 가장 빠른 검색시간을 얻으려면 해시함수의 알고리즘이 중요하다.
  * 하나의 링크드리스트에 최소한의 데이터만 저장되려면 HashMap의 크기를 적절히 지정해주어야 하고, 서로 다른 키에 대해 중복된 해시코드의 반환을 최소화해야 한다. 따라서 해싱을 구현하는 과정에서 중요한 것은 해시함수의 알고리즘이다. 
  * 실제 해싱을 구현한 Collection 클래스에서는 Object의 hashCode()를 해시함수로 사용한다.
  * 만약 새로운 클래스를 정의할 때 equals()를 재정의해야 한다면 hashCode()또한 재정의하여 equals()의 결과가 true인 두 객체의 해시코드의 결과값이 항상 같도록 해주어야 한다. 그렇지 않으면 HashMap과 같이 해싱을 구현한 클래스에서는 equals()는 같지만 hashCode()가 다르기 때문에 두 객체가 서로 다른 것으로 인식하고 따로 저장할 것이기 때문이다.



## TreeMap

> 이진 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다.
>
> 검색과 정렬에 적합한 컬렉션 클래스이다. 하지만 검색에 관한 대부분의 경우에서는 HashMap이 더 우수한 성능을 보인다. **범위 검색, 정렬**이 필요한 경우에는 TreeMap을 사용하자



### 메서드 및 설명

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TreeMap()                                                    | TreeMap 객체를  생성                                         |
| TreeMap(Comparator c)                                        | 지정된 Comparator를 기준으로 정렬하는 TreeMap을 생성         |
| TreeMap(Map m)                                               | 주어진 Map을 모두 포함하는 TreeMap을 생성                    |
| TreeMap(SortedMap m)                                         | 주어진 SortedMap을 모두 포함하는 TreeMap을 생성              |
| Map.Entry ceilingEntry(Object key)                           | 지정된 key와 일치하거나 큰 것중 제일 작은 것의 키와 값의 쌍을 반환. 없으면 null |
| Object ceilingKey(Object key)                                | 지정된 key와 일치하거나 큰 것중 제ㅣㅇㄹ 작은 것의 키를 반환. 없으면 null |
| void clear()                                                 | 모든 객체를 삭제                                             |
| Object clone()                                               | 현재 TreeMap을 복제해서 반환                                 |
| Comparator comparator()                                      | TreeMap의 정렬기준이 되는 comparator 반환. 지정되지 않았다면 null 반환 |
| boolean containsKey(Object key)                              | TreeMap에 지정된 key를 포함하는지 알려줌                     |
| boolean containsValue(Object value)                          | TreeMap에 지정된 value를 포함하는지 알려줌                   |
| NavigableSet descendingKeySet()                              | TreeMap에 저장된 키를 역순으로 정렬해서 NavigableSet에 반환  |
| Set entrySet()                                               | TreeMap에 저장된 키와 값을 엔트리의 형태로 Set에 담아 반환   |
| Map.Entry firstEntry()                                       | TreeMap에 저장된 첫 번째 키와 값의 쌍을 반환                 |
| Object firstKey()                                            | TreeMap에 저장된 첫 번째 키를 반환                           |
| Map.Entry floorEntry(Object key)                             | 지정된 key와 일치하거나 작은 것 중에서 제일 큰 키의 쌍을 반환. 없으면 null |
| Object floorKey(Object key)                                  | 지정된 key와 일치하거나 작은 것 중에서 제일 큰 키를 반환     |
| Object get(Object key)                                       | 지정된 키의 값을 반환                                        |
| SortedMap headMap(Object toKey)                              | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환 |
| NavigableMap headMap(Objct toKey, boolean inclusive)         | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환 inclusive의 값이 true면 toKey도 포함 |
| Map.Entry higherEntry(Object key)                            | 지정된 key보다 큰 키 중에서 제일 작은 키의 쌍(Map.Entry)를 반환. 없으면 null을 반환 |
| Object higherKey(Object key)                                 | 지정된 key보다 큰 키 중에서 제일 작은 키의 쌍(Map.Entry)를 반환. 없으면 null을 반환 |
| boolean isEmpty()                                            | TreeMap이 비어있는지 알려줌                                  |
| Set keySet()                                                 | TreeMap에 저장된 모든 키가 저장된 Set을 반환                 |
| Map.Entry lastEntry()                                        | TreeMap에 저장된 마지막 키(가장 큰 키)의 쌍을 반환           |
| Object lastKey()                                             | TreeMap에 저장된 마지막 키(가장 큰 키)를 반환                |
| Map.Entry lowerEntry(Object key)                             | 지정된 key보다 작은 키 중에서 제일 큰 키의 쌍을 반환. 없으면 null을 반환 |
| Object lowerKey(Object key)                                  | 지정된 key보다 작은 키 중에서 제일 큰 키의 쌍을 반환         |
| NavigableSet navigableKeySet()                               | TreeMap의 모든 키가 담긴 navigableSet을 반환                 |
| Map.Entry pollFirstEntry()                                   | TreeMap에서 제일 작은 키를 제거하면서 반환                   |
| Map.Entry pollLastEntry()                                    | TreeMap에서 제일 큰 키를 제거하면서 반환                     |
| Object put(Object key, Object value)                         | 지정된 키와 값을 TreeMap에 저장                              |
| void putAll(Map map)                                         | 지정된 Map을 TreeMap에 전부 저장                             |
| Object remove(Object key)                                    | 키로 저장된 값을 Map에서 제거                                |
| Object replace(Object k, Object v)                           | 키(k)의 값을 지정된 값(v)으로 변경                           |
| boolean replace(Object key, Object oldValue, Object newValue) | 기존의 키, 값이 일치하면 새로운 값(newValue)로 값을 변경     |
| int size()                                                   | TreeMap에 저장된 요소의 개수를 반환                          |
| NavigableMap subMap(Object fromKey, boolean fromInclusive, Object toKey, boolean toInclusive) | 지정된 두개의 키 사이에 있는 모든 요소들이 담긴 NavigableMap을 반환. fromInclusive가 true면 범위에 fromKey포함, toInclusive가 true면 범위에 toKey포함 |
| SortedMap subMap(Object fromKey, Object toKey)               | 지정된 두 개의 키 사이에 있는 모든 요소들이 담긴 SortedMap을 반환 |
| SortedMap tailMap(Object fromKey)                            | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴 SortedMap을 반환(toKey 미포함) |
| NavigableMap tailMap(Object fromKey, boolean inclusive)      | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴 NavigableMap을 반환. |
| Collection values()                                          | TreeMap에 저장된 모든 값을 컬렉션의 형태로 반환              |



### 예제 - HashMap 예제를 TreeMap으로 재구현

```java
public class TreeMapEx1 {
    public static void main(String[] args) {
        String[] data = {"A", "K", "A", "K", "D", "K", "A", "K", "K", "K", "Z", "D"};
        TreeMap map = new TreeMap();

        for (int i = 0; i < data.length; i++) {
            if (map.containsKey(data[i])) {
                Integer value = (Integer) map.get(data[i]);
                map.put(data[i], value.intValue() + 1);
            } else {
                map.put(data[i], new Integer(1));
            }
        }
        Iterator it = map.entrySet().iterator();
        System.out.println("= 기본 정렬 =");

        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value) + " " + value);

        }
        System.out.println();

        Set set = map.entrySet();
        List list = new ArrayList(set);

        Collections.sort(list, new ValueComparator());

        it = list.iterator();
        
        System.out.println("=값이 큰 순서로 정렬=");
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value) + " " + value);

        }
    }

    public static String printBar(char c, int value) {
        char[] bar = new char[value];

        for (int i = 0; i < bar.length; i++) {
            bar[i] = c;
        }

        return new String(bar);
    }

    static class ValueComparator implements Comparator {
        @Override
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Map.Entry && o2 instanceof Map.Entry) {
                Map.Entry e1 = (Map.Entry) o1;
                Map.Entry e2 = (Map.Entry) o2;

                int v1 = ((Integer) e1.getValue()).intValue();
                int v2 = ((Integer) e2.getValue()).intValue();

                return v2 - v1;
            }
            return -1;
        }
    }
}
```

* 실행결과

```java
= 기본 정렬 =
A : ### 3
D : ## 2
K : ###### 6
Z : # 1

=값이 큰 순서로 정렬=
K : ###### 6
A : ### 3
D : ## 2
Z : # 1
```



## Properties

> HashMap의 구버전인 Hashtable을 상속받아 구현한 것이다.
>
> Hashtable은 키와 값을 <Object, Object>의 형태로 저장하는데 Properties는 <String, String>으로 받는 보다 단순한 컬렉션 클래스이다.
>
> * 주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용된다. 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.



### 메서드 및 설명

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Properties()                                                 | Properties 객체를 생성한다.                                  |
| Properties(Properties defaults)                              | 지정된 Properties에 저장된 목록을 가진 Properteis 객체를 생성한다. |
| String getProperty(String key)                               | 지정된 key의 값을 반환한다.                                  |
| String getProperty(String key, String defaultValue)          | 지정된 key의 값을 반환한다. 키를 못 찾으면 기본값(defaultValue)를 반환한다. |
| void list(PrintStream out)                                   | 지정된 PrintStream에 저장된 목록을 출력한다.                 |
| void list(PrintWriter out)                                   | 지정된 PrintWriter에 저장된 목록을 출력한다.                 |
| void load(InputStream inStream)                              | 지정된 InputStream로 부터 목록을 읽어서 저장한다.            |
| void load(Reader reader)                                     | 지정된 Reader로 부터 목록을 읽어서 저장한다.                 |
| void loadFromXML(InputStream in)                             | 지정된 InputStream으로부터 XML문서를 읽어서 XML문서에 저장된 목록을 읽어다 담는다. |
| Enumertaion propertyNames()                                  | 목록의 모든 키가 담긴 Enumeration을 반환한다.                |
| void save(OutputStream out, String header)                   | deprecated -> store()사용 권장                               |
| Object setProperty(String key, String value)                 | 지정된 키와 값을 저장한다. 이미 존재하는 키면 새로운 값으로 바뀐다. |
| void store(OutputStream out, Stirng comments)                | 저장된 목록을 지정된 OutputStream에 출력(저장)한다. comments는 목록에 대한 주석으로 저장된다. |
| void store(Writer writer, String comments)                   | 저장된 목록을 지정된 Writer에 출력한다. comments는 목록에 대한 주석으로 저장된다. |
| void storeToXML(OutputStream os, String comment)             | 저장된 목록을 지정된 출력스트림에 XML문서로 출력한다. comment는 목록에 대한 설명으로 저장된다. |
| void storeToXML(OutputStream os, String comment, String encoding) | 저장된 목록을 지정된 출력스트림에 해당 인코딩의 XML 문서로 출력한다. comment는 목록에 대한 설명으로 저장된다. |
| Set stringPropertyNames()                                    | Properties에 저장되어 있는 모든 키를 Set에 담아서 반환한다.  |



### Properties 예제

```java
class PropertiesEx1 {
	public static void main(String[] args) {
    	Properties prop = new Properties();
        
        prop.setProperty("timeout", "30");
        prop.setProperty("language", "kr");
        prop.setProperty("size", "10");
        prop.setProperty("capacity", "10");
        
        Enumeration e = prop.propertyNames();
        
        while(e.hasMoreElements()) {
        	String element = (String)e.nextElement();
            System.out.println(element + " = " + prop.getProperty(element));
        }
        
        System.out.println();
        prop.setProperty("size", "20");
        System.out.println("size = " + prop.getProperty("size"));
        System.out.println("capacity = " + prop.getProperty("capacity", "20"));
        System.out.println("loadFactor = " + prop.getProperty("loadFactor", "0.75"));
                           
                           
        System.out.println(prop);
       	prop.list(System.out);
    }
}
```

* 실행결과

```java
capacity = 10
size = 10
timeout = 30
language = kr

size = 20
capacity = 10
loadFactor = 0.75
{capacity=10, size=20, timeout=30, language=kr}
-- listing properties --
capacity=10
size=20
timeout=30
language=kr
```

* Properties는 Hashtable을 상속받아 구현한 것이라 Map의 특성상 저장순서를 유지하지 않기 때문에 예제의 결과에 출력된 순서가 저장순서와는 무관하다.
* Properties는 컬렉션 프레임워크 이전의 구버전이다. Iterator가 아닌 Enumeration을 사용한다.
* list 메서드는 Properties에 저장된 모든 데이터를 화면 또는 파일에 편리하게 출력할 수 있다.



## Collections

> Arrays가 배열과 관련된 메서드를 제공하는 것처럼 Collections는 컬렉션과 관련된 메서드를 제공한다. fill(), copy(), sort(), binarySearch() 등의 메서드는 두 클래스에 모두 포함되어 있으며 같은 역할을 한다.



### 컬렉션의 동기화

```java
static Collection synchronizedCollection (Collection c)
static List synchronizedList (List list)    
static Set synchronizedSet (Set s)
static Map synchronizedMap (Map m)    
static SortedSet synchronizedSortedSet (SortedSet s)
static SortedMap synchronizedSortedMap (SortedMap m)
    
// Example
List syncList = Collections.synchronizedList(new ArrayList(...));
```

멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성을 유지하기 위해서는 공유되는 객체에 동기화가 필요하다.

Vector, Hashtable과 같은 구버전의 클래스들은 자체적으로 동기화 처리가 되어있는데 멀티쓰레드 프로그래밍이 아닌 경우 오히려 성능을 저하시킨다. 그래서 새로 추가된 ArrayList, HashMap가 같은 컬렉션은 동기화를 자체 처리하지 않고 Collections의 동기화 메서드를 이용해서 동기화 처리가 가능하도록 변경하였다. 



### 변경불가 컬렉션 만들기

```java
static Set unmodifiableSet(Set s);
static Map unmodifiableMap(Map m);
static NavigableSet unmodifiableNavigableSet(NavigableSet s);
static SortedSet unmodifiableSortedSet(SortedSet s);
static NavigableMap unmodifiableNavigableMap(NavigableMap m);
static SortedMap unmodifiableSortedMap(SortedMap m);
```

컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게 즉 읽기 전용으로 만들어야 할 때가 있다. 이를 방지하려면 위의 메서드를 사용한다.



### 싱글톤 컬렉션 만들기

```java
static List singletonList(Object o);
static Set singleton(Object o);
static Map singletonMap(Object key, Object value);
```

단 하나의 객체만을 저장하는 컬렉션을 만들고 싶을 경우 위의 메서드를 사용한다. 매개변수로 저장할 요소를 지정하면 해당 요소를 저장하는 컬렉션을 반환한다. 반환된 컬렉션은 **변경할 수 없다**



### 한 종류의 객체만 저장하는 컬렉션 만들기

```java
static Collection checkedCollection(Collection c, Class type);
static List checkedList(List list, Class type);
static Set checkedSet(Set set, Class type);
static Map checkedMap(Map map, Class keyType, Class valueType);
static Queue checkedQueue(Queue queue, Class type);
static NavigableSet checkedNavigableSet(NavigableSet set, Class type);
static SortedSet checkedSortedSet(SortedSet set, Class type);
static NavigableMap checkedNavigableMap(NavigableMap map, Class keyType, Class valueType);
static SortedMap checkedSortedMap(SortedMap map, Class keyType, Class valueType);
```

컬렉션에 모든 종류의 객체를 저장할 수 있다는 것은 장점이기도 하고, 단점이기도 하다. 대부분 한 종류의 객체를 저장하며 컬렉션에 지정된 종류의 객체만 저장할 수 있도록 제한하고 싶을 때 위 메서드를 사용한다. 저장할 요소의 타입을 제한하는 것은 Generics(JDK 1.5때 도입)로 해결하면 되지만 위 메서드들을 제공하는 이유는 호환성(JDK1.5 이전) 때문이다.

`type`을 지정한 뒤, 지정된 타입과 맞지 않는 타입을 저장하려고 하면 어떻게 될까? `ClassCastException`이 발생한다. 아래의 예제를 통해 확인할 수 있다.

```java
public class CollectionsEx1 {
    public static void main(String[] args) {
        // String만 저장 가능한 List
        List list = Collections.checkedList(new ArrayList<>(), String.class);
		
        // 정수타입인 1을 저장
        list.add(1);

        System.out.println(list);
    }
}
```

* 실행결과

```java
Exception in thread "main" java.lang.ClassCastException: Attempt to insert class java.lang.Integer element into collection with element type class java.lang.String
	at java.util.Collections$CheckedCollection.typeCheck(Collections.java:3039)
	at java.util.Collections$CheckedCollection.add(Collections.java:3082)
	at collections.CollectionsEx1.main(CollectionsEx1.java:12)
```



## 총 정리

| 컬렉션                           | 특징                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| ArrayList                        | 배열 기반. 데이터의 추가와 삭제에 불리. 순차적인 추가 삭제는 가장 빠름. 임의의 요소에 대한 접근성이 뛰어나다. |
| LinkedList                       | 연결 기반. 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않다. |
| HashMap                          | 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어남. 검색에 최고 성능을 보인다. |
| TreeMap                          | 연결 기반. 정렬과 검색(특히 범위 검색)에 적합. 검색 성능은 HashMap보다 떨어진다. |
| Stack                            | Vector를 상속받아 구현. LIFO 구조                            |
| Queue                            | LinkedList가 Queue 인터페이스를 구현. FIFO 구조              |
| Properties                       | Hashtable을 상속 받아 구현                                   |
| HashSet                          | HashMap을 이용해서 구현                                      |
| TreeSet                          | TreeMap을 이용해서 구현                                      |
| LinkedHashMap<br />LinkedHashSet | HashMap, HashSet에 저장순서유지기능을 추가                   |

{% endraw %}
