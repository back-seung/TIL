# 날짜와 시간 & 형식화 클래스

> `형식화 클래스`는 형식화에 사용될 패턴을 정의하는데 패턴에 맞춰서 형식화할 수 있고, 역으로 형식화된 데이터에서 원래의 데이터를 얻어낼 수도 있다.
>
> `java.text`패키지에는 형식화 클래스가 포함되어 있으며 숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있는 방법을 객체지향적으로 설계하여 표준화하였다.  
>
> `java.time` 패키지는 Date와 Calendar가 가지고 있던 단점들을 해소하기 위해 1.8 버전부터 추가되었다. 뒤에서 알아보자



## DecimalFormat

> 숫자를 형식화 하는데 사용하는 것이 DecimalFormat이고, 이를 이용하여 숫자 데이터를 정수, 부동소수점, 금액 등의 다양한 형식으로 표현할 수 있으며, 반대로 일정한 형식의 텍스트 데이터를 숫자로 쉽게 변환하는 것도 가능하다.

| 기호   | 의미                     | 패턴                                                         | 결과(1234567.89)                                             |
| ------ | ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0      | 10진수(값이 없을 때는 0) | 0<br />0.0<br />0000000000.0000                              | 1234568<br />1234567.9<br />0001234567.8900                  |
| #      | 10진수                   | #<br />#.#<br />##########.####                              | 1234568<br />1234567.9<br />0001234567.8900                  |
| .      | 소수점                   | #.#                                                          | 1234567.9                                                    |
| -      | 음수 부호                | #.#-<br />-#.#                                               | 1234567.9-<br />-1234567.9                                   |
| ,      | 단위 구분자              | #,###.##<br />#,####.##                                      | 1,234,567.89<br />123,4567.89                                |
| E      | 지수기호                 | #E0<br />0E0<br />##E0<br />00E0<br />####E0<br />0000E0<br />#.#E0<br />0.0E0<br />0.000000000E0<br />00.00000000E0<br />000.0000000E0<br />#.#########E0<br />##.########E0<br />###.#######E0 | 1.E7<br />1E6<br />1.2E6<br />12E5<br />123.5E4<br />1235E3<br />1.2E6<br />1.2E6<br />1.234567890E6<br />12.34567890E5<br />123.4567890E4<br />1.23456789E6<br />12.3456789E6<br />123.456789E6 |
| ;      | 패턴 구분자              | #,###,##+;#,###,##-                                          | 1,234,567.89+ (양수일 때)<br />1,234,567.89- (음수일 때)     |
| %      | 퍼센트                   | #.#%                                                         | 123456789%                                                   |
| \u2030 | 퍼밀(퍼센트 x 10)        | #.#\u2030                                                    | 1234567890%                                                  |
| \u00A4 | 통화                     | \u00A4 #,###                                                 | ₩ 1,234,568                                                  |
| '      | escape 문자              | '#'#,###<br />``#,###                                        | #1,234,568<br />`1,234,658                                   |

### DecimalFormat 패턴 적용법

```java
double number = 1234567.89;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number);
```



## SimpleDateFormat

>  Date와 Calendar만으로 날짜 데이터를 원하는 형태로 다양하게 출력하는 것은 불편하고 복잡하다. 따라서 SimpleDateFormat을 사용하여 불편을 해결한다.

| 기호 | 의미                             | 보기              |
| ---- | -------------------------------- | ----------------- |
| G    | 연대(BC, AD)                     | AD                |
| y    | 연도                             | 2006              |
| M    | 월(1 ~ 12 또는 1월 ~ 12월)       | 10 또는 10월, OCT |
| w    | 년의 몇 번째 주( 1 ~ 53 )        | 50                |
| W    | 월의 몇 번째 주( 1 ~ 5 )         | 4                 |
| D    | 년의 몇 번째 일( 1 ~ 366 )       | 199               |
| d    | 월의 몇 번째 일( 1 ~ 31 )        | 15                |
| F    | 월의 몇 번째 요일 ( 1 ~ 5 )      | 1                 |
| E    | 요일                             | 월                |
| a    | 오전/ 오후 (AM, PM)              | PM                |
| H    | 시간 (0 ~ 23)                    | 20                |
| k    | 시간(1 ~ 24)                     | 13                |
| K    | 시간(0 ~ 11)                     | 10                |
| h    | 시간 (1 ~ 12)                    | 11                |
| m    | 분(0 ~ 59)                       | 35                |
| s    | 초(0 ~ 59)                       | 55                |
| S    | 천분의 일초(0 ~ 999)             | 253               |
| z    | Time zone(General time zone)     | GMT + 9:00        |
| Z    | Time zone(RFC 822 time zone)     | +0900             |
| `    | escape문자(특수문자 표현에 사용) | 없음              |

### SimpleDateFormat 패턴 적용법

```java
Date today = new Date();
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
String result = df.format(today);
```

* `format(Date d)` 는 Date 타입만 사용될 수 있기 때문에 `Calendar`를 사용하기 위해서는 변환해야 한다.

```java
Calendar cal = Calendar.getInstance();
cal.set(2022, 5, 2); // 2022 6 2

Date day = cal.getTime(); // Calendar를 Date로 변환

SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

System.out.println(sdf.format(day));	// 2022-06-02
```

* `parse(String source)`를 사용하여 날짜 데이터의 출력형식을 바꿀 수도 있다. 문자열 `source`를 날짜 Date 인스턴스로 변환해주기 때문에 매우 유용하게 쓰일 수 있다.  parse 메서드는 SimpleDateFormat의 조상 클래스인 DateFormat에 정의되어 있다. 

```java
String pattern = "yyyy/MM/dd";
DateFormat df = new SimpleDateFormat(pattern);
Scanner s = new Scanner(System.in);

Date inDate = null;

System.out.println("날짜를" + pattern + "의 형식에 맞춰 입력해주세요");

while(s.hasNext()) {
    try {
        inDate = df.parse(s.nextLine());
        break;
    } catch(Exception e) {
        System.out.println("날짜를" + pattern + "의 형식에 맞춰 다시 입력해주세요");
    }
}
```

> 지정된 형식에 맞춰 입력하게끔 적절한 예외 처리를 해주어야 한다.



## ChoiceFormat

> 특정 범위에 속하는 값을 문자열로 변환해준다. 연속적 || 불연속적인 범위의 값들을 처리하는 데 있어서 if문이나 switch문은 적절하지 못한 경우가 많다. 이럴 때 ChoiceFormat을 사용하여 코드를 간단하고 직관적으로 만들 수 있다.



```java
double[] limits = {60, 70, 80, 90};		// 낮은 값부터 큰값의 순서로 적어야 한다.
// limits, gradse의 순서와 개수를 맞추어야 한다.
String[] grades = {"D", "C", "B", "A"};

int[] scores = { 100, 95, 88, 70, 52, 60, 70};

ChoiceFormat form = new ChoiceFormat(limits, grades);

for(int i = 0; i < scores.length; i++) {
    System.out.println(scores[i] + " : " + form.format(scores[i]));
}
```

```
>> 출력결과

100 : A
95 : A
88 : B
70 : C
52 : D
60 : D
70 : C
```

> * `limits` : 범위의 경계값을 저장(반드시 모두 오름차순으로 정렬되어 있어야 하며, double형이어야 한다.
> * `grades` : 범위에 따라 치환될 문자열, 범위의 개수와 일치해야 한다.



## MessageFormat

> 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다. 데이터가 들어갈 자리를 마련해 놓은 양식을 미리 작성하고 프로그램을 이용해서 다수의 데이터를 같은 양식으로 출력할 때 사용하면 좋다.

```java
String msg = "Name : {0} \nTel : {1} \nAge : {2} \nBirthday : {3}";

Object[] arguments = {"이자바", "02-123-1234", "27", "07-09"};

String result = MessageFormat.format(msg, arguments);

System.out.println(result);
```



## java.time

> `java.time`패키지는 다음과 같은 4개 하위 패키지를 가지고 있다. 아래 패키지들에 속한 클래스들은 String 클래스처럼 불변의 특징을 가진다.

| 패키지             | 설명                                                    |
| ------------------ | ------------------------------------------------------- |
| java.time          | 날짜와 시간을 다루는데 필요한 핵심 클래스들 제공        |
| java.time.chrono   | 표준(ISO)이 아닌 달력 시스템을 위한 클래스들을 제공     |
| java.time.format   | 날짜와 시간을 파싱하고, 형식화하기 위한 클래스들을 제공 |
| java.time.temporal | 날짜와 시간의 필드와 단위를 위한 클래스들을 제공        |
| java.time.zone     | 시간대와 관련된 클래스들을 제공                         |



### java.time 패키지의 핵심 클래스

> 날짜와 시간을 하나로 표현하는 Calendar 클래스와 달리 java.time은 이 둘을 분리했다.
>
> * `LocalDate`  - 날짜
> * `LocalTime` - 시간
>
> * `LocalDateTime` - 날짜 + 시간
> * `ZoneDateTime` - 날짜 + 시간 + 시간대



### Period와 Duration

`날짜 - 날짜 = Period`

`시간 - 시간 = Duration`



### 객체 생성하기 - now(), of()

`java.time` 패키지에 속한 클래스의 객체를 생성하는 가장 기본적인 방법은 `now(), of()`를 사용하는 것이다.

```java
LocalDate date = LocalDate.now();
LocalTime time = LocalTime.now();
LocalDateTime dateTime = LocalDateTime.now();
ZonedDateTime dateTimeInKr = ZoneDateTime.now();
```

`of()`는 단순히 해당 필드의 값을 순서대로 지정해주기만 하면 된다. 각 클래스마다 다양하게 정의되어 있다.

```java
LocalDate date = LocalDate.of(2015, 11, 23);
LocalTime time = LocalTime.of(23, 59, 59);
LocalDateTime dateTime = LocalDateTime.of(date, time);
ZonedDateTime dateTimeInKr = ZoneDateTime.of(dateTime, ZoneId.of("Asia/Seoul"));
```



### Temporal과 TemporalAmount

> * `Temporal, TemporalAccessor, TemporalAdjuster 인터페이스` - LocalDate, LocalTime, ZonedDateTime 등 날짜와 시간을 표현하기 위한 클래스가 구현을 위해 사용
> * `TemporalAmount 인터페이스`  - Duration, Period 클래스가 구현을 위해 사용  



### TemporalUnit과 TemporalField

```java
LocalTime now = LocalTime.now();
int minute = now.getMinute();
// int minute = now.get(ChronoField.MINUTE_OF_HOUR);

LocalDate today = LocalDate.now(); // 오늘
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); // 오늘에 1일을 더한다
// LocalDate tomorrow = today.plusDays(1);
```

날짜와 시간의 단위를 정의해놓은 것이 TemporalUnit 인터페이스이고, 이 인터페이스를 구현한 것이 열거형 ChronoUnit이다. 그리고 TemporalField는 년, 월, 일 등 날짜와 시간의 필드를 정의해 놓은 것으로 열거형 ChronoField가 이 인터페이스를 구현하였다.

날짜와 시간에서 특정 필드의 값만을 얻을 때는 get()이나, get으로 시작하는 이름의 메서드를 이용한다. 그리고 아래와 같이 특정 날짜와 시간에서 지정된 단위의 값을 더하거나 뺄 때는 plus()또는 minus()에 값과 함께 열거형 ChronoUnit을 사용한다



## LocalDate & LocalTime

> ``java.time``의 가장 기본이 되는 클래스. 객체를 생성하는 방법은 now(), of() 메서드를 사용한다. 두 메서드 모두 static이다.

```java
LocalDate today = LocalDate.now();	// 오늘의 날짜
LocalTiem now = LocalTime.now();	// 현재 시간 

LocalDate birthDate = LocalDate.of(1998, 05, 21);
LocalTime birthTime = LocalTime.of(23, 59, 59);
```



### 특정 필드의 값 가져오기

* 메서드

| 클래스    | 메서드                   | 설명(1991-12-31 23:59:59)                  |
| --------- | ------------------------ | ------------------------------------------ |
| LocalDate | int getYear()            | 년도(1991)                                 |
|           | int getMonthValue()      | 월(12)                                     |
|           | int getDayOfMonth()      | 월(DECEMBER) getMonth().getValue() = 12    |
|           | int getDayOfYear()       | 같은 해의 1월 1일부터 몇번째 일            |
|           | DayOfWeek getDayOfWeek() | 요일(FRIDAY) getDayOfWeek().getValue() = 5 |
|           | int lengthOfMonth()      | 같은 달의 총 일수(31)                      |
|           | int lengthOfYear()       | 365, 윤년일 때(366)                        |
|           | boolean isLeapYear()     | 윤년여부 확인                              |
| LocalTime | int getHour()            | 시(23)                                     |
|           | int getMinute()          | 분(59)                                     |
|           | int getSecond()          | 초(59)                                     |
|           | int getNano()            | 나노초(0)                                  |



* 매개변수로 사용할 수 있는 필드의 목록

| TemporalField(ChronoField)   | 설명                                           |
| ---------------------------- | ---------------------------------------------- |
| ERA                          | 시대                                           |
| YEAR_OF_ERA, YEAR            | 년                                             |
| MONTH_OF_YEAR                | 월                                             |
| DAY_OF_WEEK                  | 요일(1:월, 2:화, ... 7:일)                     |
| DAY_OF_MONTH                 | 일                                             |
| AMPM_OF_DAY                  | 오전/오후                                      |
| HOUR_OF_DAY                  | 시간(0~23)                                     |
| CLOCK_HOUR_OF_DAY            | 시간(1~24)                                     |
| HOUR_OF_AMPM                 | 시간(0~11)                                     |
| CLOCK_HOUR_OF_AMPM           | 시간(1~12)                                     |
| MINUTE_OF_HOUR               | 분                                             |
| SECOND_OF_MINUTE             | 초                                             |
| MILLI_OF_SECOND              | 천분의 일초                                    |
| MICRO_OF_SECOND *            | 백만분의 일초                                  |
| NANO_OF_SECOND *             | 10억분의 일초                                  |
| DAY_OF_YEAR                  | 그 해의 몇번째날                               |
| EPOCH_DAY *                  | EPOCH(1970.1.1)부터 몇 번째 날                 |
| MINUTE_OF_DAY                | 그 날의 몇번째 분(시간을 분으로 환산)          |
| SECOND_OF_DAY                | 그 날의 몇 번째 초(시간을 초로 환산)           |
| MILLI_OF_DAY                 | 그 날의 몇 번째 밀리초                         |
| MICRO_OF_DAY *               | 그 날의 몇 번째 마이크로초                     |
| NANO_OF_DAY *                | 그 날의 몇 번째 나노초                         |
| ALIGNED_WEEK_OF_MONTH        | 그 달의 N번째 주(1~7일 1주, 8~14일 2주)        |
| ALIGNED_WEEK_OF_YEAR         | 그 해의 N번째 주 (1월 1~7일 1주, 8~14일 2주)   |
| ALIGNED_DAY_OF_WEEK_IN_MONTH | 요일(그 달의 1일을 월요일로 간주하여 계산)     |
| ALIGNED_DAY_OF_WEEK_IN_YEAR  | 요일(그 해의 1월 1일을 월요일로 간주하여 계산) |
| INSTANT_SECONDS              | 년월일을 초단위로 환산                         |
| OFFSET_SECONDS               | UTC와의 시차. ZoneOffset에만 사용가능          |
| POLEPTIC_MONTH               | 년월일을 월단위로 환산                         |

> 사용할 수 있는 필드는 클래스별로 다르다.



### 필드의 값 변경-  with(), plus(), minus()

> 날짜와 시간에서 특정 필드 값을 변경하려면 다음과 같이 with로 시작하는 메서드를 사용하면 된다.
>
> 또한 LocalTime에는 truncatedTo()가 있는데 지정된 것보다 작은 단위의 필드를 0으로 만든다. 반면에 LocalDate에는 truncatedTo()가 없는데, 년, 월, 일은 0이 될 수 없기 때문이다. 

```java
LocalDate withYear(int year)
LocalDate withMonth(int month)
LocalDate withDayOfMonth(int dayOfMonth)
LocalDate withDayOfYear(int dayOfYear)

LocalTime withHour(int hour)
LocalTime withMinute(int minute)
LocalTime withSecond(int second)
LocalTiem withNano(int nanoOfSecond)
```

with()를 사용하면 원하는 필드를 직접 지정할 수 있다. 위의 메서드들은 모두 with()로 작성된 것이라는 것을 짐작 가능하다.

```java
LocalDate with(TemporalField field, long newValue)
```

필드를 변경하는 메서드들은 항상 새로운 객체를 반환하기 때문에 대입 연산자를 같이 사용해야 한다.

```java
date = date.withYear(2000);	 // 년도를 2000년으로 변경
time = time.withHour(12);	// 시간을 12시로 변경
```

외에도 특정 필드에 값을 더하거나 빼는 plus(), minus()가 있다.



### 날짜와 시간의 비교 - isBefore(), isAfter(), isEqual()

> LocalDate, LocalTime은 compareTo가 적절히 오버라이딩 되어 있어서 비교가 수월하다.
>
> 하지만 보다 편리하게 비교할 수 있는 메서드를 추가 제공한다.

```java
boolean isAfter (ChronoLocalDate other)
boolean isBefore(ChronoLocalDate other)
boolean isEqual(ChronoLocalDate other)
```

equals()가 있지만 isEqual() 메서드를 사용하는 이유는 연표가 다른 두 날짜를 비교하기 위해서이다. equals()와 달리 isEqual()은 오직 날짜만 비교한다.



## Instant

>   에포크 타임부터 경과된 시간을 나노초 단위로 표현한다. 단일 진법으로만 다루기 때문에 계산하기 쉽다(기계).

```java
Instant now = Instant.now();
Instant now2 = Instant.ofEpochSecond(now.getEpochSecond());
Instant now3 = Instant.ofEpochSecond(now.getEpochSecond(), now.getNano());
```

Instant를 생성할 때는 위와 같이 now(), ofEpochSecond()를 사용한다. 필드에 저장된 값을 가져올 때는 다음과 같이 한다.

```java
long epochSec = now.getEpochSecond();
int nano = now.getNano();
```

*   시간을 초 단위와 나노초 단위로 나누어 저장한다. Oracle DB의 TimeStamp처럼 밀리초 단위의 EPOCH TIME을 필요로하는 경우를 위해 toEpochMilli()가 정의되어 잇다.



### Instant와 Date간의 변환

Instant는 기존의 `java.util.Date`를 대체하기 위한 것이며, JDK1.8부터 Date에 Instant로 변환할 수 있는 새로운 메서드가 추가되었다.

```java
static Date from(Instant instant); 	// instant -> Date
Instant		toInstant()				// Date -> Instant   
```



## LocalDateTime과 ZonedDateTime

>   *   LocalDate + LocalTime -> LocalDateTime
>   *   LocalDateTime + 시간대 -> ZonedDateTime



### LocalDate와  LocalTime으로 LocalDateTime 만들기

```java
LocalDate date = LocalDate.of(2015, 12, 31);
LocalTime time = LocalTime.of(12, 34, 56);

LocalDateTime dt = LocalDateTime.of(date, time);
LocalDateTime dt2 = date.atTime(time);
LocalDateTime dt3 = time.atDate(date);
LocalDateTime dt4 = date.atTime(12, 45, 56);
LocalDateTime dt5 = time.atDate(LocalDate.of(2015, 12, 31));
LocalDateTime dt6 = date.adStartOfDay();
```



### LocalDateTime의 변환

반대로 LocalDateTime을 LocalDate, LocalTime으로 변환할 수 있다.

```java
LocalDateTime dt = LocalDateTime.of(2015, 12, 31, 12, 34, 56);
LocalDate date = dt.toLocalDate();
LocalTime time = dt.toLocalTime();
```



### LocalDateTime을 ZonedDateTime 만들기

>   시간대를 추가하면 ZonedDateTime이 된다. 기존에는 TiemZone 클래스로 시간대를 다뤘지만 새로운 시간 패키지에서는 ZoneId라는 클래스를 사용한다.

*   ZoneId : 일광 절약시간(DST, Daylight Saving Time)을 자동적으로 처리해주므로 더 편리함,

*   LocalDate에 atTime()을 쓰면 LocalDateTime을 얻는 것처럼 **LocalDateTime에 atZone()으로 시간대 정보를 추가하면 ZonedDateTime을 얻을 수 있다.**

```java
ZoneId zid = ZoneId.of("Asia/Seoul");
ZonedDateTime zdt = dateTime.atZone(zid);
System.out.println(zdt); 	// 2015-11-27T17:47:50.451+09:00[Asia/Seoul]
```

LocalDate에 atStartOfDay()라는 메서드가 있는데 이 메서드에 매개변수로 ZoneId를 지정해도 ZonedDateTime을 얻을 수 있다.

```java
ZonedDateTime zdt = LocalDate.now().atStartOfDay(zid);
System.out.println(zdt); 	// 2015-11-27T17:47:50.451+00:00[Asia/Seoul]
```



### ZoneOffset

>   UTC로부터 얼마만큼 떨어져 있는지를 ZoneOffSet으로 표현한다. 서울은 +9이다.



### OffsetDateTime

>   ZonedDateTime은 ZoneId로 구역을 표현하는데, ZoneId가 아닌 ZoneOffset을 사용하는 것이 OffsetDateTime이다.
>
>   *   ZoneId - 일광절약시간처럼 시간대와 관련된 규칙들을 포함하고 있다.
>   *   ZoneOffset - 시간대를 시간의 차이로만 구분한다. 

*   같은 지역내에 데이터를 주고받을때, 전송시간을 표현하기에 LocalDateTime이면 충분하겠지만, 서로 다른 시간대에 존재하는 컴퓨터간의 통신에는 OffsetDateTime이 필요하다. 



### ZonedDateTime의 변환

ZonedDateTime도 LocalDateTime처럼 날짜와 시간에 관련된 다른 클래스로 변환하는 메서드들을 가지고 있다. 

```java
LocalDate toLocalDate()
LocalTime toLocalTime()
LocalDateTime toLocalDateTime()
OffsetDateTime toOffsetDateTime()
long toEpochSecond()
Instant toInstant()
```



## TemporalAdjusters

>   자주 쓰일만한 날짜 계산들을 대신 해주는 메서드를 정의해놓은 것이  TemporalAdjusters 클래스이다.

```java
LocalDate today = LocalDate.now();
LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
```

*   다음주 월요일의 날짜를 계산할 때  TemporalAdjusters에 정의된 next()를 사용하였다. 



### TemporalAdjusters 메서드 및 설명

| method                                             | description             |
| -------------------------------------------------- | ----------------------- |
| firstDayOfNextYear()                               | 다음해의 첫 날          |
| firstDayOfNextMonth()                              | 다음해의 첫 달          |
| firstDayOfYear()                                   | 올 해의 첫 날           |
| firstDayOfMonth()                                  | 올 해의 첫 달           |
| lastDayOfYear()                                    | 올 해의 마지막 날       |
| lastDayOfMonth()                                   | 이번 달의 마지막 날     |
| firstInMonth(DayOfWeek dayOfWeek)                  | 이번 달의 첫 번째 ?요일 |
| lastInMonth(DayOfWeek dayOfWeek)                   | 이번 달의 마지막  ?요일 |
| previous(DayOfWeek dayOfWeek)                      | 지난 ?요일(당일 미포함) |
| previousOrSame(DayOfWeek dayOfWeek)                | 지난 ?요일(당일 포함)   |
| next(DayOfWeek dayOfWeek)                          | 다음 ?요일(당일 미포함) |
| nextOrSame(DayOfWeek dayOfWeek)                    | 다음 ?요일(당일 포함)   |
| dayOfWeekInMonth(int ordinal, DayOfWeek dayOfWeek) | 이번 달의  n번째 ?요일  |



