# 컬렉션 프레임워크

## 컬렉션 프레임워크란

>   **데이터 군을 저장하는 클래스들을 표준화한 설계.**
>
>   JDK1.2 이전까지는 Vector, Hashtable, Properties와 같은 컬렉션 클래스 등 서로 다른 각자의 방식으로 다수의 데이터를 처리해야 했으나, 1.2부터는 컬렉션 프레임워크가 추가되어 표준화된 방식으로 다룰 수 있도록 체계화되었다.

### 장점

*   인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 사용법을 익히기 편하다.
*   재사용성이 높은 코드를 작성할 수 있다.

## 컬렉션 프레임웍의 핵심 인터페이스

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wa2jm8gcj20dx053746.jpg" alt="creen Shot 2022-06-04 at 17.11.43" style="zoom:50%;"/>

>   List와 Set은 공통부분이 많이 있어서 공통된 부분을 다시 뽑아서 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했다.



### 각 인터페이스 특징

>   컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중 하나를 구현한다. 이 세가지의 특징을 잘 이해해야 한다.

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있는 데이터의 집합, 중복 허용                         |
| Set        | 순서가 없는 데이터의 집합, 중복을 허용하지 않는다.           |
| Map        | 키(key)와 값(value)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않고, 값은 중복을 허용한다. |



### Collection 인터페이스

>   Collection 인터페이스는 List, Set의 조상 인터페이스이다.

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean add(Object e)<br />boolean addAll(Collection c)      | 지정된 객체(o)또는 Collection의 객체들을 Collection에 추가한다. |
| void clear()                                                 | Collection의 모든 객체를 삭제한다.                           |
| boolean contains(Object o)<br />boolean containsAll(Collection c) | 지정도니 객체(o)또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Object o)                                     | 동일한 Collection인지 비교한다.                              |
| int hashCode()                                               | Collection의 해시코드를 반환한다.                            |
| boolean isEmpty()                                            | Collection이 비어있는지 확인한다.                            |
| Iterator iterator()                                          | Collection의 Iterator를 얻어서 반환한다.                     |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean removeAll(Collection c)                              | 지정된 Collection에 포함된 객체들을 삭제한다.                |
| boolean retainAll(Collection c)                              | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. 이 작업으로 인해 Collection에 변화가 있으면 true, 아니면 false를 반환한다. |
| int size()                                                   | Collection의 길이를 반환한다.                                |
| Object[] toArray()                                           | Collection에 저장된 객체를 객체배열(Object[])로 반환한다.    |
| Object[] toArray(Object[] a)                                 | 지정된 배열에 Collection의 객체를 저장해서 반환한다.         |



### List 인터페이스

>   **중복을 허용**하면서 **저장 순서가 유지되는** 컬렉션을 구현하는데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wbxak1f9j211o0m4wf9.jpg" alt="Screen Shot 2022-06-04 at 18.15.52" style="zoom:25%;" />

*   메서드 및 설명

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void add(int index, Object element)<br />boolean addAll(int index ,Collection c) | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| Object get(int index)                                        | 지정된 위치에 있는 객체를 반환한다.                          |
| int indexOf(Object o)                                        | 지정된 객체의 위치(index)를 반환한다. (List의 첫 번째 요소부터 순방향으로 찾는다.) |
| int lastIndexOf(Object o)                                    | 지정된 객체의 위치(index)를 반환한다. (List의 마지막 요소부터 역방향으로 찾는다.) |
| ListIterator listIterator()<br />ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다.        |
| Object remove(int index)                                     | 위치에 해당하는 객체를 삭제하고, 삭제된 객체를 반환한다.     |
| Obejct set(int index, Object element)                        | 지정된 위치(index)에 객체(element)를 저장한다.               |
| void sort(Comparator c)                                      | 지정된 비교자(comparator)로 List를 정렬한다.                 |
| List subList(int fromIndex, int toIndex)                     | 지정된 범위에 있는 객체를 반환한다.                          |



### Set 인터페이스

>   **중복을 허용하지 않고** **저장 순서가 유지되지 않는** 컬렉션 클래스를 구현하는데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wc6hs3bhj20q80ka74r.jpg" alt="Screen Shot 2022-06-04 at 18.24.44" style="zoom:25%;"/>



### Map 인터페이스

>   키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2wc8nons9j214w0kmgmn.jpg" alt="Screen Shot 2022-06-04 at 18.26.48" style="zoom:25%;" />

| 메서드                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void clear()                         | Map의 모든 객체를 삭제한다.                                  |
| boolean containsKey(Object key)      | 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인한다.   |
| boolean containsValue(Object value)  | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. |
| Set entrySet()                       | Map에 저장되어 있는 key - value 쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o)             | 동일한 Map인지 비교한다.                                     |
| Object get(Object key)               | 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.       |
| int hashCode()                       | 해시코드를 반환한다.                                         |
| boolean isEmpty()                    | Map이 비어있는지 확인한다.                                   |
| Set keySet()                         | Map에 저장된 모든 key객체를 반환한다                         |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결하여 저장한다.               |
| void putAll(Map t)                   | 지정된 Map의 모든 key-value쌍을 추가한다.                    |
| Object remove(Object key)            | 지정한 key객체와 일치하는 key - value 객체를 삭제한다.       |
| int size()                           | Map에 저장된 key-value쌍의 개수를 반환한다.                  |
| Collection values()                  | Map에 저장된 모든 value객체를 반환한다.                      |

>   *   keySet()은 중복을 허용하지 않기 때문에 Set으로 반환한다.
>   *   values()는 중복을 허용하기 때문에 Collection타입으로 반환한다.



### Map.Entry 인터페이스

>   Map인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스도 인터페이스를 정의하는 내부 인터페이스(Inner interface)를 정의하는 것이 가능하다. Map에 저잗ㅇ되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해놓았다. 이것은 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스도 함께 구현해야 한다.



| 메서드                        | 설명                                      |
| ----------------------------- | ----------------------------------------- |
| boolean equals(Object o)      | 동일한 Entry인지 비교한다.                |
| Object getKey()               | Entry의 key객체를 반환한다.               |
| Object getValue()             | Entry의 value객체를 반환한다.             |
| int hashCode()                | Entry의 해시코드를 반환한다.              |
| Object setValue(Object value) | Entry의 value객체를 지정된 객체로 바꾼다. |



## ArrayList

>   List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다.
>
>   *   ArrayList는 기존의 Vector를 개선한 것이다.
>   *   ArrayList는 Object 배열을 이용해서 데이터를 순차적으로 저장한다.
>   *   ArrayList는 배열이 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.



```java
public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable {
    ...
    transient Object[] elementData;	// Object 배열 
}
```



>   elementData라는 이름의 Object배열을 멤버 변수로 선언하고 있따는 것을 알 수 있다. 선언된 배열의 타입이 모든 객체의 최고조상인 Object이기 때문에 모든 종류의 객체를 담을 수 있다.

### 메서드 및 설명

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| ArrayList()                              | 크기가 10인 ArrayList를 생성                                 |
| ArrayList(Collection c)                  | 주어진 컬렉션이 저장된 ArrayList를 생성                      |
| ArrayList(int initialCapacity)           | 지정된 초기용량을 갖는 ArrayList를 생성                      |
| boolean add(Object o)                    | ArrayList의 마지막에 객체를 추가. 성공하면 true              |
| void add(int index, Object element)      | 지정된 위치(index)에 객체를 저장                             |
| boolean addAll(Collection c)             | 주어진 컬렉션의 모든 객체를 저장한다.                        |
| boolean addAll(int index, Collection c)  | 지정된 위치부터 주어진 컬렋녀의 모든 객체를 저장한다.        |
| void clear()                             | ArrayList를 완전히 비운다.                                   |
| Object clone()                           | ArraytList를 복제한다.                                       |
| boolean contains(Object o)               | 지정된 객체(o)가 ArrayList에 포함되어 있는지 확인            |
| void ensureCapacity(int minCapacity)     | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.         |
| Object get(int index)                    | 지정된 위치(index)에 저장된 객체를 반환한다.                 |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치를 찾아 반환한다.                   |
| boolean isEmpty()                        | ArrayList가 비어있는지 확인한다.                             |
| Iterator iterator()                      | ArrayList의 iterator객체를 반환                              |
| int lastIndexOf(Object o)                | 객체(o)가 저장된 위치를 끝부터 역방향으로 검색해서 반환      |
| ListIterator listIterator()              | ArrayList의 ListIterator를 반환                              |
| ListIterator listIterator(int index)     | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환     |
| Object remove(int index)                 | 지정된 위치에 있는 객체를 제거한다.                          |
| boolean remove(Object o)                 | 지정한 객체를 제거한다.(성공 true, 실패 false)               |
| boolean removeAll(Collection c)          | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다. |
| boolean retainAll(Collection c)          | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Object element)    | 주어진 객체를 지정된 위치에 저장한다.                        |
| int size()                               | ArrayList에 저장된 객체의 개수를 반환한다.                   |
| void sort(Comparator c)                  | 지정된 정렬기준(c)으로 ArrayList를 정렬                      |
| List subList(int fromIndex, int toIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.          |
| Object[] toArray()                       | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.        |
| Object[] toArray(Object[] a)             | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다. |
| void trimToSize()                        | 용량을 크기에 맞게 줄인다.(빈 공간을 없앤다.)                |

```java
import java.util.ArrayList;
import java.util.Collections;

public class ArrayListEx1 {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList();
        list1.add(new Integer(5));
        list1.add(new Integer(4));
        list1.add(new Integer(2));
        list1.add(new Integer(0));
        list1.add(new Integer(1));
        list1.add(new Integer(3));

        ArrayList list2 = new ArrayList(list1.subList(1, 4));
        print(list1, list2);

        Collections.sort(list1);
        Collections.sort(list2);
        print(list1, list2);

        System.out.println("list1.containsAll(list2) : " + list1.containsAll(list2));

        list2.add("B");
        list2.add("C");
        list2.add(3, "A");
        print(list1, list2);

        System.out.println("list1.retainAll(list2): " + list1.retainAll(list2));
        print(list1, list2);

        for (int i = list2.size() - 1; i >= 0; i--) {
            if (list1.contains(list2.get(i))) {
                list1.remove(i);
            }
        }
        print(list1, list2);  
    }

    static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1" + list1);
        System.out.println("list2" + list2);
        System.out.println();
    }
}
```

*   실행결과

```
list1[5, 4, 2, 0, 1, 3]
list2[4, 2, 0]

list1[0, 1, 2, 3, 4, 5]
list2[0, 2, 4]

list1.containsAll(list2) : true
list1[0, 1, 2, 3, 4, 5]
list2[0, 2, 4, A, B, C]

list1.retainAll(list2): true
list1[0, 2, 4]
list2[0, 2, 4, A, B, C]

list1[0, 2, 4]
list2[A, B, C]
```



## LinkedList

>   배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있다.
>
>   1.   크기를 변경할 수 없다.
>        *   크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야한다.
>        *   실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.
>   2.   비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.
>        *   차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르다
>        *   배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터를 복사해서 이동해야 한다.

이러한 단점을 보완하기 위해 LinkedList라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.

```java
class Node {
	Node node;	// 다음 요소의 주소를 저장
    Object obj;	// 데이터를 저장
}
```

*   링크드 리스트의 각 요소들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.

*   데이터 삭제는 간단하다. 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 다음 요소를 참조하도록 변경하면 된다. 배열처럼 데이터를 복사하는 과정이 없기 때문에 처리속도가 매우 빠르다.
*   링크드 리스트는 단방향 구조이기 때문에 다음 요소에 대한 접근은 빠르지만 이전 요소의 접근은 어렵다. 이 점을 보완한 것이 더블 링크드 리스트(Double Linked List)이다. 

```java
class Node {
    Node next;		// 다음 요소의 주소를 저장
    Node previous;	// 이전 요소의 주소를 저장
    Object obj;		// 데이터를 저장
}
```

*   더블 링크드 리스트는 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 많이 사용된다.
*   더블 링크드 리스트의 접근성을 보다 향상시킨 것은 더블 써큘러 링크드 리스트(Double Circular Linked List)이다. 더블 써큘러 링크드 리스트는 단순히 첫 번째 요소와 마지막 요소를 서로 연결시킨 것이다.
*   실제로 LinkedList 클래스는 이름과는 달리 DoubleLinkedList로 구현되어 있다. 이는 낮은 접근성을 높이기 위한 것이다.

### LinkedList의 메서드와 설명

| 생성자 또는 메서드                       | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| LinkedList()                             | LinkedList객체를 생성                                        |
| LinkedList(Collection c)                 | 주어진 컬렉션을 포함하는 LinkedList 객체를 생성              |
| boolean add(Object o)                    | 지정된 객체(o)를 LinkedList의 끝에 추가한다. 성공시 true, 실패 false |
| void add(int index, Object element)      | 지정된 위치(index)에 객체(element)를 추가                    |
| boolean addAll(Collection c)             | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가한다. 성공시 true, 실패 false |
| boolean addAll(int index, Collection c)  | 지정된 위치(index)에 컬렉션에 포함된 모든 요소를 추가한다. 성공시 true, 실패 false |
| boolean contains(Object o)               | 지정된 객체가 LinkedList에 포함되었는지 알려줌               |
| boolean containsAll(Collection c)        | 지정된 Collection의 모든 요소가 LinkedList에 포함되었는지 알려줌 |
| Object get(int index)                    | 지정된 위치(index)의 객체를 반환                             |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치(앞에서부터)를 반환                 |
| boolean isEmpty()                        | LinkedList가 비어있는지 알려준다. 비어있으면 true            |
| Iterator iterator()                      | Iterator를 반환한다.                                         |
| ListIterator listIterator()              | ListIterator를 반환한다.                                     |
| ListIterator listIterator(int index)     | 지정된 위치에서부터 시작하는 ListIterator를 반환             |
| int lastIndexOf(Object o)                | 지정된 객체의 위치(index)를 반환(끝부터 역순으로 검색)       |
| Object remove(int index)                 | 지정된 위치의 객체를 제거                                    |
| boolean remove(Object o)                 | 지정된 객체를 LinkedList에서 제거. 성공시 true, 실패 false   |
| boolean removeAll(Collection c)          | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제             |
| boolean retainAll(Collection c)          | 지정된 컬렉션의 모든 요소가 포함되어 있는지 확인             |
| Object set(int index, Object element)    | 지정된 위치(index)의 객체를 주어진 객체로 바꿈               |
| int size()                               | LinkedList의 저장된 객체의 수를 반환                         |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 변환                              |
| Object[] toArray()                       | LinkedList에 저장된 객체의 수를 반환                         |
| Object[] toArray(Object[] a)             | LinkedList에 저장된 객체를 주어진 배열에 저장하여 반환       |
| Object element()                         | LinkedList의 첫 번째 요소를 반환                             |
| boolean offer(Object o)                  | 지정된 객체(o)를 LinkedList의 **끝**에 추가. 성공하면 true, 실패하면 false |
| Object peek()                            | LinkedList의 첫 번째 요소를 반환                             |
| Object poll()                            | LinkedList의 첫 번째 요소를 반환. LinkedList에서는 제거된다. |
| Object remove()                          | LinkedList의 첫 번째 요소를 제거                             |
| void addFirst(Object o)                  | LinkedList의 맨 앞에 객체를 추가                             |
| void addLast(Object o)                   | LinkedList의 맨 뒤에 객체를 추가                             |
| Iterator descendingIterator()            | 역순으로 조회하기 위한 DescendingIterator를 반환             |
| Object getFirst()                        | LinkedList의 첫번째 요소를 반환                              |
| Object getLast()                         | LinkedList의 마지막 요소를 반환                              |
| boolean offerFirst(Object o)             | LinkedList의 맨 앞에 객체를 추가. 성공하면 true              |
| boolean offerLast(Object o)              | LinkedList의 맨 뒤에 객체를 추가. 성공하면 true              |
| Object peekFirst()                       | LinkedList의 첫번째 요소를 반환                              |
| Object peekLast()                        | LinkedList의 마지막 요소를 반환                              |
| Object pollFirst()                       | LinkedList의 첫번째 요소를 반환하면서 제거                   |
| Object pollLast()                        | LinkedList의 마지막 요소를 반환하면서 제거                   |
| Object pop()                             | removeFirst()와 동일                                         |
| void push(Object o)                      | addFirst()와 동일                                            |
| Object removeFirst()                     | LinkedList의 첫번째 요소를 제거                              |
| Object removeLast()                      | LinkedList의 마지막 요소를 제거                              |
| boolean removeFirstOccurrence(Object o)  | LinkedList에서 첫번째로 일치하는 객체를 제거                 |
| boolean removeLastOccurrence(Object o)   | LinkedList에서 마지막으로 일치하는 객체를 제거               |

### 예제 - ArrayList와 LinkedList의 성능차이

```java
public class ArrayListLinkedListTest {
    public static void main(String[] args) {
        // 추가할 데이터의 개수를 고려하여 충분히 잡아야 한다.
        ArrayList al = new ArrayList(2000000);
        LinkedList ll = new LinkedList();

        System.out.println(" 순차적으로 추가하기");
        System.out.println("ArrayList : " + add1(al));
        System.out.println("LinkedList : " + add1(ll));
        System.out.println();

        System.out.println("중간에 추가하기");
        System.out.println("ArrayList : " + add2(al));
        System.out.println("LinkedList : " + add2(ll));
        System.out.println();

        System.out.println("중간에서 삭제하기");
        System.out.println("ArrayList : " + remove2(al));
        System.out.println("LinkedList : " + remove2(ll));
        System.out.println();
        
        System.out.println("순차적으로 삭제하기");
        System.out.println("ArrayList : " + remove1(al));
        System.out.println("LinkedList : " + remove1(ll));
    }
	
    public static long add1(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            list.add(i + "");
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long add2(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            list.add(500 + "X");
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long remove1(List list) {
        long start = System.currentTimeMillis();
        for (int i = list.size() - 1; i >= 0; i--) {
            list.remove(i);
        }
        long end = System.currentTimeMillis();
        return end - start;
    }

    public static long remove2(List list) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            list.remove(i);
        }
        long end = System.currentTimeMillis();
        return end - start;
    }
}
```

### 실행결과

```java
순차적으로 추가하기
ArrayList : 129
LinkedList : 120

중간에 추가하기
ArrayList : 0
LinkedList : 1

중간에서 삭제하기
ArrayList : 1275
LinkedList : 308

순차적으로 삭제하기
ArrayList : 12
LinkedList : 30

접근 시간 테스트
ArrayList : 0
ArrayList : 325
```

### 결론

1.   **순차적으로 추가/삭제하는 경우는 ArrayList > LinkedList**

     초기에 충분한 초기용량을 확보해서 저장공간이 부족하여 ArrayList를 새로 생성하는 일은 없도록 했다. 만약 공간이 충분하지 않으면 새로운 크기의 ArrayList를 추가해야 하므로 LinkedList가 ArrayList보다 빠를 수 있다. 순차적으로 삭제하는 경우는 마지막부터 역순으로 삭제한다는 것을 의미하며 ArrayList는 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠르다.

2.   **중간 데이터를 추가/삭제하는 경우는 LinkedList > ArrayList**

     LinkedList는 중간에 각 요소간 연결만 변경해주면 되기 때문에 처리속도가 빠르다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈공간을 채워야하기 때문에 처리속도가 늦다.

3.   배열의 경우 만일 인덱스가 n인 요소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결된다.

     인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기

     <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3153a0pr0j20mw04aq36.jpg" alt="Screen Shot 2022-06-08 at 22.07.17" style="zoom:25%;" />

     배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문에 이처럼 간단한 계산으로 요소의 주소를 얻어서 곧바로 읽어올 수 있지만 LinkedList는 불연속적으로 위치한 요소들이 서로 연결된 것이라 차례대로 따라가야만 원하는 값을 얻을 수있다. 따라서 **LinkedList는 데이터의 개수가 많아질수록 접근시간이 길어진다는 단점이 있다.**

4.   정리표

     | 컬렉션     | 읽기(접근시간) | 추가 / 삭제 | 비고                                                    |
     | ---------- | -------------- | ----------- | ------------------------------------------------------- |
     | ArrayList  | 빠르다         | 느리다      | 순차적인 추가삭제는 더 빠름<br />비효율적인 메모리 사용 |
     | LinkedList | 느리다         | 빠르다      | 데이터가 많을수록 접근성이 떨어짐                       |



## Stack과 Queue

### 구조

*   Stack - LIFO(Last In First Out) 구조이다.

    *   0,1,2의 순서로 데이터를 넣었다면 마지막 데이터가 제일 먼저 나오기 때문에 2,1,0의 순서로 빠져나온다. 
    *   `ArrayList가 적합하다` - 스택은 순차적으로 데이터를 추가하고 삭제하기 때문이다.

*   Queue - FIFO(First In FirstOut) 구조이다.

    *   0,1,2의 순서로 데이터를 넣었다면 처음 데이터가 제일 먼저 나오기 때문에 0,1,2의 순서로 빠져나온다.
    *   `LinkedList가 적합하다` - 데이터를 꺼낼때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 ArrayList는 비효율적이다. 따라서 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는게 적합하다.




### Stack - 메서드와 설명

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| boolean empty()          | Stack이 비어있는지 알려준다.                                 |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환한다. pop()과 달리 Stack에서 객체를 꺼내지는 않는다. 비었을 때 `EmptyStackException 발생` |
| Object pop()             | Stack의 맨 위에 저장된 객체를 반환하고 꺼낸다. 비었을 때 `EmptyStackException 발생` |
| Object push(Object item) | Stack에 객체(item)을 저장한다.                               |
| int search(Object o)     | Stack에서 주어진 객체를 찾아서 그 위치를 반환. 못 찾으면 -1을 반환.(배열과 달리 1부터 시작) |



### Queue - 메서드와 설명

| 메서드                  | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. 저장공간이 부족하면 `IllegalStateException 발생` |
| Object remove()         | Queue에서 객체를 꺼내 반환. 비어있으면 `NoSuchElementException 발생` |
| Object element()        | 삭제없이 요소를 읽어온다. peek()과 달리  Queue가 비었을 때  `NoSuchElementException 발생` |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true. 실패하면 false를 반환    |
| Object poll()           | Queue에서 객체를 꺼내서 반환. 비어있으면 null을 반환         |
| Object peek()           | 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환    |

### Stack & Queue 예제

*   예제

```java
public class StackQueueEx {
    public static void main(String[] args) {
        Stack st = new Stack();
        Queue q = new LinkedList(); // Queue 인터페이스의 구현체인 LinkedList를 사용

        st.push("0");
        st.push("1");
        st.push("2");

        q.offer("0");
        q.offer("1");
        q.offer("2");

        System.out.println("- Stack -");
        while (!st.empty()) {
            System.out.println(st.pop());
        }

        System.out.println("- Queue -");
        while (!q.isEmpty()) {
            System.out.println(q.poll());
        }
    }
}
```

*   실행결과

```java
- Stack -
2
1
0
- Queue -
0
1
2
```

>   *   **스택**
>       *   LIFO 구조기 때문에 0,1,2의 순서로 넣었지만 2,1,0으로 출력된다.
>       *   자바에서 스택을 Stack 클래스로 구현하여 제공한다.
>   *   **큐**
>       *   FIFO 구조기 때문에 0,1,2 순서로 넣고 동일하게 0,1,2로 출력된다.
>       *   Queue는 인터페이스로 정의해 놓았을 뿐 클래스를 제공하고 있지는 않다. 다만 이를 구현한 클래스 중 하나를 선택하여 사용하면 된다.



### Stack 직접 구현하기

>   Stack은 컬렉션 프레임워크 이전부터 존재하던 것이기 때문에  ArrayList가 아닌  Vector로부터 상속받아 구현되었다.

```java
public class MyVector extends Vector {
    public Object push(Object item) {
        addElement(item);
        return item;
    }

    public Object pop() {
        Object obj = peek();
        // 만일 Stack이 비어있으면 peek() 메서드가 EmptyStackException을 발생시킨다.
        // 마지막 요소를 삭제한다. 배열의 index가 0부터 시작하므로 1을 빼준다.
        removeElement(size() - 1);
        return obj;
    }

    public Object peek() {
        int len = size();

        if (len == 0) {
            throw new EmptyStackException();
        }
        // 마지막 요소를 반환한다. 배열의 index가 0부터 시작하므로 1을 빼준다.
        return elementAt(len - 1);
    }

    public boolean empty() {
        return size() == 0;
    }

    public int search(Object o) {
        int i = lastIndexOf(o);     // 끝에서 부터 객체를 찾는다.
                                    // 반환값은 저장도니 위치(배열의 index)이다.
        if (i >= 0) {   // 객체를 찾은 경우
            return size() - i;  // Stack은 맨 위에 저장된 객체의 index를 1로 정의하기 때문에 계산을 통해서 구한다.
        }
        return -1;      // 해당 객체를 찾지 못하면 -1을 반환한다.
    }
}
```



### 스택과 큐의 활용

>   우리가 쉽게 찾아볼 수 있는 예는 다음과 같다. 책에서는 다음을 보고 몇가지를 직접 구현하는 예제를 보여주었다.

*   스택의 활용 예 - 수식게산, 수식괄호검사, 워드프로세서의  undo/redo, 웹브라우저의 뒤로/앞으로
*   큐의 활용 예 - 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)



*   스택 예제, 웹브라우저의 뒤로 / 앞으로

```java
public class StackEx1 {
    public static Stack back = new Stack();
    public static Stack forward = new Stack();

    public static void main(String[] args) {
        goURL("1. 네이트");
        goURL("2. 다음");
        goURL("3. 네이버");
        goURL("4. 야후");

        printStatus();

        goBack();
        System.out.println(" '뒤로' 버튼을 누른 후 =");
        printStatus();

        goBack();
        System.out.println(" '뒤로' 버튼을 누른 후 =");
        printStatus();

        goForward();
        System.out.println(" '앞으로' 버튼을 누른 후 =");
        printStatus();

        goURL("codechobo.com");
        System.out.println("새로운 주소로 이동후");
        printStatus();
    }

    // 각 스택을 출력하고 현재 화면을 알려준다, peek()은 객체를 꺼내지 않고 가져온다.
    public static void printStatus() {
        System.out.println("back : " + back);
        System.out.println("forward : " + forward);
        System.out.println("현재 화면은 '" + back.peek() + "' 입니다.");
        System.out.println();
    }

    // 주소 이동. back 스택에 추가하고 forward가 비어있지 않다면 내용 전체를 clear()로 비운다.
    public static void goURL(String url) {
        back.push(url);
        if (!forward.empty()) {
            forward.clear();
        }
    }
    // 앞으로 가기. forward 스택이 비어있지 않다면 back에 forward의 제일 최근 객체를 꺼내 넣는다.
    public static void goForward() {
        if (!forward.empty()) {
            back.push(forward.pop());
        }
    }

    // 뒤로 가기. back 스택이 비어있지 않다면 forward에 back의 제일 최근 객체를 꺼내 넣는다.
    public static void goBack() {
        if (!back.empty()) {
            forward.push(back.pop());
        }
    }
}
```

*   출력결과

```java
back : [1. 네이트, 2. 다음, 3. 네이버, 4. 야후]
forward : []
현재 화면은 '4. 야후' 입니다.

 '뒤로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음, 3. 네이버]
forward : [4. 야후]
현재 화면은 '3. 네이버' 입니다.

 '뒤로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음]
forward : [4. 야후, 3. 네이버]
현재 화면은 '2. 다음' 입니다.

 '앞으로' 버튼을 누른 후 =
back : [1. 네이트, 2. 다음, 3. 네이버]
forward : [4. 야후]
현재 화면은 '3. 네이버' 입니다.

새로운 주소로 이동후
back : [1. 네이트, 2. 다음, 3. 네이버, codechobo.com]
forward : []
현재 화면은 'codechobo.com' 입니다.
```



*   입력한 수식의 괄호가 올바른지 판단하는 예제

```java
public class ExpValidCheck {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage : java ExpValidCheck \"EXPRESSION\"");
            System.out.println("Example : java ExpValidCheck \"((2+3)*1)+3\"");
            System.exit(0);
        }

        Stack st = new Stack();
        String expression = args[0];
        System.out.println("expression : " + expression);

        try {
            for (int i = 0; i < expression.length(); i++) {
                char ch = expression.charAt(i);

                if (ch == '(') {
                    st.push(ch + "");
                } else if (ch == ')') {
                    st.pop();
                }
            }

            if (st.isEmpty()) {
                System.out.println("괄호가 일치합니다.");
            } else {
                System.out.println("괄호가 일치하지 않습니다.");
            }
        } catch (EmptyStackException e) {
            System.out.println("괄호가 일치하지 않습니다.");
        }
    }
}
```

*   출력 결과 (bash에서 실행했다.)

```java
Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java
Usage : java ExpValidCheck "EXPRESSION"
Example : java ExpValidCheck "((2+3)*1)+3"

Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java \(2+3\)*1
expression : (2+3)*1
괄호가 일치합니다.

    
Macui-MacBookAir:stackAndQueue mac$ java ExpValidCheck.java \(2+3\)\)*1
expression : (2+3))*1
괄호가 일치하지 않습니다..
```

