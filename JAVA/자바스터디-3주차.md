## 자바스터디 3주차



### 목표

> 자바가 제공하는 다양한 연산자를 학습하세요.



### 학습할 것

* 산술 연산자
* 비트 연산자
* 관계 연산자
* 논리 연산자
* instanceOf
* assignment( = ) operator
* 화살표( -> ) 연산자
* 3항 연산자
* 연산자 우선 순위
* (Optional) Java13.switch 연산자



## 산술 연산자

> * 산술연산자는 총 5가지로 구성되어있다. 
> * boolean 타입을 제외한 모든 기본 타입에 사용 가능하다.
> * `long` 타입을 제외한 모든 연산의 정수형 타입은 int타입으로 산출된다. 결과값이 int타입인 이유는 JVM이 기본적으로 32비트 단위로 계산하기 때문이다. 
> * 연산 중 하나의 자료형이라도 실수형이 있는 경우에는 실수형 타입으로 결과값을 계산한다.



### 산술 연산자의 종류

| 종류   | 연산자 |
| ------ | ------ |
| 덧셈   | +      |
| 뺄셈   | -      |
| 곱셈   | *      |
| 나눗셈 | /      |
| 나머지 | %      |



### 산술 연산자 예제

```java
public class CalcStudy
  public static void main(String[] args) {
  // 모두 정수형일 경우
  int A = 10;
  int B = 20;
  
  A + B; // 30;
  A - B; // -10;
  A * B; // 200;
  A / B; // 0;
  A % B; // 10;
  
  //실수 타입이 포함된 경우
  double C = 7.7;
  
  System.out.println(A + C); // 17.7;
  
  // 0으로 나누었을 때
  int D = 0;
  
  System.out.println(A / D);  || System.out.println(A % D); 
  // Exception in thread "main" java.lang.ArithmeticException: / by zero
  // 0으로 나눌 수 없다는 Exception 발생
}
```



### 주의점

> * 산술 연산을 할 때 주의할 점은 연산의 결과로 산출될 값이 충분히 표현 가능한 타입인지를 확인해야한다. 그렇지 않으면 오버플로우가 발생하기 때문이다.



## 비트 연산자

> 비트 연산자는 데이터를 비트 단위로 연산한다. 즉 0과 1이 피연산자가 된다. (**0과 1로 표현이 가능한 정수타입만 비트 연산을 할 수 있다.**)
>
> 기능에 따라 `비트 논리 연산자`,`비트 이동 연산자`로 구분한다



### 비트 논리 연산자

> 일반 논리 연산자가 `true/false`를 내뱉는다면 비트 논리 연산자는 `0/1`을 내뱉는다.



#### 비트 논리 연산자의 종류

| 구분               | 연산식 |              |      | 결과 | 설명                                                         |
| ------------------ | ------ | ------------ | ---- | ---- | ------------------------------------------------------------ |
| AND(논리곱)        | 1      | && 또는 &    | 1    | 1    | 두 비트 모두가 1일 경우에만 연산 결과는 1                    |
|                    | 1      |              | 0    | 0    |                                                              |
|                    | 0      |              | 1    | 0    |                                                              |
|                    | 0      |              | 0    | 0    |                                                              |
| OR(논리합)         | 1      | \|\| 또는 \| | 1    | 1    | 두 비트 중 하나만 1이면 연산 결과는 1                        |
|                    | 1      |              | 0    | 1    |                                                              |
|                    | 0      |              | 1    | 1    |                                                              |
|                    | 0      |              | 0    | 0    |                                                              |
| XOR(배타적 논리합) | 1      | ^            | 1    | 0    | 두 비트 중 하나는 1이고 다른 하나가 0일 경우에만 연산 결과는 1 |
|                    | 1      |              | 0    | 1    |                                                              |
|                    | 0      |              | 1    | 1    |                                                              |
|                    | 0      |              | 0    | 0    |                                                              |
| NOT (논리부정)     |        | ~            | 1    | 0    | 보수                                                         |
|                    |        |              | 0    | 1    |                                                              |

#### 보수란 ? (출처 : https://ndb796.tistory.com/4)

보수 : `두 수의 합이 진법의 밑수가 되게 하는 수`, 컴퓨터에서 음의 정수를 표현하기 위해서 고안되었다.

1의 보수 : 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻는다.

> 2진수 1010의 1의 보수는 `0101`이다.

2의 보수 : 1의 보수에 1을 더한 값과 같다.

> 2진수 1010에 대한 2의 보수를 구하려면 2진수 1010에 대한 1의 보수 0101을 구한 다음 1을 더해 `0110`을 얻는다.


![](https://images.velog.io/images/seunghan-baek/post/e9e68db9-b151-425d-95e3-6a0fa9803628/image.png)

#### 확인 예제

```java
public class BigLogicOperator {
    public static void main(String[] args) {
        System.out.println("45 & 25 = " + (45 & 25));
        System.out.println("45 | 25 = " + (45 | 25));
        System.out.println("45 ^ 25 = " + (45 ^ 25));
        System.out.println("~45 = " + (~45));
    }
}
```



### 비트 이동 연산자

> 비트를 좌측 혹은 우측으로 이동하는 연산자이다. 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

#### 비트 이동 연산자의 종류

| 구분         | 연산식 |      |      | 설명                                                         |
| ------------ | ------ | ---- | ---- | ------------------------------------------------------------ |
| 이동(쉬프트) | a      | <<   | b    | 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워진다) |
|              | a      | >>   | b    | 정수 a의 각 비트는 b만큼 오른쪽으로 이동(빈자리는 정수 **a의 최상위 부호 비트**와 같은 값으로 채워진다.) |
|              | a      | >>>  | b    | 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워진다) |



```java
public class BitMoveOperator {
    public static void main(String[] args) {
        System.out.println("1 << 3 = " + (1 << 3));
        System.out.println("-8 >> 3 = " + (-8 >> 3));
        System.out.println("-8 >>> 3 = " + (-8 >>> 3));
    }
}
```



## 관계 연산자

| 연산식 |      |      | 결과  | 설명                    |
| ------ | ---- | ---- | ----- | ----------------------- |
| 1      | ==   | 2    | true  | 1과 2가 같은가          |
| 1      | !=   | 2    | false | 1과 2가 같지 않은가     |
| 1      | >    | 2    | false | 1이 2보다 큰가          |
| 1      | <    | 2    | true  | 1이 2보다 작은가        |
| 3      | >=   | 2    | true  | 3이 2보다 크거나 같은가 |
| 2      | <=   | 2    | true  | 2가 2보다 크거나 같은가 |

> 표에 적혀있듯, 결과는 boolean으로 도출된다. 조건문 또는 반복문에서 자주 사용된다.



## 논리 연산자

> 논리연산자는 논리곱(&&), 논리합(||), 배타적 논리합(^), 논리 부정(!) 연산을 수행한다. 논리 연산자의 피연산자는 boolean 타입만 사용할 수 있다.



### 논리 연산자의 종류와 기능

| 구분               | 연산식 |              |       | 결과  | 설명                                                         |
| ------------------ | ------ | ------------ | ----- | ----- | ------------------------------------------------------------ |
| AND(논리곱)        | true   | && 또는 &    | true  | true  | 피연산자 모두가 true일 경우에만 연산 결과는 true             |
|                    | true   |              | false | false |                                                              |
|                    | false  |              | true  | false |                                                              |
|                    | false  |              | false | false |                                                              |
| OR(논리합)         | true   | \|\| 또는 \| | true  | true  | 피연산자 중 하나만 true이면 연산 결과는 true                 |
|                    | true   |              | false | true  |                                                              |
|                    | false  |              | true  | true  |                                                              |
|                    | false  |              | false | false |                                                              |
| XOR(배타적 논리합) | true   | ^            | true  | false | 피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true |
|                    | true   |              | false | true  |                                                              |
|                    | false  |              | true  | true  |                                                              |
|                    | false  |              | false | false |                                                              |
| NOT (논리부정)     |        | !            | true  | false | 피연산자의 논리값을 바꿈                                     |
|                    |        |              | false | true  |                                                              |

> &&와 &는 산출 결과는 같지만 연산 과정이 조금 다르다. 
>
> * &&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 산출 결과를 낸다. 왜냐면 하나라도 false라면 전체 연산식은 false이기 때문
>
> * &는 두 피연산자 모두를 평가해서 산출 결과를 낸다.
>
>   ▶ &&가 더 효율적으로 동작한다.
>
> ||와 |도 마찬가지 이다. 
>
> * ||는 앞의 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true라는 산출 결과를 낸다. 왜냐면 하나라도 true라면 전체 연산식은 true이기 때문
> * |는 두 피연산자 모두를 평가해서 산출 결과를 낸다.
>
> 
>
> * 논리 연산은 주로 흐름 제어문 등에서 이용된다.



### 확인 예제

```java
public class BoolOperator {
    public static void main(String[] args) {
        boolean myTrue = true;
        boolean yourTrue = true;
        boolean myFalse = false;
        boolean yourFalse = false;

        // AND 논리곱
        System.out.println(" 둘 다 참일 때 : " + (myTrue && yourTrue));
        System.out.println("하나만 참일 때 : " + (myTrue && myFalse));
        System.out.println("하나만 참일 때 2 : " + (myFalse && myTrue));
        System.out.println(" 둘 다 거짓일 때 : " + (myFalse && yourFalse));
        System.out.println("==========================================");
        
        // OR 논리합
        System.out.println(" 둘 다 참일 때 : " + (myTrue || yourTrue));
        System.out.println("하나만 참일 때 : " + (myTrue || myFalse));
        System.out.println("하나만 참일 때 2 : " + (myFalse || myTrue));
        System.out.println(" 둘 다 거짓일 때 : " + (myFalse || yourFalse));
        System.out.println("==========================================");

        // XOR 배타적 논리합
        System.out.println(" 둘 다 참일 때 : " + (myTrue ^ yourTrue));
        System.out.println("하나만 참일 때 : " + (myTrue ^ myFalse));
        System.out.println("하나만 참일 때 2 : " + (myFalse ^ myTrue));
        System.out.println(" 둘 다 거짓일 때 : " + (myFalse ^ yourFalse));
        System.out.println("==========================================");

        // NOT 논리 부정
        System.out.println("참일 때 : " + (!myTrue));
        System.out.println("거짓일 때 : " + (!myFalse));
    }
}
```

연산결과 : 
![](https://images.velog.io/images/seunghan-baek/post/a4c6e05f-c608-4072-be71-8ce89a237c09/image.png)



## InstanceOf

> 객체 타입을 비교 및 확인한다.
>
> 좌항은 객체가 오고, 우항은 타입이 오는데 좌항의 객체가 우항의 인스턴스이면(우항의 타입으로 객체가 생성되었다면) true를 산출한다



```java
boolean result = 좌항(객체) instanceOf 우항(타입)
```



#### 확인 예제

```java
public class InstanceOfExam {
    public static void main(String[] args) {
        TestObj Obj1 = new TestObj();
        TestObj Obj2 = new TestObjChild();

        System.out.println(Obj1 instanceof TestObj); // true
        System.out.println(Obj1 instanceof TestObjChild); // false
        System.out.println(Obj2 instanceof TestObj); // true
        System.out.println(Obj2 instanceof TestObjChild); // true

    }
}
```



## 대입 연산자 Assignment operator

> 대입 연산자는 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다.
>
> 단순 대입 연산자와 복합 대입 연산자로 구분할 수 있다.



| 구분             | 연산식 |      |          | 설명                                                         |
| ---------------- | ------ | ---- | -------- | ------------------------------------------------------------ |
| 단순 대입 연산자 | 변수   | =    | 피연산자 | 우측의 피연산자의 값을 변수에 저장                           |
| 복합 대입 연산자 | 변수   | +=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장 (변수 = 변수 + 피연산자와 동일) |
|                  | 변수   | -=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 뺀 후에 다시 변수에 저장  |
|                  | 변수   | *=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장 |
|                  | 변수   | /=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 나눈 후에 다시 변수에 저장 |
|                  | 변수   | %=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 나눈 후에 나머지를 변수에 저장 |
|                  | 변수   | &=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 & 연산 후에 결과를 변수에 저장 |
|                  | 변수   | \|=  | 피연산자 | 우측의 피연산자의 값을 변수의 값과 \| 연산 후에 결과를 변수에 저장 |
|                  | 변수   | ^=   | 피연산자 | 우측의 피연산자의 값을 변수의 값과 ^ 연산 후에 결과를 변수에 저장 |
|                  | 변수   | <<=  | 피연산자 | 우측의 피연산자의 값을 변수의 값과 << 연산 후에 결과를 변수에 저장 |
|                  | 변수   | >>=  | 피연산자 | 우측의 피연산자의 값을 변수의 값과 >> 연산 후에 결과를 변수에 저장 |
|                  | 변수   | >>>= | 피연산자 | 우측의 피연산자의 값을 변수의 값과 >>> 연산 후에 결과를 변수에 저장 |

* 대입 연산자는 **모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있어** 제일 마지막에 수행된다.
* 연산의 진행이 오른쪽에서 왼쪽이기 때문에 `a = b = c = 5;`는 다음과 같은 순서로 연산된다.

1. `c = 5`
2. `b = c`
3. `a = b`



## 화살표 연산자(Lambda)

* 8버전부터 람다 표현식이 공식적으로 적용되었다.

* 익명함수를 생성하기 위한 식
* 자바 코드가 매우 간결해진다.
* 컬렉션의 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계한다.



#### 기본 문법

```java
(타입 매개변수, ...) -> {실행문; ...}
```

> `(타입 매개변수 ,,,)`는 오른쪽 중괄호 {} 블록을 실행하기 위해 필요한 값을 제공하는 역할
>
> `->` 기호는 매개 변수를 이용해서 중괄호를 실행한다는 뜻



#### 예제 

> int 매개 변수 a의 값을 콘솔에 출력한다.

```JAVA
int(a) -> { System.out.println(a); }
```

* 매개 변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 있기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않는다.
* 하나의 실행문만 있다면 `{}`를 생략해도 괜찮다.



## 삼항 연산자

> 세 개의 피연산자를 필요로 하는 연산자를 말한다.

```java
조건식 ? true일 때 값 또는 연산식 : false일 때 값 또는 연산식
```



#### 예제

```java
public class ConditionalOperator {
    public static void main(String[] args) {
        int score = 95;

        System.out.println((score > 90) ? "90점 보다 높다!" : "90점 보다 낫다ㅠ");
    }
}

```



## 연산자 우선 순위

| 연산자                                | 우선 순위 | 의미                |
| ------------------------------------- | --------- | ------------------- |
| (), []                                | 1         | 괄호 / 대괄호       |
| !, ~, ++, --                          | 2         | 부정 및 증감 연산자 |
| *, /, %                               | 3         | 곱셈 나눗셈 나머지  |
| +, -                                  | 4         | 덧셈 뺄셈           |
| <<, >>, >>>                           | 5         | 비트 쉬프트 연산    |
| <, <=, =, =>, >                       | 6         | 관계 연산자         |
| ==, !=                                | 7         | 관계 연산자         |
| &                                     | 8         | 비트 논리 연산자    |
| ^                                     | 9         | 비트 논리 연산자    |
| &&                                    | 10        | 논리곱              |
| \|\|                                  | 11        | 논리합              |
| ?:                                    | 12        | 조건부 연산(삼항)   |
| =,+=,-=,*=,/=,%=,<<=,>>=,&=,\|=,^=,~= | 13        | 대입 연산자         |



## (optional) Java 13.switch 연산자

> 기존 switch 문의 break문 없이 아래로 떨어지는 걸 방지한다.
>
> * 제일 크게 달라진 것은 `:`대신 `->`을 사용할  수 있다는 것.
>
> * yield 기능을 사용하여 값을 리턴할 수도 있다.