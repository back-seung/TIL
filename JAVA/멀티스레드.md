

## 멀티 스레드

* ### 프로세스 : 

  * 운영체제에서 실행 중인 하나의 애플리케이션
  * 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행하는 것
  * 같은 프로그램을 2개 실행했다면 2개의 프로세스가 생성된 것.

  

* ### 멀티 태스킹 :

  > 두 가지 이상의 작업을 동시에 처리하는 것,
  >
  > 운영체제는 멀티 태스킹을 할 수 있도록 CPU와 메모리 자원을 프로세스마다 적절하게 할당해주고 병렬로 실행시킨다.

  

* ### 멀티 스레드

  > 하나의 프로세스가 두 개의 작업을 처리할 때,
  >
  > 동영상 플레이어는 **동영상 재생**과 **음악 재생**의 역할을한다. 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라고 볼 수 있다.



* ### 멀티 프로세스와 멀티 스레드


> 멀티 프로세스들은 운영체제에서 할당받은 자신의 메모리를 가지고 실행하기 때문에 서로 독립적이다. 따라서 하나의 프로세스에서 오류가 발생해도 다른 프로세스에게 영향을 미치지 않는다.
> 하지만 멀티 스레드는 **하나의 프로세스 내부에 생성되기 때문에** 하나의 스레드가 예외를 발생시키면 나머지 프로세스 자체가 종료될 수 있어 다른 스레드도 영향을 미치게 된다.
>
> **그렇기 때문에 멀티 스레드에서는 예외 처리에 만전을 기해야 한다.**



### 멀티 스레드 사용의 예

1. 대용량 데이터의 처리 시간을 줄이기 위해 데이터를 분할해서 병렬로 처리
2. UI를 가지고 있는 애플리케이션에서 네트워크 통신을 위해 사용
3. 다수 클라이언트의 요청을 처리하는 서버를 개발할 때



### 메인 스레드

> 모든 자바 애플리케이션은 메인 스레드가 `main()` 메서드를 실행하면서 시작된다.
>
> 첫 코드부터 순차적으로 아래로 실행되며 return문을 만나거나, 마지막 코드를 실행하면 종료된다.



* 메인 스레드는 필요에 따라 작업 스레드를 만들어서 병렬로 코드를 실행할 수 있다. (**멀티 스레드를 생성해서 멀티 태스킹을 수행한다.** ) 

* 싱글 스레드 애플리케이션에서는 메인 스레드가 종료하면 프로세스도 종료된다. 하지만 멀티 스레드 애플리케이션에서는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다. ( 메인 스레드가 먼저 종료되더라도 작업 스레드가 실행중이라면 프로세스는 종료되지 않는다. )



### 작업 스레드 생성과 실행

* Runnable 을 매개값으로 갖는 생성자를 호출해야 한다.

  ```java
  Thread thread = new Thread(Runnable target);
  ```

  > * `Runnable`은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체라고 해서 붙여진 이름이다. **인터페이스 타입이기 때문에 구현 객체를 만들어 대입해야한다.** 
  > * `Runnable`에는 `run()` 메서드 하나가 정의되어 있는데 구현 클래스는 `run()`을 재정의해서 작업 스레드가 실행할 코드를 작성해야 한다. 

  

* Runnable 구현 클래스 작성 방법

```java
class Task implements Runnable {
    public void run() {
        스레드가 실행할 코드
    }
}
```



* `Runnable`은 작업 내용을 가지고 있는 객체이지 실제 스레드는 아니다. Runnable 구현 객체를 생성한 후, 이것을 매개값으로 해서 Thread 생성자를 호출하면 비로소 작업 스레드가 생성된다.

```java
Runnable task = new Task();

Thread thread = new Thread(task);
```



* 코드를 좀 더 절약하기 위해 생성자를 호출할 때 Runnable 익명 객체를 매개값으로 사용할 수 있다. 이 방법이 더 많이 사용된다.

```java
Thread thread = new Thread(new Runnable() {
    public void run() {
        스레드가 실행할 코드;
    }
});
```



* `Runnable` 인터페이스는 run() 메소드 하나만 정의되어 있기 때문에 함수적 인터페이스이다. 따라서 다음과 같이 람다식을 매개값으로 사용할 수도 있다.

```java
Thread thread = new Thread( () -> {
    스레드가 실행할 코드;
});
```



* 작업 스레드는 생성 즉시 실행되는 것이 아니라, `start()` 메서드를 다음과 같이 호출해야만 비로소 실행된다.

```java
thread.start();
```

> start() 메서드가 호출되면, 작업 스레드는 매개값으로 받은 Runnable의 run() 메서드를 실행하여 자신의 작업을 처리한다.



### 0.5초 주기로 비프음을 발생시키면서 동시에 프린팅 하는 작업의 예제

### 메인스레드만 사용한 경우

```JAVA
import java.util.*; 

public class BeepPrintExam01 {
    public static void main(String[] args) {
        Toolkit toolkit = new Toolkit.getDefaultToolkit(); // Toolkit 객체 얻기
        for(int i = 0; i < 5; i++) {
            toolkit.beep();
            try {
                Thread.sleep(500);
            } catch(Exception e) {
                e.printStackTrace();
            }
        }
        
        for(int i = 0; i < 5; i++) {
            System.out.println("띵");
            try {
                Thread.sleep(500);
            } catch(Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

> 메인 스레드는 비프음을 모두 발생한 다음, 프린팅을 시작한다.



### 메인 스레드 + 작업 스레드로 수정



* 비프음 작업 스레드

```java
public class BeepTask implements Runnable {
    public void run() {
        Toolkit toolkit = new Toolkit.getDefaultToolkit();
        for(int i = 0; i < 5; i++) {
            toolkit.beep();
            try {
                Thread.sleep(500);
            } catch(Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```



* 메인 스레드에 작업 스레드 import

```java
public class BeepPrintExam02 {
    public static void main(String[] args) {
        Runnable beepTask = new BeepTask();
        Thread thread = new Thread(beepTask);
        thread.start();
        
        for(int i = 0; i < 5; i++) {
            System.out.println("띵");
            try {
                Thread.sleep(500);
            } catch(Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 스레드의 이름

> 스레드는 자신의 이름을 가지고 있다. 큰 역할을 하는 것은 아니지만, 디버깅할 때 어떤 스레드가 어떤 작업을 하는지 조사할 목적으로 가끔 사용된다. 메인 스레드는 "main"이라는 이름을 가지고 있고, 우리가 직접 생성한 스레드는 자동적으로 "Thread-n"이라는 이름으로설정된다.



### 이름 설정 및 불러오기 메서드

* setName :
  * `thread.setName("스레드 이름");` 방식으로 설정할 수 있다.
* getName :
  * `thread.getName();`으로 스레드의 이름을 알 수 있다.

> setName과 getName은 Thread의 인스턴스 메서드이므로 스레드 객체의 참조가 필요하다.



## 스레드 우선순위

> 멀티 스레드는 동시성 또는 병렬성으로 실행되기 때문에 이 용어들에 대해 정확히 이해하는 것이 좋다.

### 동시성 

* 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질

### 병렬성

* 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질 

### 스케줄링

> 스레드의 개수가 코어의 개수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가를 결정해야 하는데, 이를 **스케줄링**이라고 한다.



#### 자바의 스레드 스케줄링

* 우선순위 방식(Priority)과 순환 할당(Round-Robin)방식을 사용

  

#### 우선순위 방식(Priority) 

* 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케줄링.

* 스레드들이 동시성을 가질 경우 우선적으로 실행할 수 있는 순위이다.

* 코드로 제어가 가능하다.

* 우선 순위는 1(낮음) ~ 10(높음)까지로 부여된다. 기본적으로 5가 부여된다.

* `setPriority()` 메서드를 통해 할당할 수 있다. 아래는 Thread 우선 순위 상수

  * `Thread.MAX_PRIORITY` - 10
  * `Thread.NORM_PRIORITY` - 5
  * `Thread.MIN_PRIORITY` - 1

  

#### 순환할당 방식(Round-Robin)

* 시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행
* JVM에 의해서 정해지기 때문에 코드로 제어할 수 없다.



## 동기화 메소드와 동기화 블록

### 공유 객체를 사용할 때의 주의할 점

1. 스레드1에서는 변수값을 100으로 초기화하고 2초를 대기한다.
2. 2초를 대기하는 동안 스레드2에서 변수값을 50으로 초기화한다.
3. 스레드1이 변수값을 출력한다 -> 50
4. 스레드2가 변수값을 출력한다 -> 100

> 멀티 스레드가 하나의 객체를 공유하므로 오류가 생길 수 있다. 공유 객체를 사용할 때 다른 스레드가 값을 변경하기 때문에 엉뚱한 값을 산출하는 문제가 있다.



## 동기화 메소드 및 동기화 블록

> 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야한다.
>
> 멀티 스레드에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 **임계 영역(Critical Section)**이라고 한다.

* 자바는 이 임계 영역을 지정하기 위해 동기화 메서드 및 동기화 블록을 제공한다 - `synchronized` 키워드 사용

### 동기화 메소드 예

```java
public synchronized void method() {
  임계 영역; // 단 하나의 스레드만 실행
}
```

> 동기화 메소드는 synchronize라는 키워드가 붙어있는 것을 볼 수 있다. 메서드의 전체 내용이 임계 영역이 된다.
>
> 실행 시에는 공유 객체에 잠금이 일어나고, 스레드가 동기화 메소드를 실행 종료하면 잠금이 풀린다. 일부 내용만 임계 영역으로 만들고 싶다면 동기화 블록을 사용한다.



### 동기화 블록 예

```java
public void method() {
  // 여러 스레드가 실행 가능한 영역
  .
  .
  .
  synchronized(공유객체){
    임계 영역; // 단 하나의 스레드만 실행
  }
  // 여러 스레드가 실행 가능한 영역
  .
  .
  .
}
```

> 메소드 내부에 synchronized 키워드가 붙어있다. 매개변수로는 공유 객체를 받는다.
>
> 동기화 블록의 외부 코드들은 여러 스레드가 동시에 실행될 수 있지만 내부 코드는 임계 영역이 된다.



## 스레드 상태

> 스레드 객체를 생성하고 start() 메소드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만 실행대기 상태가 된다.
>
> * 실행대기 상태란 아직 스케줄링이 되지 않아서 실행을 기다리는 상태이다.
> * 실행대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 비로소 CPU를 점유하고 run() 메소드를 실행한다. 이때를 실행 상태라고 한다.
> * 실행 상태 스레드는 메소드를 모두 실행하기 전에 다시 실행 대기 상태로 돌아갈 수 있다. 그리고 실행 대기 상태에 있는 다른 실행 대기 스레드가 선택되어 실행 상태가 된다.
> * 이런식으로 번갈아 가면서 자신의 run() 메소드를 실행하고 모든 run() 메소드가 종료되면 종료 상태가 된다.



### 경우에 따라 대기 상태로 가지 않을 수도 있다.

> 실행 상태에서 일시 정지 상태로 가기도 하는데 일시정지 상태는 스레드가 실행할 수 없는 상태이다.

* 이러한 스레드의 상태를 확인하기 위해 자바 5부터 Thread 클래스에 `getState()`가 추가되었다.
* `getState()`는 다음 표처럼 스레드 상태에 따라서 `Thread.State` 열거 상수를 리턴한다.

| 상태      | 열거 상수     | 설명                                                         |
| --------- | ------------- | ------------------------------------------------------------ |
| 객체 생성 | NEW           | 스레드 객체가 생성, 아직 start() 메서드가 호출되지 않은 상태 |
| 실행 대기 | RUNNABLE      | 실행 상태로 언제든지 갈 수 있는 상태                         |
| 일시 정지 | WAITING       | 다른 스레드가 통지할 때까지 기다리는 상태                    |
|           | TIMED_WAITING | 주어진 시간 동안 기다리는 상태                               |
|           | BLOCKED       | 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태        |
| 종료      | TERMINATED    | 실행을 마친 상태                                             |



### 스레드의 상태를 출력하는 예시

* 상태 출력 스레드

```java
public class StatePrintThread extends Thread {
  private Thread targetThread;
  
  public StatePrintThread(Thread targetThread) {
    this.targetThread = targetThread;
  }
  
  public void run() {
    while(true) {
      Thread.State state = targetThread.getState(); // 스레드 상태 얻기
      System.out.println("타겟 스레드 상태 : " + state);
      
      if(state == Thread.State.NEW) { // 객체 생성 상태일 경우 실행대기 상태로 만듦
        targetThread.start();
      }
      
      if(state == Thread.State.TERMINATED) { // 종료 상태일 경우 while문 종료
        break;
      }
      
      try {
        Thread.sleep(500);
      } catch(Exception e) {}
    }
  }
}
```

* 타겟 스레드

```java
public class TargetThread extends Thread {
    public void run() {
        for (long i = 0; i < 1_000_000_000; i++) {
        }

        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (long i = 0; i < 1_000_000_000; i++) {
        }
    }
}
```

* 실행 클래스 및 실행 결과

```java
public class ThreadStateExample {

    public static void main(String[] args) {
        StatePrintThread statePrintThread = new StatePrintThread(new TargetThread());

        statePrintThread.start();
    }
}
```

```java
타겟 스레드 상태NEW
타겟 스레드 상태TIMED_WAITING
타겟 스레드 상태TIMED_WAITING
타겟 스레드 상태TIMED_WAITING
타겟 스레드 상태RUNNABLE
타겟 스레드 상태TERMINATED

종료 코드 0(으)로 완료된 프로세스
```





## 스레드 상태 제어

> * 실행중인 스레드의 상태를 변경하는 것.
> * 멀티 스레드 프로그램을 만들기 위해서는 정교한 스레드 상태 제어가 필요한데, 상태 제어가 잘못되면 프로그램은 불안정해져서 먹통이 되거나 다운된다. 멀티 프로그래밍이 어려운 이유가 여기에 있다.



### 스레드의 상태 변화를 가져오는 메소드

| 메소드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| interrupt()                                                  | 일시 정지 상태의 스레드에서 InterruptException 예외를 발생시켜, 예외 처리 코드에서 실행 대기 상태로 가거나 종료 상태로 갈 수 있도록 한다. |
| notify()<br />notyfyAll()                                    | 동기화 블록 내에서 wait() 메소드에 의해 일시 정지 상태에 있는 스레드를 실행 대기 상태로 만든다. |
| sleep(long mills)<br />sleep(long mills, int nanos)          | 주어진 시간 동안 스레드를 일시 정지 상태로 만든다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다. |
| join()<br />join(long mills)<br />join(long mills, int nanos) | join() 메소드를 호출한 스레드는 일시 정지 상태가 된다. 실행 대기 상태로 가려면 join()메소드를 멤버로 가지는 스레드가 종료되거나, 매개값으로 주어진 시간이 지나야 한다. |
| wait()<br />wait(long mills)<br />wait(long mills, int nanos) | 동기화 블록 내에서 스레드를 일시 정지 상태로 만든다. 매개값으로 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다. 시간이 주어지지 않으면 notify(), notifyAll() 메소드에 의해 실행 대기 상태로 갈 수 있다. |
| yield()                                                      | 실행 중에 우선순위가 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 된다. |

> * wait(), notify(), notifyAll()은 Object의 메소드이다. 그 외에는 모두 Thread 클래스의 메소드이다.ㄴ



### 주어진 시간동안 일시 정지(sleep())

> 실행 중인 스레드를 일정 시간 멈추게 하고 싶다면 Thread 클래스의 정적 메소드인  sleep()을 사용하면 된다.

* sleep()
  * 매개값에는 얼마 동안 일시 정지 상태로 있을 것인지 **밀리세컨드 단위**로 시간을 주면된다.
  * InterruptException이 발생하기 때문에 예외 처리가 필요하다.



### 다른 스레드에게 실행 양보(yield())

> 스레드가 처리하는 작업은 반복적 실행을 위해 for문, while문을 포함하는 경우가 많다. 가끔은 이 반복문이 무의미한 반복을 하는 경우가 있다.

```java
pubic void run() {
  while(true) {
    if(work) {
      System.out.println("Thread-n 작업 내용");s
    }
  }
}
```

> * while문의 work값이 false라면, 그리고 work의 값이 false에서 true로 변경되는 시점이 불명확하다면 무의미한 반복을 한다. 
> * 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 가는 것이 프로그램 성능에 도움이 되는데 스레드는 이를 위해 yield() 메소드를 제공하고 있다.

* yield()
  * 호출한 스레드는 실행 대기 상태로 돌아가고 동일 우선순위 또는 높은 우선순위 스레드가 실행 기회를 가질 수 있도록 함



