# 목표

자바의 상속에 대해 학습하세요.

# 학습할 것 (필수)

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스



## 자바 상속의 특징

### 상속이란?

> 부모 클래스에서 정의된 필드와 메소드를 자식 클래스가 물려받는 것. 하지만 부모의 모든 필드와 메소드를 상속받는 것은 아니다.
>
> * 상속시 사용하는 키워드 : `extends`
> * 필요한 이유 :
>   * 공통된 특징을 가지는 클래스 사이의 중복적 멤버 선언 등 불필요함을 줄이기 위해
>   * 부모 클래스의 멤버를 재사용을함으로 자식 클래스가 간결해진다.
>   * 클래스간 계층적 분류 및 관리가 쉬워진다(부모 클래스를 수정하면 상속받은 자식 클래스도 수정되기 때문)



### 상속의 특징

1. 자바에서는 다중 상속을 지원하지 않는다. 따라서 `extends` 뒤에는 단 하나의 부모 클래스만 올 수 있다. 다음은 다중 상속을 코드로 재현한 것이다.

```java
public class ChildClass extends ParentClass1, ParentClass2 { ... } // X !
public class ChildClass extends ParentClass { ... } // O !
```

2. 자바에서는 상속의 횟수에 제한을 두지 않는다. 뇌절 예제를 통해 확인해보자

```java
package extendsextendsextends;

// 최상위 부모 클래스
public class AClass {
    int field;
}

// 상위 부모 클래스
public class BClass extends AClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속 받는 클래스
public class CClass extends BClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속 받는 클래스를 상속받는 하위 클래스
public class DClass extends CClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속받는 클래스를 상속받는 하위 클래스를 상속받는 최하위 클래스
public class EClass extends DClass{
}
```

3. 자바에서의 최상위 클래스는 언제나 Object 클래스이다. Object 클래스는 유일하게 super class 를 가지고 있지 않다.



## super 키워드

> super 키워드는 부모 클래스로부터 상속 받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수이다.
>
> 부모클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 통해 구별할 수 있다.
>
> super 키워드는 this 키워드와 마찬가지로 참조 변수를 사용할 수 있는 대상은 인스턴스 메소드 뿐이며, 클래스 메소드에서는 사용할 수 없다.

* 예제

```java
class Parent {
  int a = 10;
}

class Child extends Parent {
  int a = 20;
  void display() {
    System.out.println(a); // 20 출력
    System.out.println(this.a); // 20 출력
    System.out.println(super.a); // 10 출력
  }
}

public class Inheritance02 {
  public static void main(String[] args) {
    Child ch = new Child();
    ch.display();
  }
}
```



> 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라, 부모 클래스의 모든 멤버까지도 포함되어 있다.  따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야만 한다.  
>
> 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 `super()` 명령문을 추가하여 부모 크랠스의 멤버를 초기화할 수 있도록 해준다. 
>
> 하지만, 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야만 자동으로 기본 생성자를 추가해준다.

```java
class Parent {
  int a;
  Parent(int a) {
    a = a;
  }
}
```

> 이처럼 **매개변수를 가지는 생성자를 하나라도 선언했다면** 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다. 

```java
class Parent {
  int a; 
  Parent(int a) {
    a = a;
  }
}

class Child extends Parent {
  int b;
  Child() {
    super();
    b = 20;
  }
}
```

> 하지만 이처럼 Parent 클래스를 상속받은 자식 클래스에서 super() 메소드를 사용하여 부모 클래스의 기본 생성자를 호출하게 되면, 오류가 발생한다. 부모 크래스인 Parent 클래스에는 기본 생성자가 추가되지 않았기 때문이다. 따라서 매개변수를 가지는 생성자를 선언할 경우, 기본 생성자를 명시적으로 선언해주는 것이 좋다.

* super() 사용 예제

```java
class Parent {
  int a;
  Parent() {
    a = 10;
  }
}

class Child extends Parent {
  int b;
  Child() {
    super(40); // super.a = 40;
    b = 20;
  }
  void display() {
    System.out.println(a);
    System.out.println(b);
  }
}

public class Inheritance {
  public static void main(String[] args) {
    Child c = new Child();
    c.display();
  }
}

/*
실행 결과 :
40
20
*/
```



## 메소드 오버라이딩

> 메소드 오버라이딩이란 부모 클래스로부터 상속 받은 메소드를 자식 클래스에 맞게 재정의 하는 것을 말한다.
>
> 사용의 이유는 다음과 같다.
>
> 먼저, 상속과 오버라이딩은 긴밀한 관계를 이루고 있는데 자식 클래스는 부모의 멤버 및 메소드를 상속받게 된다. 이 때 부모의 메소드와 다르게 정의할 필요가 있을 때 사용하는 방법이 **메소드 오버라이딩**이다. 메소드 오버라이딩(`@Override`)를 사용하게 되면 부모의 메소드는 숨겨지게 된다.
>
> 메소드 오버라이딩은 추상 클래스를 상속 받을 때, 또는 인터페이스를 구현할 때 많이 사용하게 된다. 일반 클래스의 상속 관계에서는 많이 사용되는 개념은 아니다.



### 오버라이딩의 규칙

1. 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다.
2. 접근 제한을 더 강하게 오버라이딩 할 수 없다.
3. 새로운 예외를 throws 할 수 없다.



## 다이나믹 메소드 디스패치

> 메소드 디스패치란 어떤 메소드를 호출할지 결정하여 실제로 실행시키는 과정이다. 자바는 런타임시 객체를 생성하고, 컴파일 시에는 생성할 객체 타입에 대한 정보만 공유한다.

## 추상 클래스

## final 키워드 

> `final` 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다.  `final`키워드는 **해당 선언이 최종 상태이고 결고 수정될 수 없음을 뜻**한다. `final`키워드가 클래스, 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라진다.

### final 클래스

> 클래스를 선언할 때 final을 class 앞에 붙이게 되면, 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다. final 클래스의 대표적인 예는 자바 표준 API에서 제공하는 String이 있다.  
>
> [String 명세](https://docs.oracle.com/javase/8/docs/api/)

* final 클래스 선언 방법

```java
public final class 클래스 { ... } // 자식 생성 불가 && 부모 클래스 될 수 없음
```



### final 메소드

> 메소드를 선언할 때 final을 선언하게 되면 이 메소드는 최종적인 의미가 되기 때문에 오버라이딩 할 수 없게 된다. 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 재정의 할 수 없다는 것이다. 

### final 필드

> 먼저, final 필드는 다음과 같이 선언한다.

```java
final 타입 필드 [= 초기값];
```

> final 필드의 초기값을 줄 수 있는 방법은 생성자에서 주거나 선언과 동시에 초기화하는 방법밖에 없다.  
>
> final 키워드가 붙은 필드를 초기화하지 않는다면 컴파일 에러가 발생한다.

### 상수 (constant)

> 먼저, 상수는 간단하게 말하면 불변의 값이다. 원주율 또는 지구의 무게 및 둘레처럼 변하지 않는 값을 말한다. 자바에서 상수는 `static final` 키워드로 표현한다.
>
> 하지만 final 키워드도 선언 후에 값을 바꿀 수 없다는 점에서 상수가 될 수 있지 않을까 생각했는데 **불변의 값은 객체마다 저장할 필요가 없는 공용성을 띄고 있고, 여러 가지 값으로 초기화 될 수 없다**는 점에서 final 필드를 상수로 부르진 않는다고 한다. 상수는 객체마다가 아닌 클래스에만 포함되며, 다음과 같이 선언한다.

```java
static final 타입 상수 [= 초기값];
```





## Object 클래스
