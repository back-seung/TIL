# 목표

자바의 상속에 대해 학습하세요.

# 학습할 것 (필수)

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스



## 자바 상속의 특징

### 상속이란?

> 부모 클래스에서 정의된 필드와 메소드를 자식 클래스가 물려받는 것.
>
> * 키워드 : `extends`
> * 필요한 이유 :
>   * 공통된 특징을 가지는 클래스 사이의 중복적 멤버 선언 등 불필요함을 줄이기 위해
>   * 부모 클래스의 멤버를 재사용을함으로 자식 클래스가 간결해진다.
>   * 클래스간 계층적 분류 및 관리가 쉬워진다(부모 클래스를 수정하면 상속받은 자식 클래스도 수정되기 때문)



### 상속의 특징

1. 자바에서는 다중 상속을 지원하지 않는다. 따라서 `extends` 뒤에는 단 하나의 부모 클래스만 올 수 있다. 다음은 다중 상속을 코드로 재현한 것이다.

```java
public class ChildClass extends ParentClass1, ParentClass2 { ... } // X !
public class ChildClass extends ParentClass { ... } // O !
```

2. 자바에서는 상속의 횟수에 제한을 두지 않는다. 뇌절 예제를 통해 확인해보자

```java
package extendsextendsextends;

// 최상위 부모 클래스
public class AClass {
    int field;
}

// 상위 부모 클래스
public class BClass extends AClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속 받는 클래스
public class CClass extends BClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속 받는 클래스를 상속받는 하위 클래스
public class DClass extends CClass {
}

// 최상위 클래스를 상속받는 부모 클래스를 상속받는 클래스를 상속받는 하위 클래스를 상속받는 최하위 클래스
public class EClass extends DClass{
}
```

3. 자바에서의 최상위 클래스는 언제나 Object 클래스이다. Object 클래스는 유일하게 super class 를 가지고 있지 않다.



## super 키워드

> super 키워드는 부모 클래스로부터 상속 받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수이다.
>
> 부모클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 통해 구별할 수 있다.
>
> super 키워드는 this 키워드와 마찬가지로 참조 변수를 사용할 수 있는 대상은 인스턴스 메소드 뿐이며, 클래스 메소드에서는 사용할 수 없다.

* 예제

```java
class Parent {
  int a = 10;
}

class Child extends Parent {
  int a = 20;
  void display() {
    System.out.println(a); // 20 출력
    System.out.println(this.a); // 20 출력
    System.out.println(super.a); // 10 출력
  }
}

public class Inheritance02 {
  public static void main(String[] args) {
    Child ch = new Child();
    ch.display();
  }
}
```



> 자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 멤버뿐만 아니라, 부모 클래스의 모든 멤버까지도 포함되어 있다.  따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야만 한다.  
>
> 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 `super()` 명령문을 추가하여 부모 크랠스의 멤버를 초기화할 수 있도록 해준다. 
>
> 하지만, 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야만 자동으로 기본 생성자를 추가해준다.

```java
class Parent {
  int a;
  Parent(int a) {
    a = a;
  }
}
```

> 이처럼 **매개변수를 가지는 생성자를 하나라도 선언했다면** 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다. 

```java
class Parent {
  int a; 
  Parent(int a) {
    a = a;
  }
}

class Child extends Parent {
  int b;
  Child() {
    super();
    b = 20;
  }
}
```

> 하지만 이처럼 Parent 클래스를 상속받은 자식 클래스에서 super() 메소드를 사용하여 부모 클래스의 기본 생성자를 호출하게 되면, 오류가 발생한다. 부모 크래스인 Parent 클래스에는 기본 생성자가 추가되지 않았기 때문이다. 따라서 매개변수를 가지는 생성자를 선언할 경우, 기본 생성자를 명시적으로 선언해주는 것이 좋다.

* super() 사용 예제

```java
class Parent {
  int a;
  Parent() {
    a = 10;
  }
}

class Child extends Parent {
  int b;
  Child() {
    super(40); // super.a = 40;
    b = 20;
  }
  void display() {
    System.out.println(a);
    System.out.println(b);
  }
}

public class Inheritance {
  public static void main(String[] args) {
    Child c = new Child();
    c.display();
  }
}

/*
실행 결과 :
40
20
*/
```

