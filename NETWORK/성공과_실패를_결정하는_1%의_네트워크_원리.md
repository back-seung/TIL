# 성공과 실패를 결정하는 1%의 네트워크 원리

## 지름길

- 핵심 포인트 - 본문에서 설명할 주제를 간단히 보여주는 내용이다.
- 워밍업 문제 - 간단한 퀴즈이다. 본문의 설명을 좀 더 적극적으로 읽을 수 있는 문제 의식을 찾게한다.
- 탐험 여행의 경유지 - 본문에서 설명하는 주제를 나타낸다. 개요를 먼저 파악해 두는 의미에서 꼭 읽자.
- 용어 설명 - 각 장의 본문 안에서 사용하는 전문 용어를 굵게 표현해놓고 상세히 설명한다.
- 본문 - 각 장의 주제를 중심으로 구조 및 작동 원리를 설명한다. 
- 확인 퀴즈 - 본문의 설명에 관해 퀴즈가 게재된다.
- 에피소드 - 네트워크 용어의 어원에 대해 게재된다. 본질을 이해할 수 있다. 용어에 친숙해진다는 기분으로 읽자.



## 챕터

1. 웹 브라우저가 메시지를 만든다.

   > 브라우저, 웹 서버, URL, HTTP, HTML, 프로토콜, URI, 리퀘스트, 메시지, 리졸버, Socket 라이브러리, DNS 서버, 도메인 명

2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.

   > TCP/IP, 소켓, 프로토콜 스택, IP 주소, 포트 번호, 패킷, 헤더, LAN 어댑터, LAN 드라이버, MAC 주소, 이더넷 컨트롤러, ICMP, UDP

3. 케이블의 앞은 LAN 기기였다.

   > LAN, 트위스트 페어 케이블, 크로스 토크, 리피터 허브, MDI, MDI-X, 스위칭 허브, 전이중, 반이중, 충돌, 자동 조정, 라우터, 경로표, 넷마스크, 기본 게이트 웨이, 조각 나누기, 주소 변환, 글로벌 주소, 프라이빗 주소

4. 엑세스 회선을 통해 인터넷의 내부로.

   > ADSL, FTTP, 광섬유 엑세스 회선, ADSL 모뎀 일체형 라우터, ATM, 셀, 직교 진폭 변조, 스플리터, DSLAM, 브로드밴드 엑세스 서버, 리모트 엑세스 서버, PPP, 네트워크 오퍼레이션 센터, 광섬유, IX(Internet eXchanger)

5. 서버축의 LAN에는 무엇이 있는가?

   > 방화벽, 패킷 필터링, 데이터 센터, 라운드 로빈, 부하 분산 장치, 캐시 서버, 프록시, 프록시 서버, 콘텐츠 배포 서비스, 리다이렉트

6. 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.

   > 응답 메시지, 멀티 태스크, 멀티 스레드, 가상 디렉토리, CGI, 폼, 엑세스 제어, 패스워드, 데이터 형식, MIME

### 

## 흐름

![스크린샷 2022-12-27 23.24.39](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212272324193.png)

- 서버측 : 결승점
- 사용자측 : 출발점



## 01. 웹 브라우저가 메시지를 만든다.

### 1. 탐험 여행은 URL 입력부터 시작한다.

URL은 Uniform Resource Location의 약자로 URL의 맨 앞 문자열인 http:, ftp:, file: 등은 엑세스 하는 방법을 나타낸다.

 엑세스 대상이 웹 서버라면 HTTP 프로토콜을 사용하고, FTP 서버라면 FTP 프로토콜을 사용한다.

 하지만 네트워크를 사용하지 않는 것도 있으므로 프로토콜을 나타낸다고 단언할 수는 없다.



| 다양한 URL 경우                                       | 예제                                                   |
| ----------------------------------------------------- | ------------------------------------------------------ |
| HTTP 프로토콜로 웹 서버에 엑세스하는 경우             | http://user:password@www.cyber.co.kr:80/dir/file1.html |
| FTP 프로토콜로 파일을 다운로드하거나 업로드 하는 경우 | ftp://user:password@ftp.cyber.co.kr:21/dir/file1.html  |
| 클라이언트 PC 자체의 파일에서 데이터를 읽어오는 경우  | file://localhost/c:/path/file1.zip                     |
| 메일을 송신하는 경우                                  | mailto:tone@cyber.co.kr                                |
| 뉴스그룹의 기사를 읽는 경우                           | news:comp.protocols.tcp-ip                             |

### 2. 브라우저는 먼저 URL을 해독한다.

브라우저가 처음 하는 일은 웹 서버에 보내는 리퀘스트의 메시지를 작성하기 위해 이 URL을 해독하는 것이다. URL의 형식은 프로토콜에 따라 다르다.

`http: + // + 웹 서버명 + / + 디렉토리명 + / + ... + 파일명`을 통해 URL의 요소를 확인해보자.

- URL 의 요소
  - `http:` - URL의 맨 앞에는 데이터 출처에 엑세스 하는 방법, 즉 프로토콜을 기록한다.
  - `//` - 나중에 이어지는 문자열이 서버의 이름임을 나타낸다.
  - `/ + 디렉토리명 + / + ... + 파일명` - 데이터 출처(파일)의 경로명을 나타낸다.

### 3. 파일명을 생략한 경우

아래의 URL들을 보며 다음과 같이 생각할 수 있다.

- http://www.lab.cyber.co.kr/dir/ 
  - 끝이 /로 끝난 경우는 /dir/의 다으멩 써야 할 파일명을 쓰지 않고 생략한다는 것이다. URL의 규칙에는 이와 같이 파일명을 생략해도 좋다. 하지만 파일명을 쓰지 않으면 어느 파일에 엑세스해야 할지 모르기 때문에 **파일명을 생략할 때를 대비하여 파일명을 미리 서버측에 설정해준다.** 대부분의 서버는 index.html, default.html이라는 파일명을 설정해 둔다.
  - 따라서 위와 같이 파일명을 생략하면 dir/index.html 또는 dir/default.html이라는 파일에 엑세스한다.
- http://www.lab.cyber.co.kr/
  - 끝에 /가 있으므로 /라는 디렉토리가 지정되고 파일명은 생략된 것이다.
  - 따라서 /index.html 또는 /default.html이라는 파일에 엑세스한다.
- http://www.lab.cyber.co.kr
  - 끝의 / 까지 생략된 경우이다. 디렉토리명까지 생략해버리면 무엇을 요청하고 있는지 알지 못하게 되므로 너무 지나친 생략일 수 있으나 이렇게 쓰는 방법도 인정되고 있다.
  - 루트 디렉토리의 아래에 있는 미리 설정된 파일명의 파일. 즉, /index.html 또는 /default.html이라는 파일에 엑세스 한다.
- http://www.lab.cyber.co.kr/whatisthis
  - 이 경우 맨 끝에 / 가 없으므로 whatisthis를 파일명으로 볼 수도 있으나 실제로는 파일명을 생략하는 규칙을 정확히 이해 못하고 디렉토리의 끝에 있는 / 까지 생략해 버린 경우일 수 있다.
  - 이 때는 whatisthis가 파일일 경우 파일로 간주하고 디렉토리일 경우는 디렉토리로 간주한다.

### 4. HTTP의 기본 개념

- HTTP(HyperText Transfer Protocol) - 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.

HTTP 프로토콜의 기본 개념은 단순하다. 먼저 클라이언트에서 서버를 향해 리퀘스트 메시지를 보내는데 이 메시지에는 무엇을(URI), 어떻게해서(HTTP METHOD) 하겠다는 내용이 쓰여있다. 

- URI(Uniform Rerouce Identifier) - 액세스 대상을 통칭하는 말(URL, URN은 URI에 포함되어 있다고 생각하면 된다). 인터넷 자원을 나타내는 고유 식별자이다. 

- HTTP METHOD 

  | 메소드  | HTTP 1.0 | HTTP 1.1 | 의미                                                         |
  | ------- | -------- | -------- | ------------------------------------------------------------ |
  | GET     | O        | O        | URI로 지정한 정보를 도출한다. 파일의 경우 해당 파일의 내용을 되돌려 보낸다. |
  | POST    | O        | O        | 클라이언트에서 서버로 데이터를 송신한다. 폼에 입력한 데이터를 송신하는 경우 등에 사용한다. |
  | HEAD    | O        | O        | GET과 비슷하지만 헤더의 부분만 돌려 받는다.                  |
  | OPTIONS |          | O        | 통신 옵션을 통지하거나 조사할 때 사용한다.(CORS에서 주로 사용) |
  | PUT     | △        | O        | URI로 지정한 서버의 파일을 치환한다. URI로 지정한 파일이 없는 경우에는 새로 파일을 생성한다. |
  | DELETE  | △        | O        | URI로 지정한 서버의 파일을 삭제한다.                         |
  | TRACE   |          | O        | 서버측에서 받은 리퀘스트 라인, 헤더를 그대로 클라이언트에게 돌려준다(루프백 테스트). 프록시 서버를 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사한다. |
  | CONNECT |          | O        | 암호화한 메시지를 프록시로 전송할 때 이용하는 메서드이다.    |

  주로 사용되는 HTTP 메서드는 다음과 같다.

  #### GET 

  리소스를 조회하는 데 사용된다. 서버에 전달하고 싶은 데이터는 쿼리 파라미터, 쿼리 스트을 통해서 전달한다.

  최근 스펙에서 GET에서 메시지 바디를 사용해 데이터 전달 하는 것을 허용하지만, 지원하지 않는 곳이 많아 비권장한다.

  - 요청

  ```http
  GET /members/100 HTTP/1.1
  Host: localhost:8080
  ```

  - 응답

  ```json
  {
      "username": "young",
      "age": 20
  }
  ```

  #### POST

  새로운 리소스를 생성하는데 사용하거나 요청 데이터를 처리하는데 사용한다.

  POST는 클라이언트에서 메시지 바디를 통해 서버로 데이터를 요청하면 서버가 이 데이터를 처리해달라고 하는 것이다.

  메시지 바디(요청 메시지)를 통해 들어온 데이터를 처리하는 모든 기능을 전부 수행한다.

  - 요청

  ```http
  POST /members HTTP/1.1
  Content-Type: application/json
  
  {
  	"username": "young",
  	"age": 20	
  }
  ```

  

  - 응답

  ```json
  HTTP/1.1 201 Created
  Content-Type: application/json
  Content-Length: 34
  Location: /members/100
  
  {
  	"username": "young",
  	"age": 20	
  }
  ```

  이 외에도 HTTP 프로토콜은 다양한 가능성을 숨겨둔 프로토콜이다.



### 5. HTTP 리퀘스트 메시지를 만든다.

URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP의 리퀘스트 메시지를 만든다. 실제 HTTP 메시지는 포맷이 결정되어 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다. 먼저 리퀘스트 메시지의 첫 번째 행에 있는 리퀘스트 라인을 쓰는데, 이 행에서 중요한 것은 맨 앞에 있는 메서드이다. 메서드는 여러가지가 있으므로 어떤 메서드를 쓸지 판단해야 한다.

리퀘스트 메시지의 구성 요소는 다음과 같다.

```http
<메소드><공백><URI><공백><HTTP 버전>  -> 리퀘스트 라인
<필드명>:<필드값> -> 메시지 헤더, 여기부터 

.
.
.

<공백 행> -> 여기까지
<메시지 본문>
```

- 리퀘스트 라인 - 리퀘스트 메시지의 내용을 대략적으로 알 수 있다.

- 메시지 헤더 - 공백 행 전까지의 내용을 메시지 헤더라고 한다. 한 행당 한 개의 헤더 필드를 쓴다.

- 메시지 본문 - 클라이언트에서 서버에 송신하는 데이터. 폼 페이지에 입력한 데이터를 POST 메소드로 웹 서버에 보낼 때 등에 데이터가 들어간다.

- 예시

  ![image-20230101145737768](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202301011457472.png)

URL 입력 상자에 URL을 입력하면 해당 페이지를 표시하므로 GET 메서드를 사용한다. 폼의 경우 폼 부분의 입력값을 보내야 하기 때문에 POST 메서드를 사용한다.

메소드를 썼으면 한칸 띄운 다음에  URI를 작성하고 메시지가 HTTP의 어느 버전인지 번호를 써서 첫 번째 행을 완료한다.

두 번째 행의 헤더에는 부가적인 자세한 정보가 필요한 경우, 이것을 써두는 용도이다. 다수의 항목이 사양으로 정해져있다. 

- 헤더 필드의 종류(`제네럴 헤더` - 리퀘스트와 응답 양쪽에 모두 사용하는 헤더 필드)

  | 필드              | HTTP 1.0 | HTTP 1.1 | 설명                                                         |
  | ----------------- | -------- | -------- | ------------------------------------------------------------ |
  | Date              | O        | O        | 리퀘스트나 응답이 작성된 날짜를 나타낸다.                    |
  | Pragma            | O        | O        | 데이터의 캐시를 허용할지의 여부를 나타내는 통신 옵션을 지정한다. |
  | Cache-Control     |          | O        | 캐시를 제어하기 위한 정보                                    |
  | Connection        |          | O        | 응답 송신 후에 TCP에 계속 접속할지, 아니면 연결을 끊을지를 나타내는 통신 옵션을 지정한다. |
  | Transfer-Encoding |          | O        | 메세제 본문의 인코딩 방식을 나타낸다.                        |
  | Via               |          | O        | 도중에 경유한 프록시, 게이트웨이를 기록한다.                 |

- 헤더 필드의 종류(`리퀘스트 헤더` - 리퀘스트의 부가 정보롤 사용하는 헤더 필드)

  | 필드                | HTTP 1.0 | HTTP 1.1 | 설명                                                         |
  | ------------------- | -------- | -------- | ------------------------------------------------------------ |
  | Authorization       | O        | O        | 사용자 인증용 데이터                                         |
  | From                | O        | O        | 리퀘스트 발신자의 메일 주소                                  |
  | If-Modified-Since   | O        | O        | 지정한 날짜 이후 정보가 갱신된 경우에만 리퀘스트를 실행하려고 필드값으로 이 날짜를 지정한다. 보통 클라이언트측에서 캐시에 저장된 정보를 비교하고 이것이 오래된 경우에 새 정보를 받으려고 할 때 사용한다. |
  | Referer             | O        | O        | 하이퍼링크를 거쳐 어느 페이지를 읽은 경우 등에 링크 대상인 URI를 나타낸다. |
  | User-Agent          | O        | O        | 클라이언트 소프트웨어의 명칭이나 버전에 대한 정보            |
  | Accept              | △        | O        | 클라이언트측이 Content-Type으로 받는 데이터의 종류. MIME 사양의 데이터 타입으로 표현한 것이다. |
  | Accept-Charset      | △        | O        | 클라이언트측이 받은 문자 코드 세트                           |
  | Accept-Encoding     | △        | O        | 클라이언트측이 Content-Encoding으로 받은 인코딩 방식. 보통 데이터 압축 형식을 나타낸다. |
  | Accept-Language     | △        | O        | 클라이언트측이 받는 언어의 종류, 한국어 : ko, 영어 : en이다. |
  | Host                |          | O        | 리퀘스트를 받는 서버의 IP주소와 포트 번호                    |
  | If-Match            |          | O        | Etag 참조                                                    |
  | If-None-Match       |          | O        | Etag 참조                                                    |
  | If-Unmodified-Since |          | O        | 지정한 날짜 이후 갱신되지 않은 경우에만 리퀘스트를 실행한다. |
  | Range               |          | O        | 데이터의 전체가 아니라 일부만 읽을 때 해당 범위를 지정한다   |

  마지막 메시지 바디에는 헤더의 끝 다음 공백 이후에 작성한다. 메시지 바디에는 클라이언트가 서버에 송신하는 데이터를 작성하는데, GET의 경우 메소드와 URI만으로 서버에 무엇을 어떻게 요구하는지 판단할 수 있으므로 메시지 바디에 무언가 적을 필요가 없다(최근 스펙에서는 작성을 허용하나, 권장하지 않는다.). POST인 경우에는 위 설명과 같이 폼에 입력한 데이터 등을 메시지 바디에 적는다.

  이 메시지를 보내면 웹 서버에서 응답 메시지가 되돌아온다. 응답 메시지의 기본 개념도 리퀘스트 메시지와 동일하다. 하지만 첫 번째 행이 다르다.

응답 메시지의 구성 요소는 다음과 같다.

```http
<HTTP 버전><공백><스테이터스 코드><공백><응답 문구> -> 스테이터스 라인
<필드명>:<필드값> -> 메시지 헤더, 여기부터

.
.
.

<공백 행> -> 여기까지
<메시지 본문>
```

- 스테이터스 라인 - 응답 HTTP 프로토콜의 버전, 응답코드, 응답 메시지가 포함되어 있다.

  - 응답 코드 - 숫자로 표시하고 실행 결과를 알려주는 것이 목적이다.
  - 응답 메시지 - 문장으로 쓰여있으며 사람에게 실행 결과를 알리는 것이 목적이다.

  | 코드값 | 설명                                  |
  | ------ | ------------------------------------- |
  | 1xx    | 처리의 경과 상황 등을 통지한다.       |
  | 2xx    | 정상 종료                             |
  | 3xx    | 무언가 다른 조치가 필요함을 나타낸다. |
  | 4xx    | 클라이언트 측의 오류                  |
  | 5xx    | 서버 측의 오류                        |

- 메시지 헤더 - 날짜, 웹 서버 이름 및 버전, 콘텐츠 타입, 캐시 제어 방식, 컨텐츠 길이 등의 값이 나온다.
- 메시지 본문 - 실제 응답 리소스 데이터가 나오는 부분이다.

- 헤더 필드의 종류(`응답 헤더` - 응답의 부가 정보로 사용되는 헤더 필드 )

  | 헤더 필드의 종류 | HTTP 1.0 | HTTP 1.1 | 설명                                                         |
  | ---------------- | -------- | -------- | ------------------------------------------------------------ |
  | Location         | O        | O        | 정보의 정확한 장소를 나타낸다. 리퀘스트의 URI가 상대 경로로 지정된 경우 절대 경로의 정보의 위치를 통지하기 위해 사용한다. |
  | Server           | O        | O        | 서버 소프트웨어의 명칭이나 버전에 대한 정보                  |
  | WWW-Authenticate | O        | O        | 리퀘스트한 정보에 대한 엑세스가 제한되어 있는 경우 사용자 인증용 데이터 |
  | Accept-Ranges    |          | O        | 데이터의 일부인 리퀘스트하는 Range를 지정한 경우 서버가 해당 기능을 가지고 있는지의 여부를 클라이언트에 통지한다. |

- 헤더 필드의 종류(`엔티티 헤더` - 엔티티의 부가 정보로 사용하는 헤더 필드)

  | 헤더 필드의 종류 | HTTP 1.0 | HTTP 1.1 | 설명                                                         |
  | ---------------- | -------- | -------- | ------------------------------------------------------------ |
  | Allow            | O        | O        | 지정한 URI로 사용 가능한 메서드를 나타낸다.                  |
  | Content-Encoding | O        | O        | 메시지 본문에 압축 등의 인코딩 처리가 되어 있는 경우 해당 방식을 나타낸다. |
  | Content-Length   | O        | O        | 메시지 본문의 길이를 나타낸다.                               |
  | Content-Type     | O        | O        | 메시지 본문이 어떤 데이터인지 종류를 나타낸다. MIME 사양으로 정의된데이터 타입으로 데이터의 종류를 나타낸다. |
  | Expires          | O        | O        | 메시지 본문의 유효 기간을 나타낸다.                          |
  | Last-Modified    | O        | O        | 정보를 최종 변경한 일시                                      |
  | Content-Language |          | O        | 메시지 본문의 언어를나타낸다. 한국어 : ko, 영어 : en이다.    |
  | Content-Location |          | O        | 메시지 본문이 서버의 어디에 놓여 있는지 위치를 URI로 나타낸다. |
  | Content-Range    |          | O        | 데이터의 전체가 아니라 일부가 리퀘스트된 경우 메시지 본문에 어느 범위의 데이터가 포함되어 있는지를 나타낸다. |
  | Etag             |          | O        | 갱신 처리 등에서 이전 리퀘스트의 응답을 바탕으로 한 갱신 데이터를 다음 리퀘스트에서 송신하는 경우가 있는데 이때 이전 응답과 다음 리퀘스트를 관련시키기 위해 사용하는 정보이다. 이전 응답에서 서버가 Etag에 따라 고유한 값을 클라이언트에 건네주고 다음 번 리퀘스트의 If-Match, If-None-Match, If-Range 필드에서 값을 서버에 통지하면 서버는 이전 회의 계속이라고 인식한다 |

  응답 메시지가 되돌아오면 그 때부터 데이터를 추출한 후, 화면에 표시해 웹 페이지를 눈으로 볼 수 있다. 페이지가 문장으로만 되어있으면 그걸로 끝이지만 사진, 동영상 등 html 태그가 함께 있는 경우엔 계속되는 내용이 있다. **따라서 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다. 영상 등을 포함하고 있는 의미의 태그를 만나면 웹페이지에 영상용 공백을 남겨두고 문장을 표시한다. 이후 다시 웹 서버의 URI에 파일의 경로로 엑세스하여 파일의 이름을 쓴 리퀘스트 메시지를 만들어 보낸다. 그렇게 읽어온 값을 비워둔 공백에 표시한다.** 

  만약 3개의 동영상을 표시해야 한다면 문장 파일을 읽는 리퀘스트와 영상 파일을 읽는 리퀘스트로 총 4회의 리퀘스트 메시지를 웹 서버에 보낸다.

  이렇게 불러온 값들을 레이아웃을 정하여 화면에 표시하는 상태로 전체의 동작을 조정하는 것도 **브라우저의 역할**이다.



## 02. 웹 서버의 IP 주소를 DNS서버에 조회한다.

### 1. IP 주소의 기본

1. HTTP 메시지를 만들면 브라우저는 **OS에 의뢰하여** 엑세스 대상인 웹서버에 송신한다.
   - 브라우저는  URL 해독, HTTP 메시지를 생성하지만 메시지를 네트워크에 송신하는 기능은 없기 때문에 OS에 의뢰하는 것이다.

2. 웹 서버의 도메인명을 통해 IP 주소를 조사해야 한다.
   - OS에 송신을 의뢰할 때는 도메인명이 아닌 IP주소로 메시지를 받을 상대를 지정해야 하기 때문이다.

**IP 주소란?**

인터넷, 사내LAN 등은 TCP/IP를 기초하였다.

TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어진다고 볼 수 있다. 여기에 XX동 XX번지를 할당한다. 이 때 **XX동은 서브넷에 할당하는 것으로 네트워크 번호라 부르고, XX번지는 컴퓨터에 할당하는 것으로, 호스트 번호라고 부른다.**

| 글에 나온 용어 | 설명                                                         |
| :------------- | :----------------------------------------------------------- |
| 서브넷         | 허브에 몇 대의 PC가 접속된 것                                |
| 네트워크 번호  | 서브넷에 할당되는 번호                                       |
| 호스트 번호    | 컴퓨터에 할당되는 번호                                       |
| IP 주소        | `네트워크 번호(16bit) ` + `호스트 번호(16bit)`를 합쳐 32비트를 1바이트씩 `.`으로 구분하여 10진수로 표기한 것. 내역은 결정되지 않는다. |
| 넷마스크       | 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있다. 이 내역을 나타내는 정보를 필요에 따라 IP 주소에 덧붙히는데 이 정보를 넷마스크라고 한다. |



- 예시

  1. IP 주소의 본체 표기

     `10.11.12.13`

  2. IP 주소 본체 표기와 같은 방법으로 네트워크 번호 표기

     `10.11.12.13`(IP 주소 본체)/`255.255.255.0`(넷마스크)

  3. 네트워크 비트 수로 넷마스크 표기

     `10.11.12.13`(IP 주소 본체)/`24`(넷마스크 비트)

  4. 서브넷을 나타내는주소

     `10.11.12.0/24` - 호스트 번호 부분의 비트가 모두 **0인 것은 각 컴퓨터가 아닌 서브넷 자체를 나타낸다.**

  5. 서브넷의 브로드캐스트를 나타내는 주소

     `10.11.12.255/24` - 호스트 번호 부분의 비트가 모두 **1인 것은 서브넷 전체에 대한 브로드캐스트를 나타낸다.**

     

- 넷마스크를 통해 네트워크 번호와 호스트 번호를 구분하는 방법

  | 구분          | 10진수 표기   | 왼쪽의 10진수 표기를 비트로 고친 것 | 비고                                                         |
  | ------------- | ------------- | ----------------------------------- | ------------------------------------------------------------ |
  | IP 주소       | 10.1.2.3      | 00001010.00000001.00000010.0000001  |                                                              |
  | 넷마스크      | 255.255.255.0 | 11111111.11111111.11111111.00000000 | 넷마스크가 1인 부분은 네트워크 번호를 나타내고, 0인 부분은 호스트 번호를 나타낸다. |
  |               |               |                                     |                                                              |
  | 네트워크 번호 | 10.1.2        | 00001010.00000001.00000010          |                                                              |
  | 호스트 번호   | 3             | 00000011                            |                                                              |

- TCP/IP와 IP 주소의 기본적인 개념

  엑세스 대상의 서버까지 메시지를 운반할 때는 이 IP 주소에 따라 엑세스 대상이 어디에 있는지 판단하고 운반한다. 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반하고 송신측에서 가장 가까운 라우터까지 도착한다. 그리고 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고 거기에 보내도록 지시하여 송신동작을 실행한다. 다시 서브넷의 허브가 라우터까지 메시지를 보낸다. 위 동작들을 반복하다보면 최종 목적이로 상대의 데이터가 도착한다는 원리이다.



### 2. 도메인명과 IP 주소를 구분하여 사용하는 이유 & 3. Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.

TCP/IP는 IP를 모르면 상대에게 메시지를 전달할 수 없다.

이는 IP 주소로 통신 상대를 지정하기 때문인데, 이 상황은 전화를 걸 때 전화번호가 필요한 것과 동일하다. 사람의 이름을 외우는 것은 편해도 전화번호를 직접 외우는 것은 힘든것처럼 IP 주소와 같은 숫자들을 외우는 것은 꽤나 어려운 일이다. 따라서 도메인명을 입력하여 IP주소를  DNS 서버에서 조회한다.

> DNS(Domain Name Service)란 - 전세계적으로 **서버의 IP 주소와 도메인 주소를 이어주는 환경/시스템**. 이름을 알면 IP 주소를 알 수 있거나, IP 주소를 알면 이름을 알 수 있다는 원리를 사용해 양 쪽의 차이를 해소한다

그럼 애초에 도메인명으로 상대를 지정하여 통신하는 방법도 괜찮지 않을까?라는 의문이 생기지만 인터넷의 내부에는 다수의 규칙이 있고 이들이 연대하여 IP 주소에 의해 목적지를 판단하여 데이터를 운반한다. 이를 실행 효율의 관점에서 바라보면 도메인명은 `적게는 수십 ~ 최대 255바이트`의 크기이지만 IP는 `4바이트`의 크기이다. 따라서 IP 주소를 사용하는 것이 상대적으로 라우터에 부하를 덜 주는 방법인 것이다.

그럼 발전된 기술인 고성능 라우터를 사용한다면? 동작 속도가 향상 되겠지만 라우터의 속도는 한계가 존재한다. 한계에 다다르면 방대한 양의 데이터가 인터넷의 내부에 정체될 수 있어 효율성이 낮다.

위와 같은 다양한 이유로 도메인명과 IP 주소를 구분하여 DNS 서버에 도메인명을 통해 IP주소를 조사한다.

브라우저는 어덯게 DNS 서버를 조회할까? 우선 DNS 서버를 조회한다는 것은 DNS 서버에 조회 메시지를 보내고 응답으로 돌아오는 메시지를 받는 것이다. 이것은 브라우저가 DNS 서버에 대해 클라이언트로 동작한다는 것이다라고 말할 수 있다. 이 때 DNS 서버의 클라이언트 객체는 `리졸버`라고한다. 그리고 DNS의 원리로 도메인명을 통해 IP주소를 조사하는 것을 `네임 리졸루션`이라고 말한다. `리졸버`는  Socket 라이브러리에 포함되어 있다.

- 용어 정리

  | 글에 나온 용어                                 | 설명                                                         |
  | ---------------------------------------------- | ------------------------------------------------------------ |
  | DNS 리졸버 또는 리졸버(Resolver, DNS Resolver) | DNS 서버의 클라이언트 객체. Socket 라이브러리에 포함되어 있다. |
  | 네임 리졸루션(Name Resolution)                 | DNS의 원리로 도메인명을 통해 IP주소를 조사하는 것. 리졸루션을 실행하는 것이 리졸버이다. |
  | 소켓 라이브러리(Socket Library)                | OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위해 부품을 모아놓은 것 |



### 4. 리졸버를 이용하여 DNS 서버를 조회한다.

```java
public void getIPAddress(String domainName) {
  String ip = getHostByName(domainName);
  .
  .
  .
  // HTTP 메시지 송신을 한다.
}
```

추상적인 코드지만 위처럼 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고 DNS 서버에서 응답 메시지가 돌아온다. 이 응답 메시지에 IP 주소가 포함되어 있다.

리졸버가 IP 주소를 조회하는 동작이 끝나면 브라우저는 웹 서버에 메시지를 보낼 때 IP 주소를 포함하여 HTTP 리퀘스트 메시지를 OS에 건네주며 송신을 의뢰한다.

### 5. 리졸버 내부의 작동

- 리졸버를 호출하면 제어가 네트워크 애플리케이션 -> 리졸버로 넘어간다. 
- 리졸버에 제어가 넘어가면 여기서 리졸버가 DNS 서버에 문의하기 위한 메시지를 만든다. 이 문의하기 위한 메시지는 HTTP 리퀘스트 메시지와 유사하다. 하지만 다음이 다르다.
  - HTTP 리퀘스트 메시지 - 문자 데이터
  - DNS 문의 메시지 - 바이너리 데이터
- 이후 리졸버는 메시지를 DNS 서버에 보내기 위해 OS에 포함된 프로토콜 스택을 호출한다. 
  - 리졸버 또한 브라우저와 마찬가지로 네트워크에 대한 데이터를 송/수신 하는 기능은 없다.
- 실행되어 보내진 메시지가 DNS 서버에 도착하고 DNS 서버는 조회 내용을 조사하여 답을 찾는다. 답이 있다면 응답 메시지를 보내준다.
  - 응답은 차례대로 네트워크를 통해 클라이언트에 도착 -> 프로토콜 스택 경유 -> 리졸버에 건네짐의 순서로 온다.
- 응답을 받은 리졸버는 응답 메시지 해독 및 IP 주소를 추출하여 애플리케이션의 메모리 영역에 이를 저장하고 동작을 마친다.
- 리졸버의 동작이 끝나면 제어가 애플리케이션에 돌아온다.



DNS 서버도 주소가 존재하는데 이 주소는 어떻게 알고 문의 메시지를 보내는지가 의문이다. 이는 DNS 서버 주소는 대게 TCP/IP의 설정 항목의 하나하나로 컴퓨터에 미리 설정되어 있어 따로 조사할 필요는 없다.



## 03. 전 세계의 DNS서버가 연대한다.

### 1. DNS 서버의 기본 동작

DNS 서버의 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.

조회 메시지는 세가지의 정보가 포함되어 있다.

1. 이름
   - 서버나 메일 배송 목적지
2. 클래스
   - 인터넷 이외에도 네트워크에서의 이용까지 DNS 구조를 검토하여 식별하기 위해 고안되었다.
   - **현재 인터넷 외의 네트워크는 소멸하여, 인터넷을 나타내는 `IN`만을 사용한다.**
3. 타입
   - 이름에 어떤 타입의 정보가 지원되는지를 나타낸다.
     - `A(Address)` - 이름에 IP 주소가 지원된다.
     - `MX(Mail eXchange)` - 이름에 메일 배송 목적지가 지원된다.
   - 타입에 따라 클라이언트에 응답하는 정보의 내용이 달라진다.
   - A, MX 외에도 다양한 타입이 존재한다. PTR, CNAME, NS, SOA 등이 있다.

DNS 서버에는 위 세가지 정보에 대응하여 회답하는 항목을 등록해두었다.



![스크린샷 2023-01-05 22.41.59](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202301052242786.png)

위 그림처럼 DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입 세 가지가 일치하는 것을 찾는다. 

- 등록된 정보 예시

| 이름                | 클래스 | 타입 | 클라이언트에 회답하는 항목 |
| ------------------- | ------ | ---- | -------------------------- |
| www.lab.cyber.co.kr | IN     | A    | 192.0.2.226                |
| cyber.co.kr         | IN     | MX   | 10 mail.cyber.co.kr        |
| mail.cyber.co.kr    | IN     | A    | 192.0.2.227                |

- 리소스 레코드 - 설정 파일에 등록하는 내용을 나타낸 것 중 한 건분의 등록 정보. 실제로는 설정 파일 등에 입력되어 있다. 위 표처럼 테이블 형태는 아니다.
- 이름 - 조회 항목의 이름과 이 항목(테이블 값)을 비교하여 해당하는 것을 찾는다.
- 클래스 - 조회 항목의 클래스와 이 항목(테이블 값)을 비교하여 해당하는 것을 찾는다.
- 타입 - 조회 항목의 타입과 이 항목(테이블 값)을 비교하여 해당하는 것을 찾는다.



이 중 타입이 MX인 것의 회답 항목을 보면 `메일의 배송 목적지 우선순위`와 `메일 서버의 이름`이 등록되어 있다.

또한 MX인 경우에는 회답뿐만 아니라 mail.cyber.co.kr이라는 메일 서버의 IP 주소(192.0.2.227)도 함께 응답한다.

이와 같이 이름과 타입에 따라 조사하는 정보를 저장하고 그것에 따라 해당하는 것을 찾아 클라이언트에 회답하는 것이 DNS 서버의 기본 동작이다.

DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다. DNS 서버의 동작은 조회 메시지 속의 이름과 타입에 해당하는 정보를 찾아내어 회답하는 단순한 원리지만, 타입을 구분해서 사용해야하므로 다양한 정보를 취급할 수 있다.



### 2. 도메인의 계층

