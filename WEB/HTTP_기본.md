# HTTP_기본

> 출처 : 김영한님의 "모든 개발자를 위한 HTTP 웹 기본 지식"

## 모든 것이 HTTP

> HTTP는 무엇을 할 수 있을까

* html, text
* image, 음성, 영상, 파일
* JSON, XML (API)
* 거의 모든 형태의 데이터를 전송할 수 있다.
* 서버간 데이터를 주고 받을 때도 HTTP를 사용한다.
  * TCP/IP를 직접 주고 받는 경우는 드물다.



### HTTP의 역사

> 우리에게 2.0, 3.0대신 1.1 버전이 가장 중요한 이유는 1.1 스펙에 대부분의 모든 기능이 구현되어 있고, 2.0, 3.0은 성능 개선 위주이다.

| 연도 | 버전       | 특징                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1991 | HTTP / 0.9 | GET 메서드만 지원, 헤더가 없음                               |
| 1996 | HTTP / 1.0 | 메서드, 헤더 추가                                            |
| 1997 | HTTP / 1.1 | 가장 많이 사용, 우리에게 가장 중요한 버전이다.<br />RFC2068(1997) -> RFC2616(1999) -> RFC7230 ~ 7235(2014)로 3번의 개정을 하였다. |
| 2015 | HTTP / 2.0 | 성능 개선                                                    |
|      | HTTP / 3.0 | 진행 중. 성능 개선, UDP 사용                                 |



## 클라이언트 서버 구조

* Request, Response 구조
* 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.
* 서버가 요청에 대한 결과를 만들어서 응답한다.

이전에는 클라이언트, 서버라는 개념이 분리되지 않았었다. 이를 개념적으로 클라이언트와 서버를 분리했고, UI/UX는 클라이언트에 집어넣고, 데이터, 비즈니스 로직은 서버에 집어넣게 되면서 각각 독립적인 진화가 가능해졌다.



## Stateful, Stateless

### 상태유지 - Stateful

서버가 클라이언트의 이전 상태를 보존함

* 단점 : 중간에 서버가 장애가 나면 클라이언트가 처음부터 다시 요청을 보내야 한다.

### 무상태 - Stateless

서버가 클라이언트의 상태를 보존하지 않음

* 장점 : 서버 확장성이 높음(스케일 아웃 - 수평확장 유리)
* 단점 : 클라이언트가 추가 데이터를 전송해야함



### Stateless 실무 한계

* 모든 것을 무상태로 설계할 수 있는 경우가 있고, 없는 경우도 있다.
  * 무상태의 예 - 로그인이 필요 없는 단순 서비스 소개화면
  * 상태 유지의 예 - 로그인
* 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지(주로 쿠키, 세션 등을 사용해서 상태를 유지)
* 상태 유지는 최소한만 사용



## 비연결성(Connectionless)

> 연결을 유지하는 모델과 유지하지 않는 모델을 예시로 설명한다.







