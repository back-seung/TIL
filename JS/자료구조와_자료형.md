# 코어 자바스크립트 - 자료구조와 자료형

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## 원시값의 메서드 - ⭐️

자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 원시값은 객체가 아님을 상기하자.

### 원시값과 객체의 차이

- 원시값

  - string, number, bigint, boolean, symbol, null, undefined형으로 총 일곱가지의 원시형 값이다.

- 객체

  - 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
  - `{name : "John", age: 30}`와 같이 중괄호를 사용해 만들 수 있다. 자바스크립트에는 여러 종류의 객체가 있는데 함수도 객체의 일종이다.
  - 개게의 장점 중 하나는 함수를 프로퍼티로 지정할 수 있다는 것이다.

  ```javascript
  let john = {
      name: "John",
      age: 30,
  	sayHi: function() {
      	alert("친구야 반갑다");    
  	}
  };
  
  john.sayHi(); // 친구야 반갑다
  ```

  객체 john을 만들고 거기에 메서드 sayHi를 정의했다. 자바스크립트는 다양한 내장 객체를 제공한다. 이 객체들은 고유한 프로퍼티와 메서드를 가진다.

  하지만 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 객체는 **원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.**



### 원시값을 객체처럼 사용하기

- 문자열이나 숫자와 같은 원시값을 다루는 작업이 많은데 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각
- 원시값은 가능한 한 가볍고 빨라야 한다.

의 상황을 해결해야만 했던 JS의 창안자는

1. 원시값은 원시값대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체 "원시 래퍼 객체"를 만들어준다. 이 객체는 곧 삭제된다.

Wrapper객체는 원시 타입에 따라 종류가 다양하며 원시값의 이름을 그대로 차용해 String, Number, Boolean, Symbol라고 부른다. 객체 마다 제공하는 메서드 역시 다르다.

- 예제

```javascript
let str = "hello";

alert(str.toUpperCase()); // HELLO
```

문자열 str은 원시값이므로 원시값의 프로퍼티에 접근하는 순간 래퍼 객체가 만들어지고 이 객체는 toUpperCase() 메서드를 실행하여 새로운 문자열 HELLO를 반환한다. 그리고 객체는 파괴되며 원시값 str만 남는다.

JS 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게끔 해준다.

숫자형도 고유한 메서드를 지원한다. 메서드 toFixed(n)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할  수 있다.

- 예제

```java
let n = 1.23456;

alert(n.toFixed(2)); // 1.23
```



숫자형, 문자열에서 더 많은 메서드를 알아보자

#### String/Number/Boolean을 생성자로 사용하면 혼란스럽다.

- 예시 1

```javascript
alert(typeof 0); // number
alert(typeof new Number(0)); // object
```

- 예시 2

```javascript
let zero = new Number(0);

if(zero) {
	alert("0이 참?");
}
```

그런데, new 키워드를 사용하지 않고 String/Number/Boolean을 사용하는 것은 괜찮다. 인수를 원하는 형의 원시값으로 바꿔준다.

#### unll/undefined는 메서드가 없다.

특수 자료형인 null/undefined의 원시값은 위와 같은 법칙을 따르지 않는다. 이 자료형과 연관되는 래퍼 객체도 없고 메서드도 제공하지 않는다. 어떤 의미에서는 두 자료형이 가장 원시적이라 할 수 있다.



## 숫자형 - ⭐️

모던 자바스크립튼느 숫자를 나타내는 두 가지 자료형을 제공한다.

1. 일반적인 숫자는 배정밀도 부동소수점 숫자로 알려진 64비트 형식의 IEEE-754에 저장된다. 
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다. 일반적인 숫자는 2의 53제곱 이상이거나 -2의 53제곱 이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다. BigInt는 아주 특별한 경우에만 사용되므로 별도의 챕터에서 다뤄진다.

### 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 했을 때 아래와 같이 직접 10억을 써줄 수 있다.

```javascript
let billion = 1000000000;
```

그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않는다. 그래서 대게 10억을 나타낼 땐 `1bn`을 사용하고 73억을 나타낼 땐 `7.3bn`을 사용한다.

자바스크립트도 숫자 옆에 e를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9; // 10억 1과 9개의 0

alert(7.3e9); // 73억
```

`e`는 e왼쪽의 수에 e오른쪽에 있는 수만큼의 10 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 10 * 10 * 10
1.23e6 = 1.23 * 1000000
```

반대로 작은 숫자를 표현할 때도 e를 사용할 수 있다. 0을 명시적으로 쓰고 싶지 않으면 다음과 같이 숫자를 표현할 수 있다.

```javascript
// before
let ms = 0.000001;
// after
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```



#### 16진수, 2진수, 8진수

16진수는 0x를 사용해 표현할 수 있다. 대 소문자를 가리지 않는다.

```javascript
alert(0xff); // 255
alert(0xFF); // 255
```

2진수와 8진수는 드물게 쓰이긴 하지만 0b, 0o를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111;
let b= 0o377;

alert(a == b); // true
```



### toString(base)

`num.toString(base)` 메서드는 base 진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환한다.

- 예시

```javascript
let num = 255;

alert(num.toString(16)); // 16진수 string으로 변경. ff
alert(num.toString(2)); // 2진수 string으로 변경. 11111111
```

base는 2 ~ 36까지 사용 가능하다. 기본값은 10이다.

- `base=16` - 16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 0 ~ 9, 10이상의 수는 A ~ F를 사용하여 나타낸다.

- `base=2` - 비트 연산 디버깅에 주로 쓰인다. 숫자는 0 || 1이다. 

- `base=36 ` - 사용할 수 있는 base 중 최대값으로 0..9, A..Z를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다. base는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다. 

  - 예시

  ```javascript
  alert(123456..toString(36)); // 2n9c
  ```

  > 숫자를 대상으로 메서드 toString()을 직접 호출하고 싶으면 `..`을 사용해야 한다. 



### 어림수 구하기

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

- `Math.floor()`- 소수점 첫째 자리에서 내림. 3.1은 3으로 -1.1은 -2가 된다.
- `Math.ceil()` - 소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 된다. 
- `Math.round()` - 소수점 첫째 자리에서 반올림. 3.1은 3, -1.1은 -1이 된다.
- `Math.trunc()` - 소수부를 무시한다. 3.1은 3, -1.1은 -1이 된다.

소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 경우, 어떻게 해야 할까

1. 곱하기와 나누기

소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 하고 처음 곱한 수를 다시 나누면 된다.

```javascript
let num = 1.23456;
alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 / 100 -> 1.23
```

2. 소수점 n번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n)를 사용한다.

```javascript
let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// toFixed()는 Math.round()와 비슷하게 동작한다.
num = 12.36;
alert(num.toFixed(1)); // "12.4"
```

toFixed()의 반환값은 문자열이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.

```javascript
let num = 12.34;
alert(num.toFixed(5)); // "12.34000"; 
```



### 부정확한 계산

숫자는 내부적으로 64비트 IEEE-754로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 피룡하다. 64비트 중 52비트는 숫자를 저장하는데 사용되고, 11비트는 소수점 위치, 1비트는 음양의 부호를 저장하는데 사용된다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert(1e500); // Infinity
```

정밀도 손실의 예시를 살펴보자.

```javascript
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.3000000000004
```

0.1과 0.2의 합이 0.3이 아니라 0.300000000004가 나오는데, 이러한 값이 나오는 것을 정밀도 손실이라고 한다.

왜 이런일이 발생할까?

숫자는 0과1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 **10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2같은 분수는 이진법으로 표현하면 무한소수가 된다.**

2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없다. IEEE-754에서는 이러한 무한소수를 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 해결한다. 하지만 이런 반올림 규척을 적용하면 작은 정밀도 손실이 발생한다.

그래서 0.1 + 0.2가 정확히 0.3이 아닌 이유가 된다.

이러한 문제를 해결하는데 도움을 주는 것이 toFixed(n)을 사용해 어림수를 만드는 것이다.

```javascript
let sum = 0.1 + 0.2;
alert(sum.toFixed(2))// 0.30;
```

이때 toFixed는 항상 문자열을 반환한다는 점에 유의하자. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 숫자로 변환하고 싶다면 단항 연산자 +를 사용하자.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```



#### 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 현상은 0, -0이라는 두 종류의 0이 존재한다는 사실이다. 

자바스크립트에서는 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은 0과 -0을 동일하게 취급하기 때문에 두 0의 차이는 쉽게 두드러지지 않는다.



### isNaN, isFinite

- `Infinity` - 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` - 에러를 나타내는 값

두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- isNaN(value) - 인수를 숫자로 변환한 다음 NaN인지 테스트함

```javascript
alert(isNaN(NaN)); // true
alert(isNaN("str")); // false
```

===과 같은 비교연산이 아닌 isNaN 메서드를 사용하는 이유는 NaN은 자기자신을 포함해 어떤 값과도 같지 않기 때문이다.

- isFinite(value) - 인수를 숫자로 변환하고 변환한 숫자가  NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우  true 반환

```javascript
alert(isFinite("15")); // true
alert(isFinite("str")); // false, NaN이기 때문에
alert(isFinite(Infinity)); // false
```

isFinite는 문자열이 일반 숫자인지 검증하는데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요, " '');

alert(isFinite(num));
```



### parseInt, parseFloat

단항 덧셈 연산자 + 또는 Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert(+"100px"); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

하지만 12px, 14pt, 1.5em등의 숫자만 추출하는 방법이 필요할 때는 내장 함수 parseInt, parseFloat를 사용한다. 이 메서드는 불가능할 때까지 문자열에서 숫자를 읽고 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환된다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

parseInt, parseFloat이 NaN을 반환하는 경우도 있는데 읽을 수 있는 숫자가 없을 때 그렇다.

```javascript
alert(parseInt('a123')); // NaN
```

- parseInt(str, radix)

  parseInt의 두 번째 인수 radix는 선택사항이다. radix는 원하는 진수를 지정해줄 때 사용한다. 16, 2진수 등의 문자열 등을 파싱할 수 있다.



### 기타 수학 함수

- `Math.random()` - 0과 1 사이의 난수를 반환한다.

```javascript
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (무작위 수)
```

 

- `Math.max(a, b, c ...), Math.min(a, b, c ...)` - 인수 중 최대/최소값을 반환

```javascript
alert( Math.max(3, 5, -10, 0, 1) ); // 5 
alert( Math.min(1, 2) ); // 1
```

- `Math.pow(n, power)` - n을  power번 거듭제곱한 값을 반환

```javascript
alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
```



## 문자열 - ⭐

자바스크립트는 char와 같이 문자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다.

JS에서 문자열은 페이지 인코딩 방식과 상관없이 UTF-16형식을 따른다.



### 따옴표

문자열은 `''`, `""`, ` `` `으로 감쌀 수 있다.

```javascript
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

작은 따옴표와 큰 따옴표는 기능상 차이가 없지만, 백틱은 특별한 기능이 있다. 표현식을 `${..}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 넣을 수 있다. 이 방식을 **템플릿 리터럴**이라고 부른다.

```javascript
function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1,2)}.`); // 1 +  2 = 3
```

백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.

```javascript
let guestList = `손님: 
* John,
* Pete,
* Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
```

하지만 작은 따옴표, 큰 따옴표를 사용하면 여러 줄에 걸쳐 작성하는 것이 불가능하다.



### 특수 기호

줄 바꿈 문자라 불리는 특수 기호 `\n`을 사용하면 작은 따옴표나 큰 따옴표로도 여러 줄 문자열을 만들 수 있다.

```javascript
let guestList = "손님:\n * John\n * Pete\n * Mary";

alert(guestList);
```

그 외에 다양한 특수 기호가 존재한다.

| 특수 문자                                            | 설명                                                         |
| :--------------------------------------------------- | :----------------------------------------------------------- |
| `\n`                                                 | 줄 바꿈                                                      |
| `\r`                                                 | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꿉니다. 캐리지 리턴을 단독으론 사용하는 경우는 없습니다. |
| `\'`, `\"`                                           | 따옴표                                                       |
| `\\`                                                 | 역슬래시                                                     |
| `\t`                                                 | 탭                                                           |
| `\b`, `\f`, `\v`                                     | 각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타냅니다. 호환성 유지를 위해 남아있는 기호로 요즘엔 사용하지 않습니다. |
| `\xXX`                                               | 16진수 유니코드 `XX`로 표현한 유니코드 글자입니다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일함). |
| `\uXXXX`                                             | UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호입니다. `XXXX`는 반드시 네 개의 16진수로 구성되어야 합니다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드임). |
| `\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호입니다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지합니다. 이 방법을 사용하면 긴 코드를 삽입할 수 있습니다. |

### 문자열의 길이

JS에서의 length는 다른 언어에서의 length()와 달리 메서드가 아닌 프로퍼티이다.

```javascript
let str = 'Hello';

alert(str.length); // 5
```



### 특정 글자에 접근하기

문자열 내 특정 위치인 pos에 있는 글자에 접근하려면 [pos]같이 대괄호를 이용하거나 str.charAt(pos)라는 메서드를 호출한다. 위치는 0부터 시작이다. 

```javascript
let str = 'Hello';

alert(str[0]); // H
alert(str.charAt(0)); // H

alert(str[str.length - 1]); // o
```

둘 중 charAt은 비교적 옛날 방식이며 요즘엔  []를 사용한다.

#### 반환할 글자가 없을 때 [], charAt()의 차이

- [] - undefined
- charAt(pos) - 빈 문자열

### 문자열의 불변성

문자열은 수정할 수 없다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

```javascript
let str = 'hi';

str[0] = 'H'; // Error: Cannot assign to read only property '0' of string 'hi'
alert(str[0]); // 동작하지 않는다.
```

이런 문제를 피하려면 **완전히 새로운 문자열을 하나 만든 다음 이 문자열을 str에 할당하면 된다.**

```javascript
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체함

alert( str ); // hi
```



## 대·소문자 변경하기

- 대문자로 변경 - toUpperCase()
- 소문자로 변경 - toLowerCase()



### 부분 문자열 찾기

`str.indexOf(substr, pos)` - 이 메서드는 문자열 str의 pos부터 시작해 substr이 어딨는지 찾아준다. 부분 문자열을 찾으면 위치를 반환, 찾지 못하면 -1을 반환한다. 반대로 문자열의 맨 끝부터 위치를 찾고 싶다면 `str.lastIndexOf()`를 사용하면 된다.

```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함

alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

두 번째 매개변수 pos는 선택적 사용인데, 이를 명시하면 검색을 해당 위치에서부터 시작한다.

```javascript
let str = 'Widget with id';

alert(str.indexOf('id', 2)); // 12
```

이 외에 비교적 근래에 나온 메서드인 str.includes(substr, pos)는 true, false를 반환한다. 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.

또한 `startsWith()`, `endsWith()`메서드도 있는데 이는 메서드 이름 그래도 문자열이 특정 문자열로 시작하는지 또는 끝나는지의 여부를 확인할 때 사용한다.



### 부분 문자열 추출하기

자바스크립트엔 부분 문자열 추출과 관련된 메서드가 세가지 있다.

- substring
- substr
- slice

위 세개의 메서드를 하나씩 알아보자

* `str.slice(start [, end])`

  문자열의 `start`부터 `end`까지(`end`는 미포함)를 반환한다.

  ```javascript
  let str = "stringify"; alert(str.slice(0, 5) ); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함하지 않음) 
  alert(str.slice(0, 1) ); // 's', 0번째부터 1번째 위치까지(1번째 위치의 자는 포함하지 않음)
  ```

  두 번째 인수가 생략된 경우엔, 명시한 위치부터 문자열 끝까지를 반환한다.

* `str.substring(start, [, end])`

  start, end 사이에 있는 문자열을 반환한다.  slice와 유사하지만 start가 end보다 커도 괜찮다는데 차이가 있다. 

  ```javascript
  let str = "stringify";
  
  // 동일한 부분 문자열을 반환.
  alert( str.substring(2, 6) ); // "ring"
  alert( str.substring(6, 2) ); // "ring"
  
  // slice를 사용하면 결과가 다름
  alert( str.slice(2, 6) ); // "ring" (같음)
  alert( str.slice(6, 2) ); // "" (빈 문자열)
  ```

* `str.substr(start, [, length])`

  start에서 시작해 length개의 글자를 반환한다.

  substr은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서  substring, slice와 차이가 있다.

  ```javascript
  let str = "stringify";
  alert( str.substr(2, 4) ); // ring, 두 번째부터 글자 네 개
  ```

  첫번째 인수가 음수면 뒤에서부터 개수를 센다.

  ```javascript
  let str = "stringify";
  alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두 개
  ```

  

부분 문자열 추출과 관련된 메서드를 요약해보자.

| 메서드                  | 추출할 부분 문자열                    | 음수 허용 여부(인수)  |
| :---------------------- | :------------------------------------ | :-------------------- |
| `slice(start, end)`     | `start`부터 `end`까지(`end`는 미포함) | 음수 허용             |
| `substring(start, end)` | `start`와 `end` 사이                  | 음수는 `0`으로 취급함 |
| `substr(start, length)` | `start`부터 `length`개의 글자         | 음수 허용             |



### 문자열 비교하기

문자열을 비교할 땐 **알파벳 순서를 기준으로 글자끼리 비교가 이뤄진다.** 모든 문자열은 UTF-16으로 인코딩된다.



## 배열 -

순서가 있는 컬렉션을 저장할 때 자료구조 중 하나인 배열을 사용할 수 있다.

### 배열 선언

```javascript
let arr = new Array();
let arr = [];
```

대부분은 2번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것이 가능하다.

```javascript
let fruits = ['사과', '오렌지', '자두'];
```

배열의 요소에 접근하려면 대괄호[]안에 순서를 나타내는 숫자인 인덱스를 넣어주어야 하는데 인덱스는 0부터 시작한다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두
```

또한 배열의 요소를 수정하거나 추가할 수도 있다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

fruits[2] = '배';
fruits[3] = '레몬';
```

length는 배열의 길이를 나타낸다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert(fruits.length); // 3
```

배열의 자료형에는 제약이 없다.

```javascript
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];
```

### pop·push와 shift·unshift

배열의 메서드를 알기전에 큐와 스택에 대해 간단히 알아보자.

큐는 배열을 사용해 만들 수 있는 대표적인 자료구조로 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용한다. 먼저 집어넣은 요소가 먼저 나오는 FIFO(First In First Out)구조이다. 큐에서 사용하는 주요 연산은 다음과 같다.

- push : 맨 끝에 요소를 추가한다.
- shift : 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다.

스택은 한쪽 끝에 요소를 더하거나 뺄 수 있게 해주는 자료구조이다. 가장 나중에 넣은 요소가 가장 먼저 나오는 LIFO(Last In First Out)구조이다. 스택에서 사용하는 주요 연산은 다음과 같다.

- push : 요소를 스택 끝에 집어넣는다.
- pop : 스택의 끝 요소를 추출한다.



배열의 끝 또는 앞에 무언가를 해주는 메서드는 다음과 같다.

- pop : 배열의 끝 요소를 제거하고 제거한 요소를 반환한다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 띄움.

alert( fruits ); // 사과,오렌지
```

- push : 배열 끝에 요소를 추가한다.	 

```javascript
let fruits = ["사과", "오렌지"];

fruits.push("배");

alert( fruits ); // 사과,오렌지,배
```

- shift : 배열 앞 요소를 제거하고, 제거한 요소를 반환한다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 띄움.

alert( fruits ); // 오렌지,배
```

- unshift

```javascript
let fruits = ["오렌지", "배"];

fruits.unshift('사과');

alert( fruits ); // 사과,오렌지,배
```
