# 코어 자바스크립트 - 자료구조와 자료형

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## 원시값의 메서드 - ⭐️

자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 원시값은 객체가 아님을 상기하자.

### 원시값과 객체의 차이

- 원시값

  - string, number, bigint, boolean, symbol, null, undefined형으로 총 일곱가지의 원시형 값이다.

- 객체

  - 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
  - `{name : "John", age: 30}`와 같이 중괄호를 사용해 만들 수 있다. 자바스크립트에는 여러 종류의 객체가 있는데 함수도 객체의 일종이다.
  - 개게의 장점 중 하나는 함수를 프로퍼티로 지정할 수 있다는 것이다.

  ```javascript
  let john = {
      name: "John",
      age: 30,
  	sayHi: function() {
      	alert("친구야 반갑다");    
  	}
  };
  
  john.sayHi(); // 친구야 반갑다
  ```

  객체 john을 만들고 거기에 메서드 sayHi를 정의했다. 자바스크립트는 다양한 내장 객체를 제공한다. 이 객체들은 고유한 프로퍼티와 메서드를 가진다.

  하지만 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 객체는 **원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.**



### 원시값을 객체처럼 사용하기

- 문자열이나 숫자와 같은 원시값을 다루는 작업이 많은데 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각
- 원시값은 가능한 한 가볍고 빨라야 한다.

의 상황을 해결해야만 했던 JS의 창안자는

1. 원시값은 원시값대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체 "원시 래퍼 객체"를 만들어준다. 이 객체는 곧 삭제된다.

Wrapper객체는 원시 타입에 따라 종류가 다양하며 원시값의 이름을 그대로 차용해 String, Number, Boolean, Symbol라고 부른다. 객체 마다 제공하는 메서드 역시 다르다.

- 예제

```javascript
let str = "hello";

alert(str.toUpperCase()); // HELLO
```

문자열 str은 원시값이므로 원시값의 프로퍼티에 접근하는 순간 래퍼 객체가 만들어지고 이 객체는 toUpperCase() 메서드를 실행하여 새로운 문자열 HELLO를 반환한다. 그리고 객체는 파괴되며 원시값 str만 남는다.

JS 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게끔 해준다.

숫자형도 고유한 메서드를 지원한다. 메서드 toFixed(n)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할  수 있다.

- 예제

```java
let n = 1.23456;

alert(n.toFixed(2)); // 1.23
```



숫자형, 문자열에서 더 많은 메서드를 알아보자

#### String/Number/Boolean을 생성자로 사용하면 혼란스럽다.

- 예시 1

```javascript
alert(typeof 0); // number
alert(typeof new Number(0)); // object
```

- 예시 2

```javascript
let zero = new Number(0);

if(zero) {
	alert("0이 참?");
}
```

그런데, new 키워드를 사용하지 않고 String/Number/Boolean을 사용하는 것은 괜찮다. 인수를 원하는 형의 원시값으로 바꿔준다.

#### unll/undefined는 메서드가 없다.

특수 자료형인 null/undefined의 원시값은 위와 같은 법칙을 따르지 않는다. 이 자료형과 연관되는 래퍼 객체도 없고 메서드도 제공하지 않는다. 어떤 의미에서는 두 자료형이 가장 원시적이라 할 수 있다.



## 숫자형 - ⭐️

모던 자바스크립튼느 숫자를 나타내는 두 가지 자료형을 제공한다.

1. 일반적인 숫자는 배정밀도 부동소수점 숫자로 알려진 64비트 형식의 IEEE-754에 저장된다. 
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다. 일반적인 숫자는 2의 53제곱 이상이거나 -2의 53제곱 이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다. BigInt는 아주 특별한 경우에만 사용되므로 별도의 챕터에서 다뤄진다.

### 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 했을 때 아래와 같이 직접 10억을 써줄 수 있다.

```javascript
let billion = 1000000000;
```

그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않는다. 그래서 대게 10억을 나타낼 땐 `1bn`을 사용하고 73억을 나타낼 땐 `7.3bn`을 사용한다.

자바스크립트도 숫자 옆에 e를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9; // 10억 1과 9개의 0

alert(7.3e9); // 73억
```

`e`는 e왼쪽의 수에 e오른쪽에 있는 수만큼의 10 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 10 * 10 * 10
1.23e6 = 1.23 * 1000000
```

반대로 작은 숫자를 표현할 때도 e를 사용할 수 있다. 0을 명시적으로 쓰고 싶지 않으면 다음과 같이 숫자를 표현할 수 있다.

```javascript
// before
let ms = 0.000001;
// after
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```



#### 16진수, 2진수, 8진수

16진수는 0x를 사용해 표현할 수 있다. 대 소문자를 가리지 않는다.

```javascript
alert(0xff); // 255
alert(0xFF); // 255
```

2진수와 8진수는 드물게 쓰이긴 하지만 0b, 0o를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111;
let b= 0o377;

alert(a == b); // true
```



### toString(base)

`num.toString(base)` 메서드는 base 진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환한다.

- 예시

```javascript
let num = 255;

alert(num.toString(16)); // 16진수 string으로 변경. ff
alert(num.toString(2)); // 2진수 string으로 변경. 11111111
```

base는 2 ~ 36까지 사용 가능하다. 기본값은 10이다.

- `base=16` - 16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 0 ~ 9, 10이상의 수는 A ~ F를 사용하여 나타낸다.

- `base=2` - 비트 연산 디버깅에 주로 쓰인다. 숫자는 0 || 1이다. 

- `base=36 ` - 사용할 수 있는 base 중 최대값으로 0..9, A..Z를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다. base는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다. 

  - 예시

  ```javascript
  alert(123456..toString(36)); // 2n9c
  ```

  > 숫자를 대상으로 메서드 toString()을 직접 호출하고 싶으면 `..`을 사용해야 한다. 



### 어림수 구하기

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

- `Math.floor()`- 소수점 첫째 자리에서 내림. 3.1은 3으로 -1.1은 -2가 된다.
- `Math.ceil()` - 소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 된다. 
- `Math.round()` - 소수점 첫째 자리에서 반올림. 3.1은 3, -1.1은 -1이 된다.
- `Math.trunc()` - 소수부를 무시한다. 3.1은 3, -1.1은 -1이 된다.

소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 경우, 어떻게 해야 할까

1. 곱하기와 나누기

소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 하고 처음 곱한 수를 다시 나누면 된다.

```javascript
let num = 1.23456;
alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 / 100 -> 1.23
```

2. 소수점 n번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n)를 사용한다.

```javascript
let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// toFixed()는 Math.round()와 비슷하게 동작한다.
num = 12.36;
alert(num.toFixed(1)); // "12.4"
```

toFixed()의 반환값은 문자열이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.

```javascript
let num = 12.34;
alert(num.toFixed(5)); // "12.34000"; 
```



### 부정확한 계산

숫자는 내부적으로 64비트 IEEE-754로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 피룡하다. 64비트 중 52비트는 숫자를 저장하는데 사용되고, 11비트는 소수점 위치, 1비트는 음양의 부호를 저장하는데 사용된다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert(1e500); // Infinity
```

정밀도 손실의 예시를 살펴보자.

```javascript
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.3000000000004
```

0.1과 0.2의 합이 0.3이 아니라 0.300000000004가 나오는데, 이러한 값이 나오는 것을 정밀도 손실이라고 한다.

왜 이런일이 발생할까?

숫자는 0과1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 **10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2같은 분수는 이진법으로 표현하면 무한소수가 된다.**

2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없다. IEEE-754에서는 이러한 무한소수를 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 해결한다. 하지만 이런 반올림 규척을 적용하면 작은 정밀도 손실이 발생한다.

그래서 0.1 + 0.2가 정확히 0.3이 아닌 이유가 된다.

이러한 문제를 해결하는데 도움을 주는 것이 toFixed(n)을 사용해 어림수를 만드는 것이다.

```javascript
let sum = 0.1 + 0.2;
alert(sum.toFixed(2))// 0.30;
```

이때 toFixed는 항상 문자열을 반환한다는 점에 유의하자. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 숫자로 변환하고 싶다면 단항 연산자 +를 사용하자.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```



#### 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 현상은 0, -0이라는 두 종류의 0이 존재한다는 사실이다. 

자바스크립트에서는 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은 0과 -0을 동일하게 취급하기 때문에 두 0의 차이는 쉽게 두드러지지 않는다.



### isNaN, isFinite

- `Infinity` - 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` - 에러를 나타내는 값

두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- isNaN(value) - 인수를 숫자로 변환한 다음 NaN인지 테스트함

```javascript
alert(isNaN(NaN)); // true
alert(isNaN("str")); // false
```

===과 같은 비교연산이 아닌 isNaN 메서드를 사용하는 이유는 NaN은 자기자신을 포함해 어떤 값과도 같지 않기 때문이다.

- isFinite(value) - 인수를 숫자로 변환하고 변환한 숫자가  NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우  true 반환

```javascript
alert(isFinite("15")); // true
alert(isFinite("str")); // false, NaN이기 때문에
alert(isFinite(Infinity)); // false
```

isFinite는 문자열이 일반 숫자인지 검증하는데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요, " '');

alert(isFinite(num));
```



### parseInt, parseFloat

단항 덧셈 연산자 + 또는 Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert(+"100px"); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

하지만 12px, 14pt, 1.5em등의 숫자만 추출하는 방법이 필요할 때는 내장 함수 parseInt, parseFloat를 사용한다. 이 메서드는 불가능할 때까지 문자열에서 숫자를 읽고 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환된다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

parseInt, parseFloat이 NaN을 반환하는 경우도 있는데 읽을 수 있는 숫자가 없을 때 그렇다.

```javascript
alert(parseInt('a123')); // NaN
```

- parseInt(str, radix)

  parseInt의 두 번째 인수 radix는 선택사항이다. radix는 원하는 진수를 지정해줄 때 사용한다. 16, 2진수 등의 문자열 등을 파싱할 수 있다.



### 기타 수학 함수

- `Math.random()` - 0과 1 사이의 난수를 반환한다.

```javascript
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (무작위 수)
```

 

- `Math.max(a, b, c ...), Math.min(a, b, c ...)` - 인수 중 최대/최소값을 반환

```javascript
alert( Math.max(3, 5, -10, 0, 1) ); // 5 
alert( Math.min(1, 2) ); // 1
```

- `Math.pow(n, power)` - n을  power번 거듭제곱한 값을 반환

```javascript
alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
```



## 문자열 - ⭐

자바스크립트는 char와 같이 문자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다.

JS에서 문자열은 페이지 인코딩 방식과 상관없이 UTF-16형식을 따른다.



### 따옴표

문자열은 `''`, `""`, ` `` `으로 감쌀 수 있다.

```javascript
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

작은 따옴표와 큰 따옴표는 기능상 차이가 없지만, 백틱은 특별한 기능이 있다. 표현식을 `${..}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 넣을 수 있다. 이 방식을 **템플릿 리터럴**이라고 부른다.

```javascript
function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1,2)}.`); // 1 +  2 = 3
```

백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.

```javascript
let guestList = `손님: 
* John,
* Pete,
* Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
```

하지만 작은 따옴표, 큰 따옴표를 사용하면 여러 줄에 걸쳐 작성하는 것이 불가능하다.



### 특수 기호

줄 바꿈 문자라 불리는 특수 기호 `\n`을 사용하면 작은 따옴표나 큰 따옴표로도 여러 줄 문자열을 만들 수 있다.

```javascript
let guestList = "손님:\n * John\n * Pete\n * Mary";

alert(guestList);
```

그 외에 다양한 특수 기호가 존재한다.

| 특수 문자                                            | 설명                                                         |
| :--------------------------------------------------- | :----------------------------------------------------------- |
| `\n`                                                 | 줄 바꿈                                                      |
| `\r`                                                 | 캐리지 리턴(carriage return). Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꿉니다. 캐리지 리턴을 단독으론 사용하는 경우는 없습니다. |
| `\'`, `\"`                                           | 따옴표                                                       |
| `\\`                                                 | 역슬래시                                                     |
| `\t`                                                 | 탭                                                           |
| `\b`, `\f`, `\v`                                     | 각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타냅니다. 호환성 유지를 위해 남아있는 기호로 요즘엔 사용하지 않습니다. |
| `\xXX`                                               | 16진수 유니코드 `XX`로 표현한 유니코드 글자입니다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일함). |
| `\uXXXX`                                             | UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호입니다. `XXXX`는 반드시 네 개의 16진수로 구성되어야 합니다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드임). |
| `\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자) | UTF-32로 표현한 유니코드 기호입니다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지합니다. 이 방법을 사용하면 긴 코드를 삽입할 수 있습니다. |

### 문자열의 길이

JS에서의 length는 다른 언어에서의 length()와 달리 메서드가 아닌 프로퍼티이다.

```javascript
let str = 'Hello';

alert(str.length); // 5
```



### 특정 글자에 접근하기

문자열 내 특정 위치인 pos에 있는 글자에 접근하려면 [pos]같이 대괄호를 이용하거나 str.charAt(pos)라는 메서드를 호출한다. 위치는 0부터 시작이다. 

```javascript
let str = 'Hello';

alert(str[0]); // H
alert(str.charAt(0)); // H

alert(str[str.length - 1]); // o
```

둘 중 charAt은 비교적 옛날 방식이며 요즘엔  []를 사용한다.

#### 반환할 글자가 없을 때 [], charAt()의 차이

- [] - undefined
- charAt(pos) - 빈 문자열

### 문자열의 불변성

문자열은 수정할 수 없다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

```javascript
let str = 'hi';

str[0] = 'H'; // Error: Cannot assign to read only property '0' of string 'hi'
alert(str[0]); // 동작하지 않는다.
```

이런 문제를 피하려면 **완전히 새로운 문자열을 하나 만든 다음 이 문자열을 str에 할당하면 된다.**

```javascript
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체함

alert( str ); // hi
```



## 대·소문자 변경하기

- 대문자로 변경 - toUpperCase()
- 소문자로 변경 - toLowerCase()



### 부분 문자열 찾기

`str.indexOf(substr, pos)` - 이 메서드는 문자열 str의 pos부터 시작해 substr이 어딨는지 찾아준다. 부분 문자열을 찾으면 위치를 반환, 찾지 못하면 -1을 반환한다. 반대로 문자열의 맨 끝부터 위치를 찾고 싶다면 `str.lastIndexOf()`를 사용하면 된다.

```javascript
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
alert( str.indexOf('widget') ); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함

alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

두 번째 매개변수 pos는 선택적 사용인데, 이를 명시하면 검색을 해당 위치에서부터 시작한다.

```javascript
let str = 'Widget with id';

alert(str.indexOf('id', 2)); // 12
```

이 외에 비교적 근래에 나온 메서드인 str.includes(substr, pos)는 true, false를 반환한다. 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.

또한 `startsWith()`, `endsWith()`메서드도 있는데 이는 메서드 이름 그래도 문자열이 특정 문자열로 시작하는지 또는 끝나는지의 여부를 확인할 때 사용한다.



### 부분 문자열 추출하기

자바스크립트엔 부분 문자열 추출과 관련된 메서드가 세가지 있다.

- substring
- substr
- slice

위 세개의 메서드를 하나씩 알아보자

* `str.slice(start [, end])`

  문자열의 `start`부터 `end`까지(`end`는 미포함)를 반환한다.

  ```javascript
  let str = "stringify"; alert(str.slice(0, 5) ); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함하지 않음) 
  alert(str.slice(0, 1) ); // 's', 0번째부터 1번째 위치까지(1번째 위치의 자는 포함하지 않음)
  ```

  두 번째 인수가 생략된 경우엔, 명시한 위치부터 문자열 끝까지를 반환한다.

* `str.substring(start, [, end])`

  start, end 사이에 있는 문자열을 반환한다.  slice와 유사하지만 start가 end보다 커도 괜찮다는데 차이가 있다. 

  ```javascript
  let str = "stringify";
  
  // 동일한 부분 문자열을 반환.
  alert( str.substring(2, 6) ); // "ring"
  alert( str.substring(6, 2) ); // "ring"
  
  // slice를 사용하면 결과가 다름
  alert( str.slice(2, 6) ); // "ring" (같음)
  alert( str.slice(6, 2) ); // "" (빈 문자열)
  ```

* `str.substr(start, [, length])`

  start에서 시작해 length개의 글자를 반환한다.

  substr은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서  substring, slice와 차이가 있다.

  ```javascript
  let str = "stringify";
  alert( str.substr(2, 4) ); // ring, 두 번째부터 글자 네 개
  ```

  첫번째 인수가 음수면 뒤에서부터 개수를 센다.

  ```javascript
  let str = "stringify";
  alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두 개
  ```

  

부분 문자열 추출과 관련된 메서드를 요약해보자.

| 메서드                  | 추출할 부분 문자열                    | 음수 허용 여부(인수)  |
| :---------------------- | :------------------------------------ | :-------------------- |
| `slice(start, end)`     | `start`부터 `end`까지(`end`는 미포함) | 음수 허용             |
| `substring(start, end)` | `start`와 `end` 사이                  | 음수는 `0`으로 취급함 |
| `substr(start, length)` | `start`부터 `length`개의 글자         | 음수 허용             |



### 문자열 비교하기

문자열을 비교할 땐 **알파벳 순서를 기준으로 글자끼리 비교가 이뤄진다.** 모든 문자열은 UTF-16으로 인코딩된다.



## 배열 - ⭐️⭐️

순서가 있는 컬렉션을 저장할 때 자료구조 중 하나인 배열을 사용할 수 있다.

### 배열 선언

```javascript
let arr = new Array();
let arr = [];
```

대부분은 2번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것이 가능하다.

```javascript
let fruits = ['사과', '오렌지', '자두'];
```

배열의 요소에 접근하려면 대괄호[]안에 순서를 나타내는 숫자인 인덱스를 넣어주어야 하는데 인덱스는 0부터 시작한다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두
```

또한 배열의 요소를 수정하거나 추가할 수도 있다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert( fruits[0] ); // 사과
alert( fruits[1] ); // 오렌지
alert( fruits[2] ); // 자두

fruits[2] = '배';
fruits[3] = '레몬';
```

length는 배열의 길이를 나타낸다.

```javascript
let fruits = ["사과", "오렌지", "자두"];

alert(fruits.length); // 3
```

배열의 자료형에는 제약이 없다.

```javascript
let arr = [ '사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); } ];
```

### pop·push와 shift·unshift

배열의 메서드를 알기전에 큐와 스택에 대해 간단히 알아보자.

큐는 배열을 사용해 만들 수 있는 대표적인 자료구조로 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용한다. 먼저 집어넣은 요소가 먼저 나오는 FIFO(First In First Out)구조이다. 큐에서 사용하는 주요 연산은 다음과 같다.

- push : 맨 끝에 요소를 추가한다.
- shift : 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다.

스택은 한쪽 끝에 요소를 더하거나 뺄 수 있게 해주는 자료구조이다. 가장 나중에 넣은 요소가 가장 먼저 나오는 LIFO(Last In First Out)구조이다. 스택에서 사용하는 주요 연산은 다음과 같다.

- push : 요소를 스택 끝에 집어넣는다.
- pop : 스택의 끝 요소를 추출한다.



배열의 끝 또는 앞에 무언가를 해주는 메서드는 다음과 같다.

- pop : 배열의 끝 요소를 제거하고 제거한 요소를 반환한다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert( fruits.pop() ); // 배열에서 "배"를 제거하고 제거된 요소를 띄움.

alert( fruits ); // 사과,오렌지
```

- push : 배열 끝에 요소를 추가한다.	 

```javascript
let fruits = ["사과", "오렌지"];

fruits.push("배");

alert( fruits ); // 사과,오렌지,배
```

- shift : 배열 앞 요소를 제거하고, 제거한 요소를 반환한다.

```javascript
let fruits = ["사과", "오렌지", "배"];

alert( fruits.shift() ); // 배열에서 "사과"를 제거하고 제거된 요소를 띄움.

alert( fruits ); // 오렌지,배
```

- unshift

```javascript
let fruits = ["오렌지", "배"];

fruits.unshift('사과');

alert( fruits ); // 사과,오렌지,배
```



### 배열의 내부 동작 원리

배열은 특별한 종류의 객체이다. 배열 arr의 요소를 `arr[0]`처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔다. 다만 배열은 키가 숫자라는 점만 다르다.

배열은 length라는 프로퍼티도 제공하지만 본질은 객체이다.

배열은 객체와 마찬가지로 참조를 통해 복사된다.

```javascript
let frutis = ['바나나'];

let arr = fruits; // 참조를 복사함

alert(arr === fruits); // true

arr.push("배");

alert(fruits); // 바나나, 배
```

자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높힌다. 이 방법 외에도 배열 관련 연산을 빠르게 해주는 최적화 기법은 다양하다.

하지만 배열을 순서가 있는 자료 컬렉션처럼 다루지 않고 일반 객체처럼 다루면 이러한 기법이 잘 동작하지 않는다.

```javascript
let fruits = []; // 빈 배열을 하나 생성

fruits[99999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만든다.

fruits.age = 25; // 임의의 이름을 사용해 프로퍼티를 만든다.
```

배열은 객체이기 때문에 에러는 발생하지 않지만 위처럼 코드를 작성하게 되면 JS엔진은 배열을 일반 객체로 인식해 최적화 기법을 적용하지 못하기 때문에 배열의 이점을 잃는다.

#### 그 외 잘못된 방법의 예

- arr.test = 5같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
- arr[0]과  arr[1000]만 추가하고 그 사이엔 아무런 요소도 없는 경우

- arr[1000], arr[999]같이 요소를 역순으로 추가하는 경우

> 배열은 순서가 있는 자료를 저장하는 용도로 만들어진 특수한 자료구조이다. 배열 내장 메서드들은 이런 용도에 맞게 만들어졌으며, JS엔진은 이런 특성을 고려하여 배열을 신중하게 조정하고 처리한다.
>
>   
>
> 배열을 사용할 땐 이런 목적에 맞게 사용해야 한다.



### 성능

push & pop은 빠르지만  shift & unshift는 느리다.

이는 shift, unshift가 배열 요소의 앞에서 무언가를 하기 때문인데 코드를 보며 이해해보자.

```javascript
let nums = [0,1,2,3];

nums.shift(); // 배열 맨 앞의 요소(0)를 뺀다.
```

위 코드를 실행하면 nums[0]의 값인 0이 사라지고 1,2,3만 남게 되는데 요소를 제거한 후에 제거 대상이 아닌 나머지 요소들의 인덱스 또한 줄어들기 때문에 이 과정을 또 수행해야 한다.

반면에 push, pop은 맨 끝에서 동작을 하기 때문에 인덱스의 값을 변경하는 추가 동작이 필요하지 않기 때문에 push & pop이 shift & unshift보다 빠른 것이다.



### 반복문

`for`문은 배열을 순회할 때 사용하는 가장 오래된 방법이다. 순회시 인덱스를 사용한다.

```javascript
for(let i = 0; i < arr.lengthl; i++) {
    alert(arr[i]); // 배열 순회
}
```

또 다른 방법으로  `for..of`가 있다. 현재 요소의 인덱스는 얻을 수는 없지만 값을 알 수 있다.

`for..in`도 사용할 수 있는데 이는 다음과 같은 특징을 가진다.

- `for..in`은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.

  : 브라우저나 기타 호스트 환경에서 쓰이는 객체에서는 유사 배열 객체가 있다. 유사 배열 객체에는 배열처럼 length 프로퍼티도 있고 요소마다 인덱스도 붙어있다. 그런데 여기에 더해 유사배열에는 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. `for..in`을 사용하면 이 모든 것을 순회한다.

- `for..in`은 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 느리다.



### length 프로퍼티

배열에 무언가 조작을 하면 length프로퍼티가 자동으로 갱신된다. length 프로퍼티는 배열 내 요소의 개수가 아닌 가장 큰 인덱스에 1을 더한 값이다.

따라서 배열에 요소가 하나지만 인덱스가 123 등 큰 정수라면  length는 `123 + 1 = 124`가 된다.

```javascript
let fruits = [];
fruits[123] = '사과';
alert(fruits.length); // 124
```

배열을 이렇게 사용하지는 말자.

length는 수정이 가능하다. length를 수동으로 증가시키면 아무일도 일어나지 않지만 감소하면 배열이 그만큼 잘려나간다. 잘려나간 요소는 되돌릴 수 없다.

```javascript
let arr = [1, 2, 3, 4, 5];

arr.length = 2;
alert(arr); // 1, 2

arr.length = 5;
alert(arr); // undefined : 삭제된 기존 요소들이 복구되지 않는다.
```

이런 특징을 이용해  `arr.length = 0`을 사용하면 배열이 쉽게 비워진다.



### new Array()

`new Array()`문법을 사용해도 배열을 만들수도 있다.

```javascript
let arr = new Array("사과", "배", "기타");
```

대괄호를 이용하면 더 짧은 문법으로 배열을 만들수 있기 때문에 잘 사용하지는 않는다.

다루기 까다롭기도 하다.



### 다차원 배열

다차원 배열은 행열을 저장하는 용도로 쓰인다.

```javascript
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
];

alert(matrix[1][1]); // 5
```

​	

### toString

배열에는 toString 메서드가 구현되어 있다. 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환된다.

- 예시

```javascript
let arr = [1, 2, 3];

alert(arr); // 1, 2, 3
alert(String(arr) === '1,2,3'); // true
```





## 배열과 메서드 - ⭐️

배열은 다양한 메서드를 제공한다. 

### 요소 추가 / 제거 메서드

push(), pop(), shift(), unshift()외에 추가/제거와 관련된 메서드를 알아보자.

#### splice()

배열에서 요소를 하나만 지우고 싶다면 어떻게 할까 먼저 배운대로라면 프로퍼티인 delete를 사용하는 방법이 있을 것이다.

```javascript
let arr = ["I", "go", "home"];

delete arr[1];

alert(arr); // "I", , "home";

alert(arr.length); // 3
```

예상과 다르게 arr[1]이라는 키의 해당하는 값을 삭제했을 뿐 배열 전체의 요소는 여전히 3개다.

이럴때 splice()를 사용하면 요소 추가, 교체, 삭제가 가능하다.

- 문법

```javascript
arr.splice(index[, deleteCount, elem1, ... elemN]);
```

- 삭제

```javascript
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // 인덱스 1부터 요소 한 개를 제거

alert( arr ); // ["I", "JavaScript"]
```

인덱스 1이 가리키는 요소부터 시작해서 요소 1개를 지웠다.

요소 3개를 지우고, 그 자리를 다른 요소 두개로 채워보자.

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체.
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

splice는 삭제된 요소로 구성된 배열을 반환한다. 

```javascript
let arr = ["I", "study", "JavaScript", "right", "now"];

let removed = arr.splice(0, 2);

alert(removed); // "I", "study" 삭제된 요소로 배열 구성
```

splice 메서드의 deleteCount를 0으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.

```javascript
let arr = ["I", "study", "JavaScript"];

// 인덱스 2부터 0개의 요소를 삭제. 그 후, "complex", "language" 추가
arr.splice(2, 0, "complex", "language");
alert(arr); //"I", "study", "complex", "language", "JavaScript"
```

배열 관련 메서드엔 음수 인덱스를 사용할 수 있다. 이때 마이너스 부호의 앞의 숫자는 배열의 끝에서 부터 센 요소의 위치이다.

```javascript
let arr = [1, 2, 5];

// 인덱스 -1부터 (배열 끝에서부터 첫 번째 요소)
// 0개의 요소를 삭제하고
// 3과 4를 추가합니다.
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```

#### slice()

arr.slice()는 splice()와 유사하지만 훨씬 간단하다.

- 문법

```javascript
arr.slice([start], [end]);
```

이 메서드는 start인덱스부터 end 인덱스까지의 요소를 복사한 새로운 배열을 만든다.

arr.slice()는 문자열 메서드 str.slice()와 유사하게 동작한다. 하지만 서브 문자열 대신 서브 배열을 반환한다는 것이 그 차이다.

- 예시

```javascript
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))

alert( arr.slice(-2) ); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사)
```

arr.slice는 인수를 하나도 남기지 않고 호출하여 arr의 복사본을 만들 수 있다. 이런 방식은 기존의 배열을 건드리지 않으면서 배열을 조작해 새로운 배열을 만들고자 할 때 자주 사용된다. 



#### concat

arr.concat은 기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용한다.

```javascript
arr.concat(arg1, arg2, ... argN);
```

인수엔 배열이나 값이 올 수있는데 인수 개수에는 제한이 없다.

```javascript
let arr = [1, 2];

// arr의 요소 모두와 [3,4]의 요소 모두를 한데 모은 새로운 배열이 만들어짐
alert( arr.concat([3, 4]) ); // 1,2,3,4

// arr의 요소 모두와 [3,4]의 요소 모두, [5,6]의 요소 모두를 모은 새로운 배열이 만들어짐
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// arr의 요소 모두와 [3,4]의 요소 모두, 5와 6을 한데 모은 새로운 배열이 만들어짐
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

concat은 제공받은 배열의 요소를 복사해 활용한다. 객체가 인자로 넘어오면 객체는 분해되지 않고 통으로 복사되어 더해진다. 하지만 유사 배열 객체에 프로퍼티 Symbol.isConcatSpredable이 있으면 배열처럼 취급한다.

```javascript
let arr = [1, 2];

let arrayLike = {
    0: "something",
    length: 1
};

alert(arr.concat(arrayLike)); // 1, 2, [object Object]

arrayLike = {
    0: "something",
    1: "else"
   	[Symbol.isConcatSpreadable]: true,
    length: 1
};

alert(arr.concat(arrayLike)); // 1, 2, something, else
```



#### forEach 반복작업

- 문법

```javascript
arr.forEach(function(item, index, array) {
    // 요소에 무언가를 할 수 있다.
});
```

- 예제

```javascript
["Bilbo", "Gandalf", "Nazgul"].forEach(alert); // 요소를 하나씩 alert

// 조금 더 정교하게 사용

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```



### 배열 탐색

배열 내 탐색 메서드에 대해 알아보자

#### indexOf, lastIndexOf, includes

* `arr.indexOf(item, from)`는 인덱스 `from`부터 시작해 `item(요소)`을 찾는다. 요소를 발견하면 해당 요소의 인덱스를 반환하고, 발견하지 못했으면 `-1`을 반환.

* `arr.lastIndexOf(item, from)`는 위 메서드와 동일한 기능을 하는데, 검색을 끝에서부터 시작한다는 점만 다르다.

* `arr.includes(item, from)`는 인덱스 `from`부터 시작해 `item`이 있는지를 검색하는데, 해당하는 요소를 발견하면 `true`를 반환.

  * 예제

  ```javascript
  let arr = [1, 0, false];
  
  alert( arr.indexOf(0) ); // 1
  alert( arr.indexOf(false) ); // 2
  alert( arr.indexOf(null) ); // -1
  
  alert( arr.includes(1) ); // true
  ```

  위 메서드들은 요소를 찾을때 ===를 사용한다. 따라서 0, false를 정확하게 구분한다(NaN도 제대로 처리한다). 요소가 배열 내부에 위치하는지만 확인하고 싶다면 includes를 사용하는 것이 좋다.



#### find, findIndex

객체로 이루어진 배열이 있다고 가정할 때 특정 조건에 부합하는 객체를 배열 내에서 어떻게 찾을 수 있을까?

- 문법

```javascript
let result = arr.find(function(item, index, array) {
   // true가 반환되면 반환이 멈추고, 해당 요소를 반환
   // 조건에 해당하는 요소가 없으면 undefined 반환
});
```

요소 전체를 대상으로 함수가 순차적으로 호출된다.

- item - 함수를 호출할 요소
- index - 요소의 인덱스
- array - 배열 자기 자신

함수가 참을 반환하면 탐색은 중단되며, 해당 요소가 반환된다. 원하는 요소를 찾지 못하면 undefind를 반환한다.



#### filter

find 메서드는 함수의 반환 값을 true로 만드는 단 하나의 요소를 찾는다. 조건을 충족하는 요소가 여러개면 arr.filter(fn)를 사용하면 된다.

- 문법

```javascript
let results = arr.filter(function(item, index, array) {
   // 조건을 충족하는 요소는 results에 순차적으로 더해진다. 모든 요소가 조건을 만족하지 못한다면 빈 배열이 반환된다.
});
```

- 예시

```javascript
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 앞쪽 사용자 두 명을 반환.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```



### 배열을 변형하는 메서드

배열을 변형시키거나 요소를 재정렬해주는 메서드에 대해 알아보자.

#### map

arr.map()은 유용성과 사용빈도가 높다.

map은 배열 요소 전체를 대상으로 함수를 호출하고 함수 호출 결과를 배열로 반환해준다.

- 문법

```javascript
let result = arr.map(function(item, index, array) {
   // 요소 대신 새로운 값을 반환 
});
```

- 예시

```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert.(lengths); // 5, 7, 6
```



#### sort(fn)

arr.sort(fn)은 배열의 요소를 정렬해준다. 배열 자체가 변경된다.

메서드를 호출하면 재정렬 된 배열이 반환되는데, arr자체가 수정되었기 때문에 반환 값은 잘 사용하지 않는다.

- 예시

```javascript
let arr = [1, 2, 15];

arr.sort();

alert(arr); // 1, 15, 2
```

요소는 문자열로 취급되어 재정렬된다. 따라서 `1, 15, 2`라는 엉뚱한 값을 얻을 수 있는 것이다. 새로운 정렬 기준을 만들어내려면 arr.sort()의 인자로 compare와 같이 a, b를 반드시 비교하고 반환값도 있어야 하는 함수를 넣어야 한다.

```javascript
function compare(a, b) {
    // return값이 굳이 1, 0, -1일 필요 없이 2, 1, 0이 되어도 상관은 없다. 큰지 작은지 같은지를 알려주기만 하면 된다.
    if (a > b) return 1;
    if (a == b) return = 0;
    if (a < b) return -1;
}

let arr = [1, 2, 15];

arr.sort(compare);

alert(arr); // 1, 2, 15
```

사실 `arr`엔 숫자, 문자열, 객체 등이 들어갈 수 있다. 알 수 없는 무언가로 구성된 집합이

된다. 이런 비동질적인 집합을 정렬하기 위해서는 기준이 필요하다. 이때 정렬 기준을 정의해주는 함수(ordering funciton, 정렬함수)가 필요하다.

arr.sort(fn)은 포괄적인 정렬 알고리즘을 이용해 구현되었다. 대게 퀵소트로 정렬되어있다.

- 정렬 함수는 어떤 숫자든 반환할 수 있다. 반환값엔 제약이 없기 때문에 조금 더 간결하게 정렬함수를 정의할 수 있다.

  ```javascript
  let arr = [1, 15, 2];
  
  arr.sort(function(a, b) { return a - b; });
  
  alert(arr); // 1, 2, 15
  ```

- 화살표 함수를 사용하자. 더 깔끔하게 만들 수 있다.

  ```javascript
  arr.sort((a, b) => a -b );
  ```

- 문자열에는 localeCompare를 사용하자. 유니코드를 기준으로 글자를 비교한다. 발음체계가 붙은 문자가 있는 언어에도 대응하려면 localeCompare를 사용하여 구분하는 것이 좋다.



#### reverse

arr.reverse는 배열의 요소를 역순으로 정렬해준다.

- 예시

```javascript
let arr = [1, 2, 3, 4, 5];

arr.reverse()

alert(arr); // 5, 4, 3, 2, 1
```

반환 값은 재정렬된 배열이다.



#### split, join

str.split(delim)를 사용하면 구분자(delimeter)로 문자열을 쪼개준다.

```javascript
let names = "Bilbo, Gandalf, Nazgul";

let arr = names.split(", ");
for(let name of arr) {
    alert(`${name}에게 보내는 메시지`);
}
```

join은 이와 반대로 접착제처럼 배열을 문자열로 바꿔준다.

```javascript
let arr = ["Bilbo", "Gandalf", "Nazgul"];

let str = arr.join(';');

alert(str); // Bilbo;Gandalf;Nazgul
```

#### reduce, reduceRight

`forEach, for, for..of`를 사용하면 배열 내 요소를 대상으로 반복 작업을 할 수 있다.

각 요소를 돌면서 반복작업을 수행하고 작업 결과물을 새로운 배열 형태로 얻으려면 map을 사용하면 된다.

arr.reduce, arr.reduceRight은 위와 유사한 작업을 한다. 

- 문법

```javascript
let value = arr.reduce(function(accumulator, item, index, array) {
   // ...
}, [initial]);
```

인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례대로 적용되며 적용 결과는 다음 함수 호출 시 사용된다.

인수의 설명은 다음과 같다.

- `accumulator` - 이전 함수 호출의 결과, initial은 함수 호출 시 사용되는 초기값

- `item` - 현재 배열 요소
- `index` - 요소의 위치
- `array` - 배열

 이전 함수 호출 결과는 다음 함수를 호출할 때 첫번째 인수로 사용된다.

첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되는 누산기라고 생각하면 된다. 마지막 함수까지 호출되면 이 값은 reduce의 반환 값이 된다.

* 예시

```jsx
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result);
```

reduce에 전달한 함수는 오직 인수 두 개만 받고 있다. 대게 이렇게 한다.

* 순서

1. 함수 최초 호출 시, reduce의 마지막 인수인 0이 sum에 할당된다. current에는 배열의 첫번째 요소 1이 할당된다. 함수의 결과는 1.
2. 두 번째 호출시 1 + 2가 되어 함수의 결과는 3.
3. 세 번째 호출시 3 + 3이 되어 함수의 결과는 6. 이러한 과정이 반복된다.

초기값을 생략할 수도 있는데 이럴때는 배열의 첫번째 요소가 초기값이 되고 두번째 요소부터 함수를 호출한다.(배열이 비어있는 상태면 오류가 발생한다) 초기값은 명시할 것을 튜토리얼에서는 권장한다.

### Array.isArray로 배열여부 알아내기

JS에서 배열은 독립된 자로형으로 취급되지 않고 객체형에 속한다(엄밀히 말하면 좀 특별한)

따라서 typeof로는 일반 객체와 배열을 구별할 수 없다. **배열인지 아닌지를 감별해내는 메서드가 제목에서의 Array.isArray(value)이다. value가 배열이면 true를 아니면 false를 반환한다.**

```jsx
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

### 배열 메서드와 thisArg

함수를 호출하는 대부분의 배열 메서드(sort 제외.)는 thisArg라는 매개변수를 옵션으로 받을 수 있다. 자주 사용되지는 않지만 알아보자.

* 활용

```jsx
arr.find(func, thisArg); 
arr.filter(func, thisArg);
arr.map(func, thisArg);

//... 

//thisArg는 선택적으로 사용할 수 있는 마지막 인수이다.
```

thisArg는 func의 this가 된다.

아래 예시를 보자

```jsx
let army = {
	minAge: 18, 
	maxAge: 27,
	canJoin(user) {
		return user.age >= this.minAge && user.age <= this.maxAge;
	}
};

let users = [
	{age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

let soldiers = users.filter(army.canJoin, army);
alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

## 요약

* 요소를 더하거나 지우기
  * `push(...items)` – 맨 끝에 요소 추가하기
  * `pop()` – 맨 끝 요소 추출하기
  * `shift()` – 첫 요소 추출하기
  * `unshift(...items)` – 맨 앞에 요소 추가하기
  * `splice(pos, deleteCount, ...items)` – `pos`부터 `deleteCount`개의 요소를 지우고, `items` 추가하기
  * `slice(start, end)` – `start`부터 `end` 바로 앞까지의 요소를 복사해 새로운 배열을 만듦
  * `concat(...items)` – 배열의 모든 요소를 복사하고 `items`를 추가해 새로운 배열을 만든 후 이를 반환함. `items`가 배열이면 이 배열의 인수를 기존 배열에 더해줌
* 원하는 요소 찾기
  * `indexOf/lastIndexOf(item, pos)` – `pos`부터 원하는 `item`을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면 `1`을 반환함
  * `includes(value)` – 배열에 `value`가 있으면 `true`를, 그렇지 않으면 `false`를 반환함
  * `find/filter(func)` – `func`의 반환 값을 `true`로 만드는 첫 번째/전체 요소를 반환함
  * `findIndex`는 `find`와 유사함. 다만 요소 대신 인덱스를 반환함
* 배열 전체 순회하기
  * `forEach(func)` – 모든 요소에 `func`을 호출함. 결과는 반환되지 않음
* 배열 변형하기
  * `map(func)` – 모든 요소에 `func`을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦
  * `sort(func)` – 배열을 정렬하고 정렬된 배열을 반환함
  * `reverse()` – 배열을 뒤집어 반환함
  * `split/join` – 문자열을 배열로, 배열을 문자열로 변환함
  * `reduce(func, initial)` – 요소를 차례로 돌면서 `func`을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨
* 기타
  * `Array.isArray(arr)` – `arr`이 배열인지 여부를 판단함



## iterable 객체 - ⭐️

반복 가능한(Iterable)객체는 배열을 일반화한 객체이다. 이터러블이라는 개념을 사용하면 어떤 객체든 `for..of`반복문을 적용할 수 있다. 

배열은 대표적인 이터러블입니다. 배열 외에도 다수의 내장 객체가 반복 가능하다. 문자열 역시 이터러블의 예이다.

배열이 아닌 객체가 있는데 이 객체가 어던 것들의 컬렉션을 나타내고 있는 경우  `for..of` 문법을 적용할 수만 있다면 컬렉션을 순회하는데 유용할 것이다.



### Symbol.iterator

직접 이터러블 객체를 만들어직접 이터러블 객체를 만들어 이터러블이라는 개념을 이해해보자

`for..of`를 적용하기에 적합해 보이는 배열이 아닌 객체를 만들어본다.

예시의 객체 `range`는 숫자 간격을 나타내고 있다.

```javascript
let range = {
  from: 1,
  to: 5
};

// 아래와 같이 for..of가 동작할 수 있도록 하는 게 목표
// for(let num of range) ... num=1,2,3,4,5
```

`range`를 이터러블로 만들려면(`for..of`가 동작하도록 하려면) 객체에 `Symbol.iterator`(특수 내장 심볼)라는 메서드를 추가해 아래와 같은 일이 벌어지도록 해야 한다.

1. `for..of`가 시작되자마자 `for..of`는 `Symbol.iterator`를 호출한다(`Symbol.iterator`가 없으면 에러가 발생한다). `Symbol.iterator`는 반ㅂ드시 *이터레이터(iterator, 메서드 `next`가 있는 객체)* 를 반환해야 한다.
2. 이후 `for..of`는 *반환된 객체(이터레이터)만*을 대상으로 동작한다.
3. `for..of`에 다음 값이 필요하면, `for..of`는 이터레이터의 `next()`메서드를 호출한다.
4. `next()`의 반환 값은 `{done: Boolean, value: any}`와 같은 형태이어야 한다. `done=true`는 반복이 종료되었음을 의미한다. `done=false`일땐 `value`에 다음 값이 저장된다.

`range`를 반복 가능한 객체로 만들어주는 코드는 다음과 같다.

```javascript
let range = {
  from: 1,
  to: 5
};

// 1. for..of 최초 호출 시, Symbol.iterator가 호출된다.
range[Symbol.iterator] = function() {

  // Symbol.iterator는 이터레이터 객체를 반환.
  // 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 정해진다.
  return {
    current: this.from,
    last: this.to,

    // 3. for..of 반복문에 의해 반복마다 next()가 호출된다.
    next() {
      // 4. next()는 값을 객체 {done:.., value :...}형태로 반환해야 한다.
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// 이제 의도한 대로 동작한다
for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이터러블 객체의 핵심은 '관심사의 분리(Separation of concern, SoC)'에 있다.

* `range`엔 메서드 `next()`가 없다.
* 대신 `range[Symbol.iterator]()`를 호출해서 만든 ‘이터레이터’ 객체와 이 객체의 메서드 `next()`에서 반복에 사용될 값을 만들어낸다.

이렇게 하면 이터레이터 객체와 반복 대상인 객체를 분리할 수 있다.

이터레이터 객체와 반복 대상 객체를 합쳐서 `range` 자체를 이터레이터로 만들면 코드가 더 간단해진다.

```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

이제 `range[Symbol.iterator]()`가 객체 `range` 자체를 반환한다. 반환된 객체엔 필수 메서드인 `next()`가 있고 `this.current`에 반복이 얼마나 진행되었는지를 나타내는 값도 저장되어 있다.

단점은 두 개의 `for..of` 반복문을 하나의 객체에 동시에 사용할 수 없다는 점이다. 이터레이터(객체 자신)가 하나뿐이어서 두 반복문이 반복 상태를 공유하기 때문인데, 동시에 두 개의 `for..of`를 사용하는 것은 비동기 처리에서도 흔한 케이스는 아니다.

**무한개의 이터레이터**

무수히 많은 이터레이터도 가능하다. `range`에서 `range.to`에 `Infinity`를 할당하면 `range`가 무한대가 된다. 무수히 많은 의사 난수(pseudorandom numbers)를 생성하는 이터러블 객체를 만드는 것도 가능하다. 이 방법이 유용하게 쓰이는 경우도 있다.

`next`엔 제약사항이 없어서 `next`가 값을 계속 반환하는 것은 정상적인 동작이다.

물론 위와 같은 이터러블에 `for..of` 반복문을 사용하면 끝이 없다. 그렇다 하더라도 `break`를 사용하면 언제든지 반복을 멈출 수 있다.

### 문자열은 이터러블

배열과 문자열은 가장 광범위하게 쓰이는 내장 이터러블이다.

`for..of`는 문자열의 각 글자를 순회한다.

```javascript
for (let char of "test") {
  // 글자 하나당 한 번 실행됩니다(4회 호출).
  alert( char ); // t, e, s, t가 차례대로 출력됨
}
```

서로게이트 쌍(surrogate pair)에도 잘 동작한다.

```javascript
let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳와 😂가 차례대로 출력됨
}
```

## 이터레이터를 명시적으로 호출하기

이터레이터를 어떻게 명시적으로 사용할 수 있는지 살펴보면서 좀 더 깊게 이해해보자.

`for..of`를 사용했을 때와 동일한 방법으로 문자열을 순회할 건데, 이번엔 직접 호출을 통해서 순회해보자. 다음 코드는 문자열 이터레이터를 만들고, 여기서 값을 ‘수동으로’ 가져온다.

```javascript
let str = "Hello";

// for..of를 사용한 것과 동일한 작업을 한다.
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자가 하나씩 출력된다.
}
```

이터레이터를 명시적으로 호출하는 경우는 거의 없는데, 이 방법을 사용하면 `for..of`를 사용하는 것보다 반복 과정을 더 잘 통제할 수 있다는 장점이 있다. 반복을 시작했다가 잠시 멈춰 다른 작업을 하다가 다시 반복을 시작하는 것과 같이 반복 과정을 여러 개로 쪼개는 것이 가능하다.

### 이터러블과 유사 배열

비슷해 보이지만 아주 다른 용어 두 가지가 있다. 헷갈리지 않으려면 두 용어를 잘 이해하고 있어야 한다.

* *이터러블(iterable)* 은 위에서 설명한 바와 같이 메서드 `Symbol.iterator`가 구현된 객체이다.
* *유사 배열(array-like)* 은 인덱스와 `length` 프로퍼티가 있어서 배열처럼 보이는 객체이다.

브라우저 등의 호스트 환경에서 자바스크립트를 사용해 문제를 해결할 때 이터러블 객체나 유사 배열 객체 혹은 둘 다인 객체를 만날 수 있다.

이터러블 객체(`for..of` 를 사용할 수 있음)이면서 유사배열 객체(숫자 인덱스와 `length` 프로퍼티가 있음)인 문자열이 대표적인 예시이다.

이터러블 객체라고 해서 유사 배열 객체는 아니다. 유사 배열 객체라고 해서 이터러블 객체인 것도 아니다.

위 예시의 `range`는 이터러블 객체이긴 하지만 인덱스도 없고 `length` 프로퍼티도 없으므로 유사 배열 객체가 아니다.

아래 예시의 객체는 유사 배열 객체이긴 하지만 이터러블 객체가 아니다.

```javascript
let arrayLike = { // 인덱스와 length프로퍼티가 있음 => 유사 배열
  0: "Hello",
  1: "World",
  length: 2
};

// Symbol.iterator가 없으므로 에러 발생
for (let item of arrayLike) {}
```

이터러블과 유사 배열은 대개 *배열이 아니기 때문에* `push`, `pop` 등의 메서드를 지원하지 않는다. 이터러블과 유사 배열을 배열처럼 다루고 싶을 때 이런 특징은 불편함을 초래한다. `range`에 배열 메서드를 사용해 무언가를 하고 싶을 때처럼 말이다. 어떻게 하면 이터러블과 유사 배열에 배열 메서드를 적용할 수 있을까

### Array.from

범용 메서드 Array.from는 이터러블이나 유사 배열을 받아 ‘진짜’ `Array`를 만들어줍니다. 이 과정을 거치면 이터러블이나 유사 배열에 배열 메서드를 사용할 수 있다.

예시:

```javascript
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (메서드가 제대로 동작.)
```

`(*)`로 표시한 줄에 있는 `Array.from`은 객체를 받아 이터러블이나 유사 배열인지 조사한다. 넘겨 받은 인수가 이터러블이나 유사 배열인 경우, 새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열로 복사한다.

- 이터러블을 사용한 예시.

```javascript
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정.
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (배열-문자열 형 변환이 제대로 동작한다.)
```

`Array.from`엔 ‘매핑(mapping)’ 함수를 선택적으로 넘겨줄 수 있다.

```javascript
Array.from(obj[, mapFn, thisArg])
```

`mapFn`을 두 번째 인수로 넘겨주면 새로운 배열에 `obj`의 요소를 추가하기 전에 각 요소를 대상으로 `mapFn`을 적용할 수 있다. 새로운 배열엔 `mapFn`을 적용하고 반환된 값이 추가된다. 세 번째 인수 `thisArg`는 각 요소의 `this`를 지정할 수 있도록 해준다.

예시:

```javascript
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정.

// 각 숫자를 제곱
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```

아래 예시에선 `Array.from`를 사용해 문자열을 배열로 만들어보았습니다.

```javascript
let str = '𝒳😂';

// str를 분해해 글자가 담긴 배열로 만듦
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```

`Array.from`은 `str.split`과 달리, 문자열 자체가 가진 이터러블 속성을 이용해 동작한다. 따라서 `for..of`처럼 서로게이트 쌍에도 제대로 적용된다.

위 예시는 기술적으로 아래 예시와 동일하게 동작한다고 보면 된다.

```javascript
let str = '𝒳😂';

let chars = []; // Array.from 내부에선 아래와 동일한 반복문이 돌아감.
for (let char of str) {
  chars.push(char);
}

alert(chars);
```

`Array.from`을 사용한 예시가 더 짧다.

`Array.from`을 사용하면 서로게이트 쌍을 처리할 수 있는 `slice`를 직접 구현할 수도 있다.

```javascript
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 내장 순수 메서드는 서로게이트 쌍을 지원하지 않습니다.
alert( str.slice(1, 3) ); // 쓰레깃값 출력 (영역이 다른 특수 값)
```

### 요약

`for..of`을 사용할 수 있는 객체를 *이터러블*이라고 부른다.

* 이터러블엔 메서드

  ```javascript
  Symbol.iterator
  ```

  가 반드시 구현되어 있어야 한다.

  * `obj[Symbol.iterator]`의 결과는 *이터레이터*라고 부른다. 이터레이터는 이어지는 반복 과정을 처리한다.
  * 이터레이터엔 객체 `{done: Boolean, value: any}`을 반환하는 메서드 `next()`가 반드시 구현되어 있어야 한다. 여기서 `done:true`은 반복이 끝났음을 의미하고 그렇지 않은 경우엔 `value`가 다음 값이 된다.

* 메서드 `Symbol.iterator`는 `for..of`에 의해 자동으로 호출되는데, 개발자가 명시적으로 호출하는 것도 가능하다.

* 문자열이나 배열 같은 내장 이터러블에도 `Symbol.iterator`가 구현되어 있다.

* 문자열 이터레이터는 서로게이트 쌍을 지원한다.

인덱스와 `length` 프로퍼티가 있는 객체는 *유사 배열*이라 불린다. 유사 배열 객체엔 다양한 프로퍼티와 메서드가 있을 수 있는데 배열 내장 메서드는 없다.

명세서를 보면 대부분의 메서드는 ‘진짜’ 배열이 아닌 이터러블이나 유사 배열을 대상으로 동작한다고 쓰여 있는걸 볼 수 있다. 이 방법이 더 추상적이기 때문이다.

`Array.from(obj[, mapFn, thisArg])`을 사용하면 이터러블이나 유사 배열인 `obj`를 진짜 `Array`로 만들 수 있다. 이렇게 하면 `obj`에도 배열 메서드를 사용할 수 있다. 선택 인수 `mapFn`와 `thisArg`는 각 요소에 함수를 적용할 수 있게 해준다.



## 맵과 셋 - ⭐️

현실 세계를 반영하기엔 객체, 배열로는 부족하다. 따라서 맵과 셋 자료형이 등장하게 되었다.



### 맵

Map은 키가 있는 데이터를 저장한다는 점에서 객체와 비슷하다. 맵은 키에 다양한 자료형을 허용한다는 점에서 차이가 있다.

맵에는 다음과 같은 프로퍼티가 있다.

- new Map() - 맵을 만든다.
- map.set(key, value) - key를 이용해 value를 저장한다.
- map.get(key) - key에 해당하는 값을 반환한다. 없을 시 undefined
- map.has(key) - key가 존재하면 true, 없으면 false
- map.delete(key) - key에 해당하는 값을 삭제한다.
- map.clear() - 맵안의 모든 요소를 제거한다.
- map.size - 요소의 개수를 반환한다.



```javascript
let map = new Map();

map.set('1,', 'str1');
map.set(1, 'num1');
map.set(true, 'bool1');

alert(map.get(1)); // num1
alert(map.get('1')); // str1
alert(map.get(true)); // bool1

alert(map.size); // 3
```

맵은 객체와 달리 키를 문자형으로 반환하지 않는다. 키엔 자료형 제약이 없다.

**맵은 키로 객체를 허용한다.**

- 예시

```javascript
let john = { name: "John" };

// 고객의 가게 방문 횟수를 세본다고 가정.
let visitsCountMap = new Map();

// john을 맵의 키로 사용
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
```

객체를 키로 사용할 수 있다는 점은 맵의 가장 중요한 기능 중 하나이다. 객체에는 문자열 키를 사용할 수 있다. 하지만 객체 키는 사용할 수 없다. 객체형 키를 객체에 써보자.

```javascript
let john = { name: "John" };

let visitsCountObj = {}; // 객체 생성

visitsCountObj[john] = 123; // 객체 체  john을 키로 해서 객체에 값 123을 저장 해보자

// 원하는 값을 얻으려면 아래와 같이 키가 들어갈 자리에 object Object를 써줘야한다.
alert(visitsCountObj["object Object"]); // 123
```

`visitsCountObj`는 객체이기 때문에 모든 키를 문자형으로 변환시킵니다. 이 과정에서 `john`은 문자형으로 변환되어 `"[object Object]"`가 된다.



### 맵의 요소에 반복 작업하기

다음 세가지 메서드를 사용해 맵의 각 요소에 반복 작업을 할 수 있다.

* `map.keys()` – 각 요소의 키를 모은 반복 가능한(iterable, 이터러블) 객체를 반환.
* `map.values()` – 각 요소의 값을 모은 이터러블 객체를 반환.
* `map.entries()` – 요소의 `[키, 값]`을 한 쌍으로 하는 이터러블 객체를 반환. 이 이터러블 객체는 `for..of`반복문의 기초로 쓰인다.

```javascript
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 키(vegetable)를 대상으로 순회
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 값(amount)을 대상으로 순회
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// [키, 값] 쌍을 대상으로 순회
for (let entry of recipeMap) { // recipeMap.entries()와 동일
  alert(entry); // cucumber,500 ...
}
```

> 맵은 삽입 순서를 기억한다. 값이 삽입된 순서대로 순회를 실시한다.



여기에 더하여 맵은 배열과 유사하게 내장 메서드 forEach도 지원한다.

```javascript
// 각 (키, 값) 쌍을 대상으로 함수를 실행
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 ...
});
```



### Object.entries: 객체를 맵으로 바꾸기

각 요소가 키-값 쌍인 배열이나 이터러블 객체를 초기화 용도로 `맵`에 전달해 새로운 `맵`을 만들 수 있다.

```javascript
// 각 요소가 [키, 값] 쌍인 배열
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
```

평범한 객체를 가지고 `맵`을 만들고 싶다면 내장 메서드 Object.entries(obj)를 활용해야 한다. 이 메서드는 객체의 키-값 쌍을 요소(`[key, value]`)로 가지는 배열을 반환한다

- 예시

```javascript
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
```

`Object.entries`를 사용해 객체 `obj`를 배열 `[ ["name","John"], ["age", 30] ]`로 바꾸고, 이 배열을 이용해 새로운 `맵`을 만들어보았다.

### Object.fromEntries: 맵을 객체로 바꾸기

방금까진 `Object.entries(obj)`를 사용해 평범한 객체를 `맵`으로 바꾸는 방법에 대해 알아보았다.

이젠 이 반대인 맵을 객체로 바꾸는 방법은 `Object.fromEntries`를 사용하면 가능하다. 이 메서드는 각 요소가 키 : 값 쌍인 배열을 객체로 바꿔준다.

```javascript
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

`Object.fromEntries`를 사용해 `맵`을 객체로 바꿔보자.

자료가 `맵`에 저장되어있는데, 서드파티 코드에서 자료를 객체형태로 넘겨받길 원할 때 이 방법을 사용할 수 있다.

예시:

```javascript
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // 맵을 일반 객체로 변환 (*)

// 맵이 객체가 되었다
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

`map.entries()`를 호출하면 맵의 `[키, 값]`을 요소로 가지는 이터러블을 반환한다. `Object.fromEntries`를 사용하기 위해 딱 맞는 형태이다.

`(*)`로 표시한 줄을 좀 더 짧게 줄이는 것도 가능하다.

```javascript
let obj = Object.fromEntries(map); // .entries()를 생략함
```

`Object.fromEntries`는 인수로 이터러블 객체를 받기 때문에 짧게 줄인 코드도 이전 코드와 동일하게 동작한다. 꼭 배열을 전달해줄 필요는 없다. 그리고 `map`에서의 일반적인 반복은 `map.entries()`를 사용했을 때와 같은 키-값 쌍을 반환하기 때문에 `map`과 동일한 키-값을 가진 일반 객체를 얻게 된다.

### 셋

`셋(Set)`은 중복을 허용하지 않는 값을 모아놓은 특별한 컬렉션이다. 셋에 키가 없는 값이 저장된다.

주요 메서드는 다음과 같다.

* `new Set(iterable)` – 셋을 만든다. `이터러블` 객체를 전달받으면(대개 배열을 전달받음) 그 안의 값을 복사해 셋에 넣는다.
* `set.add(value)` – 값을 추가하고 셋 자신을 반환.
* `set.delete(value)` – 값을 제거. 호출 시점에 셋 내에 값이 있어서 제거에 성공하면 `true`, 아니면 `false`를 반환.
* `set.has(value)` – 셋 내에 값이 존재하면 `true`, 아니면 `false`를 반환.
* `set.clear()` – 셋을 비운다.
* `set.size` – 셋에 몇 개의 값이 있는지 센다.

셋 내에 동일한 값(value)이 있다면 `set.add(value)`을 아무리 많이 호출하더라도 아무런 반응이 없다. 셋 내의 값에 중복이 없는 이유가 바로 이 때문이다.

방문자 방명록을 만든다고 가정해 보자. 한 방문자가 여러 번 방문해도 방문자를 중복해서 기록하지 않겠다고 결정 내린 상황이다. 즉, 한 방문자는 단 한 번만 기록되어야 한다.

이때 적합한 자료구조가 바로 `셋`이다.

```javascript
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// 어떤 고객(john, mary)은 여러 번 방문할 수 있다.
set.add(john);
set.add(pete);
set.add(mary);
set.add(john); // 중복
set.add(mary); // 중복

// 셋에는 유일무이한 값만 저장된다.
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // // John, Pete, Mary 순으로 출력.
}
```

`셋` 대신 배열을 사용하여 방문자 정보를 저장한 후, 중복 값 여부는 배열 메서드인 [arr.find](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find)를 이용해 확인할 수도 있다. 하지만 `arr.find`는 배열 내 요소 전체를 뒤져 중복 값을 찾기 때문에, 셋보다 성능 면에서 떨어진다. 반면, `셋`은 값의 유일무이함을 확인하는데 최적화되어있다.

## 셋의 값에 반복 작업하기

`for..of`나 `forEach`를 사용하면 셋의 값을 대상으로 반복 작업을 수행할 수 있다.

```javascript
let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// forEach를 사용해도 동일하게 동작한다.
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

`forEach`에 쓰인 콜백 함수는 세 개의 인수를 받는데, 첫 번째는 `값`, 두 번째도 *같은 값*인 `valueAgain`을 받고 있다. 세 번째는 목표하는 객체(셋)이다. 동일한 값이 인수에 두 번 등장하고 있다.

이렇게 구현된 이유는 `맵`과의 호환성 때문이다. `맵`의 `forEach`에 쓰인 콜백이 세 개의 인수를 받을 때를 위해서이다. 이상해 보이겠지만 이렇게 구현해 놓았기 때문에 `맵`을 `셋`으로 혹은 `셋`을 `맵`으로 교체하기가 쉽다.

`셋`에도 `맵`과 마찬가지로 반복 작업을 위한 메서드가 있다.

* `set.keys()` – 셋 내의 모든 값을 포함하는 이터러블 객체를 반환.
* `set.values()` – `set.keys`와 동일한 작업을 한다. `맵`과의 호환성을 위해 만들어진 메서드.
* `set.entries()` – 셋 내의 각 값을 이용해 만든 `[value, value]` 배열을 포함하는 이터러블 객체를 반환한다. `맵`과의 호환성을 위해 만들어졌다.

### 요약

`맵`은 키가 있는 값이 저장된 컬렉션이다.

주요 메서드와 프로퍼티:

* `new Map([iterable])` – 맵을 만든다. `[key,value]`쌍이 있는 `iterable`(예: 배열)을 선택적으로 넘길 수 있는데, 이때 넘긴 이터러블 객체는 맵 초기화에 사용된다.
* `map.set(key, value)` – 키를 이용해 값을 저장한다.
* `map.get(key)` – 키에 해당하는 값을 반환한다. `key`가 존재하지 않으면 `undefined`를 반환.
* `map.has(key)` – 키가 있으면 `true`, 없으면 `false`를 반환.
* `map.delete(key)` – 키에 해당하는 값을 삭제.
* `map.clear()` – 맵 안의 모든 요소를 제거.
* `map.size` – 요소의 개수를 반환.

일반적인 `객체`와의 차이점:

* 키의 타입에 제약이 없다. 객체도 키가 될 수 있다.
* `size` 프로퍼티 등의 유용한 메서드나 프로퍼티가 있다.

`셋`은 중복이 없는 값을 저장할 때 쓰이는 컬렉션이다.

주요 메서드와 프로퍼티:

* `new Set([iterable])` – 셋을 만든다. `iterable` 객체를 선택적으로 전달받을 수 있는데(대개 배열을 전달받음), 이터러블 객체 안의 요소는 셋을 초기화하는데 쓰인다.
* `set.add(value)` – 값을 추가하고 셋 자신을 반환한다. 셋 내에 이미 `value`가 있는 경우 아무런 작업을 하지 않는다.
* `set.delete(value)` – 값을 제거한다. 호출 시점에 셋 내에 값이 있어서 제거에 성공하면 `true`, 아니면 `false`를 반환한다.
* `set.has(value)` – 셋 내에 값이 존재하면 `true`, 아니면 `false`를 반환한다.
* `set.clear()` – 셋을 비운다.
* `set.size` – 셋에 몇 개의 값이 있는지 세준다.

`맵`과 `셋`에 반복 작업을 할 땐, 해당 컬렉션에 요소나 값을 추가한 순서대로 반복 작업이 수행된다. 따라서 이 두 컬렉션은 정렬이 되어있지 않다고 할 수는 없다. 그렇지만 컬렉션 내 요소나 값을 재 정렬하거나 (배열에서 인덱스를 이용해 요소를 가져오는 것처럼) 숫자를 이용해 특정 요소나 값을 가지고 오는 것은 불가하다.



## 위크맵과 위크셋 -

자바스크립트 엔진은 도달 가능한 값을 메모리에 유지한다.

- 예시

```javascript
let john = { name: "John" };

// 위 객체는 john이라는 참조를 통해 접근할 수 있다. 그런데 참조를 null로 덮어쓰면 위 객체에 더 이상 도달이 가능하지 않게 되어
 john = null;

// 객체가 메모리에서 삭제된다.
```

자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대게 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않는다. 객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당한다.

에를 들어보자. 배열에 객체 하나를 추가해 보겠다. 이때 배열이 메모리에 남아있는 한, 배열의 요소인 이 객체도 메모리에 남아있게 된다. 이 객체를 참조하는 것이 아무것도 없더라도 말이다.

아래 코드를 통해 확인해보자.

```javascript
let john = { name: "John" };

let array = [ john ];

john = null;

// john을 나타내는 객체는 배열의 요소이기 때문에 가비지 컬레터의 대상이 되지 않는다. array[0]을 이용하면 해당 객체를 얻는 것도 가능하다.
alert(JSON.stringify(array[0]));
```

맵에서 객체를 키로 사용한 경우 역시 맵이 메모리에 있는 한 객체도 메모리에 남는다. 가비지 컬렉터의 대상이 되지 않는다.

- 예시

```javascript
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // 참조를 null로 덮어씀

// john을 나타내는 객체는 맵 안에 저장되어있다.
// map.keys()를 이용하면 해당 객체를 얻는 것도 가능하다.
for(let obj of map.keys()){
  alert(JSON.stringify(obj));
}

alert(map.size); // 1
```

이런 관점에서 위크맵(WeakMap)은 일반 맵과 전혀 다른 양상을 보인다. 위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다.



### 위크맵

맵과 위크맵의 첫번째 차이는 위크맵의 키가 반드시 객체여야 한다는 점이다. **원시값은 위크맵의 키가 될 수 없다.**

```javascript
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // 정상적으로 동작(키 =객체)
weakMap.set("test", "oops"); // Error: Invalid value used as weak map key
```

위크맵의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 위크맵에서 자동으로 삭제된다.

```javascript
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // 참조를 덮어씀

// john을 나타내는 객체는 이제 메모리에서 지워진다.
```

 john을 나타내는 객체는 오로지 위크맵의 키로만 사용되고 있으므로 참조를 덮어쓰게 되면 이 객체는 위크맵과 메모리에서 자동으로 삭제된다.

맵과 위크맵의 두 번째 차이는 위크맵은 반복 작업과, keys(), values(), entries() 메서드를 지원하지 않는다는 점이다. 따라서 위크맵에선 키나 값 전체를 얻는게 불가능하다.

**위크맵이 지원하는 단축키는 단촐하다.** 

- weakMap.get(key)
- weakMap.set(key, value)
- weakMap.delete(key)
- weakMap.has(key)

이렇게 적은 메서드를 제공하는 이유는 가비지 컬렉션의 동작 방식 때문이다. 위 예시의 john을 나타내는 객체처럼 모든 참조를 잃게 되면 자동으로 가비지 컬렉션의 대상이 된다. 그런데 가비지 컬렉션의 동작 시점은 정확히 알 수 없다.

가비지 컬렉션이 일어나는 시점은 자바스크립트 엔진이 결정한다. 객체는 모든 참조를 잃었을 때, 그 즉시 메모리에서 삭제될 수도 있고, 다른 삭제 작업이 있을 때까지 대기하다가 함께 삭제될 수도 있다. 현재 위크맵에 요소가 몇개 있는지 정확히 파악하는 것 자체가 불가능한 것이다. 가비지 컬렉터가 한 번에 메모리를 청소할 수도 있고, 부분 부분 메모리를 청소할 수도 있으므로 위크맵의 요소 전체를 대상으로 무언가를 하는 메서드는 동작 자체가 불가능하다.

그럼 위크맵은 어떤 경우에 사용할까

### 유스 케이스: 추가 데이터

위크맵은 부차적인 데이터를 저장할 곳이 필요할 때 그 진가를 발휘한다.

서드파티 라이브러리와 같은 외부 코드에 속한 객체를 가지고 작업을 해야 한다고 가정해보자. 이 객체에 데이터를 추가해줘야 하는데 추가해 줄 데이터는 객체가 살아있는 동안에만 유효한 상황이다. 이럴 때 위크맵을 사용할 수 있다.

위크맵에 원하는 데이터를 저장하고 이때 키는 객체를 사용하면 된다. 이렇게하면 객체가 가비지 컬렉션의 대상이 될 때 데이터도 함께 사라지게 된다.

```javascript
weakMap.set(john, "비밀문서");
// john이 사망하면 비밀문서는 자동으로 파기된다.
```

좀 더 구체적인 예시를 들어보자.

아래에 사용자의 방문 횟수를 세어주는 코드가 있다. 관련 정보는 맵에 저장하고 있는데 맵 요소의 키엔 특정 사용자를 나타내는 객체를 값엔 해당 사용자의 방문 횟수를 저장하고 있다. 어떤 사용자의 정보를 저장할 필요가 없어지면 (가비지 컬렉션의 대상이 되면)해당 사용자의 방문 횟수도 저장할 필요가 없어질 것이다.

아래 함수는 맵을 사용해 사용자의 방문 횟수를 세준다.

```javascript
// 📁 visitsCount.js
let visitsCountMap = new Map(); // 맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려준다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

아래는 John이라는 사용자가 방문했을 때 어떻게 방문횟수가 증가하는지를 보여준다.

```javascript
// 📁 main.js
let john = { name: "John" };

countUser(john); // John의 방문 횟수를 증가시킴

// John의 방문 횟수를 셀 필요가 없어지면 아래와 같이 john을 null로 덮어쓴다.
john = null;
```

이제 john을 나타내는 객체는 가비지 컬렉션의 대상이 되어야 하는데 visitsCountMap의 키로 사용되고 있어서 메모리에서 삭제되지 않는다. 

특정 사용자를 나타내는 객체가 메모리에서 사라지면 해당 객체에 대한 정보(방문 횟수)도 손수 지워줘야 하는 상황이다. 이렇게 하지 않으면 visitsCountMap이 차지하는 메모리 공간이 한없이 커질것이다. 애플리케이션 구조가 복잡할 땐 이렇게 쓸모 없는 데이터를 수동으로 비워주는게 꽤 골치 아픈 일이다.

이런 문제를 weakMap을 사용해 예방할 수 있다.

```javascript
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // 위크맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려준다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

위크맵을 사용해 사용자 방문 횟수를 저장하면 visitsCountMap을 수동으로 청소해줄 필요가 없다. john을 나타내는 객체가 도달 가능하지 않은 상태가 되면 자동으로 메모리에서 삭제되기 때문이다. 위크맵의 키에 대응하는 값도 자동으로 가비지 컬렉션의 대상이 된다 

### 유스 케이스: 캐싱

위크맵은 캐싱이 필요할 때 유용하다. 캐싱은 시간이 오래 걸리는 작업의 결과를 저장해서 연산 시간과 비용을 절약해주는 기법이다. 동일한 함수를 여러 번 호출해야 할 때 최초 호출 시 반환된 값을 어딘가에 저장해 놓았다가 그 다음엔 함수를 호출하는 대신, 저장된 값을 사용하는게 캐싱이다.

아래 에시는 함수 연산 결과를 맵에 저장한다.

```javascript
// 📁cache.js
let cache = new Map();

// 연산을 수행하고 그 결과를 맵에 저장한다.
function process(obj) {
    if(!cache.has(obj)) {
        let result = /* 연산수행 */ obj;
    	cache.set(obj, result);
    }
    return cache.get(obj);
}

// 함수 process 호출
// 📁 main.js
let obj = {/* 객체 */};
let result = process(obj);

// 동일한 함수를 두 번째 호출할 땐
let resuilt2 = process(obj); // 연산을 수행할 필요 없이 맵에 저장된 결과를 가져오면 된다.

// 객체가 쓸모 없어지면 아래와 같이  null로 덮어 쓴다.
obj = null;

alert(cache.size); //1 
```

process(obj)를 여러 번 호출하면 최초 호출할 때만 연산이 수행되고, 그 이후엔 연산 결과를 cache에서 가져온다. 그런데 맵을 사용하고 있어서 객체가 필요 없어져도 cache를 수동으로 청소해줘야 한다.

맵을 위크맵을 변경하면 이런 문제를 예방할 수 있다. 객체가 메모리에서 삭제되면 캐시에 저장된 결과 역시 메모리에서 자동으로 삭제되기 때문이다.

```javascript
// 📁 cache.js
let cache = new WeakMap();

// 연산을 수행하고 그 결과를 위크맵에 저장한다.
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* 객체 */};

let result1 = process(obj);
let result2 = process(obj);

// 객체가 쓸모없어지면 아래와 같이 null로 덮어다.
obj = null;

// 이 예시에선 맵을 사용한 예시처럼 cache.size를 사용할 수 없다.
// 하지만 obj가 가비지 컬렉션의 대상이 되므로, 캐싱된 데이터 역시 메모리에서 삭제될 것이다.
// 삭제가 진행되면 cache엔 그 어떤 요소도 남아있지 않을것이다
```



### 위크셋

이제 위크셋에 대해 알아보자.

- 위크셋은 셋과 유사한데, 객체만 저장할 수 있다는 점이 다르다. 원시값은 저장할 수 없다.
- 셋 안의 객체는 도달 가능할 때만 메모리에서 유지된다.
- 셋과 마찬가지로 위크셋이 지원하는 메서드는 단출하다. `add`, `has`, `delete`를 사용할 수 있고, `size`, `keys()`나 반복작업 관련 메서드는 사용할 수 없다.

위크맵과 유사하게 위크셋도 부차적인 데이터를 저장할 때 사용할 수 있다. 다만 위크셋엔 위크앱처럼 복잡한 복잡한 데이터를 저장하지 않는다. 대신 예 || 아니오같은 간단한 답변을 얻는 용도로 사용된다. 물론 위크셋에 저장되는 값들은 객체이다.

예시와 함께 위크셋의 용도를 알아보자. 아래 코드에선 사용자의 사이트 방문 여부를 추적하는 용도로 위크셋을 사용하고 있다.

```javascript
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // john이 사이트를 방문
visitedSet.add(pete); // 이어서 Pete가 사이트를 방문한다.
visitedSet.add(john); // 이어서 John이 다시 사이트를 방문한다.

// visitiedSet엔 두 명의 사용자가 저장될 것이다.

// John의 방문 여부를 확인해보자.
alert(visitedSet.has(john)); // true

// Mary의 방문 여부를 확인해보자.
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet에서 john을 나타내는 객체가 자동으로 삭제된다.
```

**위크맵과 위크셋의 가장 큰 단점은 반복 작업이 불가능하다는 것이다.** 위크맵이나 위크셋에 저장된 자료를 한 번에 얻는게 불가능하다. 이런 단점은 불편을 초래하는 것 같지만 위크맵과 위크셋을 이요해 할 수 있는 주요 작업을 방해하진 않는다. 위크맵과 위크셋은 객체와 함께 추가 데이터를 저장하는 용도로 쓸 수 있다. 

### 요약

위크맵은 맵과 유사한 컬렉션이다. 위크맵을 구성하는 요소의 키는 오직 객체만 가능하다. 키로 사용된 객체가 메모리에서 삭제되면 이에 대응하는 값 역시 삭제된다.

위크셋은 셋과 유사한 컬렉션이다. 위크셋엔 객첵만 저장할 수 있다. 위크셋에 저장된 객체가 도달 불가능한 상태가 되면 해당 객체는 메모리에서 삭제된다.

두 자료구조 모두 구성 요소 전체를 대상으로 하는 메서드를 지원하지 않는데 이는 가비지 컬렉션의 구조 때문이다.

객체엔 주료 자료를 위크맵, 위크셋에는 부수적인 자료를 저장하는 형태로 위크맵, 위크셋을 활용할 수 있다. 객체가 메모리에서 삭제되면(그리고 오로지 위크맵, 위크셋의 키만 해당 객체를 참조하고 있다면) 위크맵이나 위크셋에 저장된 연관 자료들 역시 메모리에서 자동으로 삭제된다.



