# 코어 자바스크립트 - 자료구조와 자료형

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## 원시값의 메서드 - ⭐️

자바스크립트는 원시값을 마치 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 원시값은 객체가 아님을 상기하자.

### 원시값과 객체의 차이

- 원시값

  - string, number, bigint, boolean, symbol, null, undefined형으로 총 일곱가지의 원시형 값이다.

- 객체

  - 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
  - `{name : "John", age: 30}`와 같이 중괄호를 사용해 만들 수 있다. 자바스크립트에는 여러 종류의 객체가 있는데 함수도 객체의 일종이다.
  - 개게의 장점 중 하나는 함수를 프로퍼티로 지정할 수 있다는 것이다.

  ```javascript
  let john = {
      name: "John",
      age: 30,
  	sayHi: function() {
      	alert("친구야 반갑다");    
  	}
  };
  
  john.sayHi(); // 친구야 반갑다
  ```

  객체 john을 만들고 거기에 메서드 sayHi를 정의했다. 자바스크립트는 다양한 내장 객체를 제공한다. 이 객체들은 고유한 프로퍼티와 메서드를 가진다.

  하지만 이런 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다. 객체는 **원시값보다 무겁고, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.**



### 원시값을 객체처럼 사용하기

- 문자열이나 숫자와 같은 원시값을 다루는 작업이 많은데 메서드를 사용하면 작업을 수월하게 할 수 있을 것 같다는 생각
- 원시값은 가능한 한 가볍고 빨라야 한다.

의 상황을 해결해야만 했던 JS의 창안자는

1. 원시값은 원시값대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메서드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해 원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체 "원시 래퍼 객체"를 만들어준다. 이 객체는 곧 삭제된다.

Wrapper객체는 원시 타입에 따라 종류가 다양하며 원시값의 이름을 그대로 차용해 String, Number, Boolean, Symbol라고 부른다. 객체 마다 제공하는 메서드 역시 다르다.

- 예제

```javascript
let str = "hello";

alert(str.toUpperCase()); // HELLO
```

문자열 str은 원시값이므로 원시값의 프로퍼티에 접근하는 순간 래퍼 객체가 만들어지고 이 객체는 toUpperCase() 메서드를 실행하여 새로운 문자열 HELLO를 반환한다. 그리고 객체는 파괴되며 원시값 str만 남는다.

JS 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게끔 해준다.

숫자형도 고유한 메서드를 지원한다. 메서드 toFixed(n)를 이용하면 원하는 자리에서 소수점 아래 숫자를 반올림할  수 있다.

- 예제

```java
let n = 1.23456;

alert(n.toFixed(2)); // 1.23
```



숫자형, 문자열에서 더 많은 메서드를 알아보자

#### String/Number/Boolean을 생성자로 사용하면 혼란스럽다.

- 예시 1

```javascript
alert(typeof 0); // number
alert(typeof new Number(0)); // object
```

- 예시 2

```javascript
let zero = new Number(0);

if(zero) {
	alert("0이 참?");
}
```

그런데, new 키워드를 사용하지 않고 String/Number/Boolean을 사용하는 것은 괜찮다. 인수를 원하는 형의 원시값으로 바꿔준다.

#### unll/undefined는 메서드가 없다.

특수 자료형인 null/undefined의 원시값은 위와 같은 법칙을 따르지 않는다. 이 자료형과 연관되는 래퍼 객체도 없고 메서드도 제공하지 않는다. 어떤 의미에서는 두 자료형이 가장 원시적이라 할 수 있다.



## 숫자형 - ⭐️

모던 자바스크립튼느 숫자를 나타내는 두 가지 자료형을 제공한다.

1. 일반적인 숫자는 배정밀도 부동소수점 숫자로 알려진 64비트 형식의 IEEE-754에 저장된다. 
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있다. 일반적인 숫자는 2의 53제곱 이상이거나 -2의 53제곱 이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌다. BigInt는 아주 특별한 경우에만 사용되므로 별도의 챕터에서 다뤄진다.

### 숫자를 입력하는 다양한 방법

10억을 입력해야 한다고 했을 때 아래와 같이 직접 10억을 써줄 수 있다.

```javascript
let billion = 1000000000;
```

그런데 이렇게 0을 많이 사용해 숫자를 표현하다 보면 잘못 입력하기 쉽기 때문에 실제로는 이런 방법을 잘 사용하지 않는다. 그래서 대게 10억을 나타낼 땐 `1bn`을 사용하고 73억을 나타낼 땐 `7.3bn`을 사용한다.

자바스크립트도 숫자 옆에 e를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있다.

```javascript
let billion = 1e9; // 10억 1과 9개의 0

alert(7.3e9); // 73억
```

`e`는 e왼쪽의 수에 e오른쪽에 있는 수만큼의 10 거듭제곱을 곱하는 효과가 있다.

```javascript
1e3 = 1 * 10 * 10 * 10
1.23e6 = 1.23 * 1000000
```

반대로 작은 숫자를 표현할 때도 e를 사용할 수 있다. 0을 명시적으로 쓰고 싶지 않으면 다음과 같이 숫자를 표현할 수 있다.

```javascript
// before
let ms = 0.000001;
// after
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동
```



#### 16진수, 2진수, 8진수

16진수는 0x를 사용해 표현할 수 있다. 대 소문자를 가리지 않는다.

```javascript
alert(0xff); // 255
alert(0xFF); // 255
```

2진수와 8진수는 드물게 쓰이긴 하지만 0b, 0o를 사용해 간단히 나타낼 수 있다.

```javascript
let a = 0b11111111;
let b= 0o377;

alert(a == b); // true
```



### toString(base)

`num.toString(base)` 메서드는 base 진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환한다.

- 예시

```javascript
let num = 255;

alert(num.toString(16)); // 16진수 string으로 변경. ff
alert(num.toString(2)); // 2진수 string으로 변경. 11111111
```

base는 2 ~ 36까지 사용 가능하다. 기본값은 10이다.

- `base=16` - 16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 0 ~ 9, 10이상의 수는 A ~ F를 사용하여 나타낸다.

- `base=2` - 비트 연산 디버깅에 주로 쓰인다. 숫자는 0 || 1이다. 

- `base=36 ` - 사용할 수 있는 base 중 최대값으로 0..9, A..Z를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다. base는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다. 

  - 예시

  ```javascript
  alert(123456..toString(36)); // 2n9c
  ```

  > 숫자를 대상으로 메서드 toString()을 직접 호출하고 싶으면 `..`을 사용해야 한다. 



### 어림수 구하기

어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나이다.

- `Math.floor()`- 소수점 첫째 자리에서 내림. 3.1은 3으로 -1.1은 -2가 된다.
- `Math.ceil()` - 소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 된다. 
- `Math.round()` - 소수점 첫째 자리에서 반올림. 3.1은 3, -1.1은 -1이 된다.
- `Math.trunc()` - 소수부를 무시한다. 3.1은 3, -1.1은 -1이 된다.

소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 경우, 어떻게 해야 할까

1. 곱하기와 나누기

소수점 두 번째 자리 숫자까지만 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 원하는 어림수 내장 함수를 하고 처음 곱한 수를 다시 나누면 된다.

```javascript
let num = 1.23456;
alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 / 100 -> 1.23
```

2. 소수점 n번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n)를 사용한다.

```javascript
let num = 12.34;
alert(num.toFixed(1)); // "12.3"

// toFixed()는 Math.round()와 비슷하게 동작한다.
num = 12.36;
alert(num.toFixed(1)); // "12.4"
```

toFixed()의 반환값은 문자열이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.

```javascript
let num = 12.34;
alert(num.toFixed(5)); // "12.34000"; 
```



### 부정확한 계산

숫자는 내부적으로 64비트 IEEE-754로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 피룡하다. 64비트 중 52비트는 숫자를 저장하는데 사용되고, 11비트는 소수점 위치, 1비트는 음양의 부호를 저장하는데 사용된다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.

```javascript
alert(1e500); // Infinity
```

정밀도 손실의 예시를 살펴보자.

```javascript
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.3000000000004
```

0.1과 0.2의 합이 0.3이 아니라 0.300000000004가 나오는데, 이러한 값이 나오는 것을 정밀도 손실이라고 한다.

왜 이런일이 발생할까?

숫자는 0과1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그런데 **10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2같은 분수는 이진법으로 표현하면 무한소수가 된다.**

2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없다. IEEE-754에서는 이러한 무한소수를 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 해결한다. 하지만 이런 반올림 규척을 적용하면 작은 정밀도 손실이 발생한다.

그래서 0.1 + 0.2가 정확히 0.3이 아닌 이유가 된다.

이러한 문제를 해결하는데 도움을 주는 것이 toFixed(n)을 사용해 어림수를 만드는 것이다.

```javascript
let sum = 0.1 + 0.2;
alert(sum.toFixed(2))// 0.30;
```

이때 toFixed는 항상 문자열을 반환한다는 점에 유의하자. 문자열을 반환하기 때문에 소수점 다음에 오는 숫자가 항상 2개가 될 수 있다. 숫자로 변환하고 싶다면 단항 연산자 +를 사용하자.

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```



#### 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 현상은 0, -0이라는 두 종류의 0이 존재한다는 사실이다. 

자바스크립트에서는 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은 0과 -0을 동일하게 취급하기 때문에 두 0의 차이는 쉽게 두드러지지 않는다.



### isNaN, isFinite

- `Infinity` - 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` - 에러를 나타내는 값

두 특수 숫자는 숫자형에 속하지만 정상적인 숫자는 아니기 때문에 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- isNaN(value) - 인수를 숫자로 변환한 다음 NaN인지 테스트함

```javascript
alert(isNaN(NaN)); // true
alert(isNaN("str")); // false
```

===과 같은 비교연산이 아닌 isNaN 메서드를 사용하는 이유는 NaN은 자기자신을 포함해 어떤 값과도 같지 않기 때문이다.

- isFinite(value) - 인수를 숫자로 변환하고 변환한 숫자가  NaN/Infinity/-Infinity가 아닌 일반 숫자인 경우  true 반환

```javascript
alert(isFinite("15")); // true
alert(isFinite("str")); // false, NaN이기 때문에
alert(isFinite(Infinity)); // false
```

isFinite는 문자열이 일반 숫자인지 검증하는데 사용되곤 한다.

```javascript
let num = +prompt("숫자를 입력하세요, " '');

alert(isFinite(num));
```



### parseInt, parseFloat

단항 덧셈 연산자 + 또는 Number()를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격하다. 피연산자가 숫자가 아니면 형 변환이 실패한다.

```javascript
alert(+"100px"); // NaN
```

엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때이다.

하지만 12px, 14pt, 1.5em등의 숫자만 추출하는 방법이 필요할 때는 내장 함수 parseInt, parseFloat를 사용한다. 이 메서드는 불가능할 때까지 문자열에서 숫자를 읽고 부동 소수점 숫자를 반환한다.

```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환된다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```

parseInt, parseFloat이 NaN을 반환하는 경우도 있는데 읽을 수 있는 숫자가 없을 때 그렇다.

```javascript
alert(parseInt('a123')); // NaN
```

- parseInt(str, radix)

  parseInt의 두 번째 인수 radix는 선택사항이다. radix는 원하는 진수를 지정해줄 때 사용한다. 16, 2진수 등의 문자열 등을 파싱할 수 있다.



### 기타 수학 함수

- `Math.random()` - 0과 1 사이의 난수를 반환한다.

```javascript
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (무작위 수)
```

 

- `Math.max(a, b, c ...), Math.min(a, b, c ...)` - 인수 중 최대/최소값을 반환

```javascript
alert( Math.max(3, 5, -10, 0, 1) ); // 5 
alert( Math.min(1, 2) ); // 1
```

- `Math.pow(n, power)` - n을  power번 거듭제곱한 값을 반환

```javascript
alert( Math.pow(2, 10) ); // 2의 10제곱 = 1024
```



## 문자열 - 

자바스크립트는 char와 같이 문자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다.

JS에서 문자열은 페이지 인코딩 방식과 상관없이 UTF-16형식을 따른다.



### 따옴표

문자열은 `''`, `""`, ` `` `으로 감쌀 수 있다.

```javascript
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

작은 따옴표와 큰 따옴표는 기능상 차이가 없지만, 백틱은 특별한 기능이 있다. 표현식을 `${..}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 넣을 수 있다. 이 방식을 **템플릿 리터럴**이라고 부른다.

```javascript
function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1,2)}.`); // 1 +  2 = 3
```

백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.

```javascript
let guestList = `손님: 
* John,
* Pete,
* Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 작성함
```

