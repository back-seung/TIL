# 함수_심화학습

## 재귀와 스택 - ⭐️⭐️⭐️

재귀는 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다. 목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용할 수 있다. 특정 자료구조를 다뤄야 할 때도 재귀가 사용된다.

문제 해결을 하다 보면 함수에서 다른 함수를 호출해야 할 때가 있다. 이때 함수가 *자기 자신*을 호출할 수도 있는데, 이를 *재귀* 라고 부른다.

### 두 가지 사고방식

간단한 예시를 시작으로 재귀에 대해 알아보자. `x`를 `n` 제곱해 주는 함수 `pow(x, n)`를 만들어본다. `pow(x, n)`는 `x`를 `n`번 곱해주기 때문에 아래 결과를 만족해야 한다.

```javascript
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```

구현하는 방법은 두 가지가 있다.

1. 반복적인 사고를 통한 방법: `for` 루프

   ```javascript
   function pow(x, n) {
     let result = 1;
   
     // 반복문을 돌면서 x를 n번 곱함
     for (let i = 0; i < n; i++) {
       result *= x;
     }
   
     return result;
   }
   
   alert( pow(2, 3) ); // 8
   ```

2. 재귀적인 사고를 통한 방법: 작업을 단순화하고 자기 자신을 호출함

   ```javascript
   function pow(x, n) {
     if (n == 1) {
       return x;
     } else {
       return x * pow(x, n - 1);
     }
   }
   
   alert( pow(2, 3) ); // 8
   ```

재귀를 이용한 예시가 반복문을 사용한 예시와 어떤 부분에서 근본적인 차이가 있는지 잘 살펴보길 바란다.

`pow (x, n)`을 호출하면 아래와 같이 두 갈래로 나뉘어 코드가 실행된다.

```javascript
              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
```

1. `n == 1`일 때: 모든 절차가 간단해진다. 명확한 결괏값을 즉시 도출하므로 이를 *재귀의 베이스(base)* 라고 한다. `pow(x, 1)`는 `x` 이다.
2. `n == 1`이 아닐 때: `pow(x, n)`은 `x * pow(x, n - 1)`으로 표현할 수 있다. 수학식으론 `xn = x * xn-1`로 표현할 수 있다. 이를 *재귀 단계(recursive step)* 라고 부른다. 여기선 목표 작업 `pow(x, n)`을 간단한 동작(`x`를 곱하기)과 목표 작업을 변형한 작업(`pow(x, n - 1)`)으로 분할하였다. 재귀 단계는 `n`이 `1`이 될 때까지 계속 이어진다.

즉, `pow`는 `n == 1`이 될 때까지 *재귀적으로 자신을 호출*한다.

`pow (2, 4)`를 계산하려면 아래와 같은 재귀 단계가 차례대로 이어진다.

1. `pow(2, 4) = 2 * pow(2, 3)`
2. `pow(2, 3) = 2 * pow(2, 2)`
3. `pow(2, 2) = 2 * pow(2, 1)`
4. `pow(2, 1) = 2`

이렇게 재귀를 이용하면 함수 호출의 결과가 명확해질 때까지 함수 호출을 더 간단한 함수 호출로 계속 줄일 수 있다.

* **재귀를 사용한 코드는 짧다.**

재귀를 사용한 코드는 반복적 사고에 근거하여 작성한 코드보다 대개 짧다.

`if` 대신 조건부 연산자 `?`를 사용하면 `pow (x, n)`를 더 간결하고 읽기 쉽게 만들 수도 있다.

```javascript
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```

가장 처음 하는 호출을 포함한 중첩 호출의 최대 개수는 *재귀 깊이(recursion depth)* 라고 한다. `pow(x, n)`의 재귀 깊이는 `n`이다.

자바스크립트 엔진은 최대 재귀 깊이를 제한한다. 만개 정도까진 확실히 허용하고, 엔진에 따라 이보다 더 많은 깊이를 허용하는 경우도 있다. 하지만 대다수의 엔진이 십만까지는 다루지 못한다. 이런 제한을 완화하려고 엔진 내부에서 자동으로 'tail calls optimization’라는 최적화를 수행하긴 하지만, 모든 곳에 적용되는 것은 아니고 간단한 경우에만 적용된다.

재귀 깊이 제한 때문에 재귀를 실제 적용하는데 제약이 있긴 하지만, 재귀는 여전히 광범위하게 사용되고 있다. 재귀를 사용하면, 간결하고 유지보수가 쉬운 코드를 만들 수 있기 때문이다.

### 실행 컨텍스트와 스택

실제 재귀 호출이 어떻게 동작하는지 알아보자. 이를 위해서 함수의 내부 동작에 대해 살펴보도록 한다.

실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 *실행 컨텍스트(execution context)* 에 저장된다.

실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, `this`의 값(여기선 다루지 않음) 등 상세 내부 정보가 실행 컨텍스트에 저장된다.

함수 호출 1회당 정확히 하나의 실행 컨텍스트가 생성된다.

함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행된다.

* 현재 함수의 실행이 일시 중지된다.
* 중지된 함수와 연관된 실행 컨텍스트는 *실행 컨텍스트 스택(execution context stack)* 이라는 특별한 자료 구조에 저장된다.
* 중첩 호출이 실행된다.
* 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

이제 `pow (2, 3)`가 호출되면 실행 컨텍스트에서 무슨 일이 일어나는지 살펴보자.

### pow(2, 3)

`pow (2, 3)`를 호출하는 순간, 실행 컨텍스트엔 변수 `x = 2, n = 3`이 저장되고, 실행 흐름은 함수의 첫 번째 줄에 위치한다.

이를 도식화하면 다음과 같다.

* Context: { x: 2, n: 3, 첫 번째 줄 } pow(2, 3)

위 그림은 함수 실행이 시작되는 순간을 나타낸 것이다. 지금 상태론 조건 `n == 1`을 만족하지 못하므로 실행 흐름은 `if`의 두 번째 분기로 넘어간다.

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
```

변수는 동일하지만, 실행 흐름의 위치가 변경되면서 실행 컨텍스트도 다음과 같이 변경된다.

* Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

`x * pow (x, n - 1)`을 계산하려면 새로운 인수가 들어가는 `pow`의 서브 호출(subcall), `pow (2, 2)`을 만들어야 한다.

### pow(2, 2)

중첩 호출을 하기 위해, 자바스크립트는 *실행 컨텍스트 스택* 에 현재 실행 컨텍스트를 저장한다.

지금 보고 있는 예시에선 실행 컨텍스트 스택에 동일한 함수 `pow`를 호출하였는데, 이는 중요치 않다. 모든 함수에 대해 아래 프로세스가 똑같이 적용된다.

1. 스택 최상단에 현재 컨텍스트가 '기록’된다.
2. 서브 호출을 위한 새로운 컨텍스트가 만들어진다.
3. 서브 호출이 완료되면. 기존 컨텍스트를 스택에서 꺼내(pop) 실행을 이어나간다.

다음은 서브 호출 `pow (2, 2)`이 시작될 때의 실행 컨텍스트 스택이다.

* **Context: { x: 2, n: 2, 첫 번째 줄 } pow(2, 2)**
* Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

굵은 테두리로 표시한 새 실행 컨텍스트는 상단에, 기존 컨텍스트는 하단에 있다.

이전 컨텍스트에 변수 정보, 코드가 일시 중단된 줄에 대한 정보가 저장되어있기 때문에 서브 호출이 끝났을 때 이전 컨텍스트가 문제없이 다시 시작된다.

**주의:**

예시엔 한 줄에 서브 호출 하나만 있기 때문에, 그림에서 '줄’이라는 단어를 사용했다.

하지만 한 줄에는 `pow(…) + pow(…) + somethingElse(…)` 같이 복수의 서브 호출이 있을 수 있다.

따라서 좀 더 정확히는 실행이 '서브 호출 바로 직후’에 시작된다고 이야기 할 수 있다.

### pow(2, 1)

동일한 과정이 다시 반복된다. 다섯 번째 줄에서 인수 `x = 2`, `n = 1`과 함께 새로운 서브 호출이 만들어진다.

새로운 실행 컨텍스트가 만들어지고, 이전 실행 컨텍스트는 스택 최상단에 올라간다(push).

* Context: { x: 2, n: 1, 첫 번째 줄 } pow(2, 1)
* Context: { x: 2, n: 2, 다섯 번째 줄 } pow(2, 2)
* Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

기존 컨텍스트 두 개가 밑에, `pow (2, 1)`에 상응하는 컨텍스트가 맨 위에 있는 것을 확인할 수 있다.

### 실행 종료

`pow (2, 1)`가 실행될 땐 상황이 달라진다. 이전과는 달리 조건 `n == 1`을 만족시키므로 `if`문의 첫 번째 분기가 실행된다.

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```

이젠 호출해야 할 중첩 호출이 없다. 따라서 함수는 종료되고 `2`가 반환된다.

함수가 종료되었기 때문에 이에 상응하는 실행 컨텍스트는 쓸모가 없어졌다. 따라서 해당 실행 컨텍스트는 메모리에서 삭제된다. 스택 맨 위엔 이전의 실행 컨텍스가 위치하게 된다.

* Context: { x: 2, n: 2, 다섯 번째 줄 } pow(2, 2)
* Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

`pow (2, 2)`의 실행이 다시 시작된다. 서브 호출 `pow (2, 1)`의 결과를 알고 있으므로, 쉽게 `x * pow (x, n - 1)`를 계산해 `4`를 반환한다.

그리고 다시 이전 컨텍스트가 스택 최상단에 위치하게 된다.

* Context: { x: 2, n: 3, 다섯 번째 줄 } pow(2, 3)

마지막 실행 컨텍스트까지 처리되면 `pow (2, 3) = 8`이라는 결과가 도출된다.

지금 본 예시의 재귀 깊이는 **3** 이다.

도식을 통해 살펴보았듯이, 재귀 깊이는 스택에 들어가는 실행 컨텍스트 수의 최댓값과 같다.

실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 땐 메모리 요구사항에 유의해야 한다. `n`을 늘리면 `n`이 줄어들 때마다 만들어지는 `n`개의 실행 컨텍스트가 저장될 메모리 공간이 필요하기 때문이다.

한편, 반복문 기반 알고리즘을 사용하면 메모리가 절약된다.

```javascript
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

반복을 사용해 만든 함수 `pow`는 컨텍스트를 하나만 사용한다. 이 컨텍스트에서 `i`와 `result`가 변경된다. 실행 컨텍스트가 하나이기 때문에 `n`에 의존적이지 않고, 필요한 메모리가 적다. 사용 메모리 공간도 고정된다.

**재귀를 이용해 작성한 코드는 반복문을 사용한 코드로 다시 작성할 수 있다. 반복문을 사용하면 대개 함수 호출의 비용(메모리 사용)이 절약된다.**

하지만 코드를 다시 작성해도 큰 개선이 없는 경우가 있다. 조건에 따라 함수가 다른 재귀 서브 호출을 하고 그 결과를 합칠 때가 그렇다. 분기문이 복잡하게 얽혀있을 때도 메모리가 크게 절약되지 않는다. 이런 경우엔 최적화가 필요하지 않을 수 있고 최적화에 드는 노력이 무용지물일 수 있다.

재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다. 모든 곳에서 메모리 최적화를 신경 써서 코드를 작성해야 하는 것은 아니다. 우리가 필요한 것은 좋은 코드이며, 이런 이유 때문에 재귀를 사용한다.

### 재귀적 순회

재귀는 재귀적 순회(recursive traversal)를 구현할 때 사용하면 좋다.

한 회사가 있다고 가정해 보자. 임직원을 아래와 같이 객체로 표현해 보았다.

```javascript
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
```

회사엔 부서가 있다.

* 부서에는 여러 명의 직원이 있는데, 이를 배열로 표현할 수 있다. `sales` 부서의 John과 Alice라는 2명의 직원을 배열 요소로 표현해 보았다.

* 부서는 하위 부서를 가질 수 있다. `development` 부서는 `sites`와 `internals`라는 두 개의 하위 부서를 갖는다. 각 하위부서에도 직원이 있다.

* 하위 부서가 커지면 더 작은 단위의 하위 부서(또는 팀)로 쪼개질 가능성도 있다.

  `sites` 부서는 미래에 `siteA`와 `siteB`로 나뉠 수 있다. 이렇게 나눠진 부서가 미래에 더 세분화될 수도 있다. 미래에 벌어질 일까진 나타내지 않았지만, 이러한 가능성도 있다는 걸 염두에 두어야 한다.

자, 이제 모든 임직원의 급여를 더한 값을 구해야 한다고 해보자. 어떻게 할 수 있을까?

구조가 단순하지 않기 때문에 반복문을 사용해선 구하기 쉽지 않아 보인다. 가장 먼저 떠오르는 생각은 `company`를 대상으로 동작하는 `for` 반복문을 만들고 한 단계 아래의 부서에 중첩 반복문를 돌리는 것이다. 그런데 이렇게 하면 `sites` 같은 두 단계 아래의 부서에 속한 임직원의 급여를 뽑아낼 때 또 다른 중첩 반복문이 필요하다. 세 단계 아래의 부서가 미래에 만들어진다고 가정하면 또 다른 중첩 반복문이 필요할 것이다. 얼마만큼의 깊이까지 중첩 반복문을 만들 수 있을까? 객체를 순회하는 중첩 반복문의 깊이가 3~4개가 되는 순간 코드는 정말 지저분해질 것이다.

재귀를 이용한 풀이법을 시도해 보자.

앞서 본 바와 같이 임직원 급여 합계를 구할 때는 두 가지 경우로 나누어 생각할 수 있다.

1. 임직원 *배열* 을 가진 ‘단순한’ 부서 – 간단한 반복문으로 급여 합계를 구할 수 있다.
2. `N`개의 하위 부서가 있는 *객체* – 각 하위 부서에 속한 임직원의 급여 합계를 얻기 위해 `N`번의 재귀 호출을 하고, 최종적으로 모든 하위부서 임직원의 급여를 더한다.

배열을 사용하는 첫 번째 경우는 간단한 경우로, 재귀의 베이스가 된다.

객체를 사용하는 두 번째 경우는 재귀 단계가 된다. 복잡한 작업은 작은 작업(하위 부서에 대한 반복문)으로 쪼갤 수 있다. 부서의 깊이에 따라 더 작은 작업으로 쪼갤 수 있는데, 결국 마지막엔 첫 번째 경우가 될 것이다.

코드를 직접 읽어보면서 재귀 알고리즘을 이해해보자.

```javascript
let company = { // 동일한 객체(간결성을 위해 약간 압축함)
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// 급여 합계를 구해주는 함수
function sumSalaries(department) {
  if (Array.isArray(department)) { // 첫 번째 경우
    return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
  } else { // 두 번째 경우
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
```

짧고 이해하기 쉬운 코드로 원하는 기능을 구현하였다. 재귀의 강력함은 여기에 있다. 하위 부서의 깊이와 상관없이 원하는 값을 구할 수 있게 되는 것이다.

객체 `{...}`를 만나면 서브 호출이 만들어지는 반면, 배열 `[...]`을 만나면 더 이상의 서브 호출이 만들어지지 않고 결과가 바로 계산된다.

함수 내부에선 앞서 학습한 두 문법을 사용하고 있는 것도 눈여겨보길 바란다.

* 배열과 메서드 챕터에서 학습한 메서드 `arr.reduce`는 배열의 합을 계산해 준다.
* `for(val of Object.values (obj))`에서 쓰인 `Object.values`는 프로퍼티의 값이 담긴 배열을 반환한다.

### 재귀적 구조

재귀적으로 정의된 자료구조인 재귀적 자료 구조는 자기 자신의 일부를 복제하는 형태의 자료 구조이다.

위에서 살펴본 회사 구조 역시 재귀적 자료 구조 형태이다.

회사의 *부서* 객체는 두 가지 종류로 나뉜다.

* 사람들로 구성된 배열
* 하위 부서로 이루어진 객체

웹 개발자에게 익숙한 HTML과 XML도 재귀적 자료 구조 형태를 띈다.

HTML 문서에서 *HTML 태그*는 아래와 같은 항목으로 구성되기 때문이다.

* 일반 텍스트
* HTML-주석
* 이 외의 *HTML 태그* (이 아래에 일반 텍스트, HTML-주석, 다른 HTML 태그가 올 수 있다.)

이렇게 다양한 곳에서 재귀적으로 정의된 자료구조가 쓰인다.

다음은 '연결 리스트’라는 재귀적 자료 구조를 살펴보면서 재귀적 구조에 대해 더 알아보도록 하겠다. 몇몇 상황에서 배열 대신 연결 리스트를 사용하면 더 좋은 경우가 있다.

### 연결 리스트

객체를 정렬하여 어딘가에 저장하고 싶다고 가정해 보자.

가장 먼저 떠오르는 자료 구조는 아마 배열일 것이다.

```javascript
let arr = [obj1, obj2, obj3];
```

하지만 배열은 요소 '삭제’와 '삽입’에 들어가는 비용이 많이 든다는 문제가 있다. `arr.unshift(obj)` 연산을 수행하려면 새로운 `obj`를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매겨야 한다. 배열이 커지면 연산 수행 시간이 더 걸리게 된다. `arr.shift()`를 사용할 때도 마찬가지이다.

요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 `arr.push/pop` 뿐이다. 앞쪽 요소에 무언가를 할 때 배열은 이처럼 꽤 느리다.

빠르게 삽입 혹은 삭제를 해야 할 때는 배열 대신 연결 리스트(linked list)라 불리는 자료 구조를 사용할 수 있다.

*연결 리스트의 요소* 는 객체와 아래 프로퍼티들을 조합해 정의할 수 있다.

* `value`
* `next`: 다음 *연결 리스트 요소*를 참조하는 프로퍼티. 다음 요소가 없을 땐 `null`이 된다.

예시:

```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```

아래처럼 코드를 작성해도 동일한 연결 리스트가 된다.

```javascript
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

이렇게 연결 리스트를 만드니 객체가 여러개 있고, 각 객체엔 `value`와 이웃 객체를 가리키는 프로퍼티인 `next`가 있는 게 명확히 보인다. 체인의 시작 객체는 변수 `list`에 저장되어 있다. 우리는 `list`의 `next` 프로퍼티를 이용해 이어지는 객체 어디든 도달할 수 있다.

연결 리스트를 사용하면 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고, 다시 합치는 것도 가능하다.

```javascript
let secondList = list.next.next;
list.next.next = null;
```

합치기:

```javascript
list.next.next = secondList;
```

그리고 쉽게 요소를 추가하거나 삭제할 수 있다. 리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.

```javascript
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// list에 새로운 value를 추가.
list = { value: "new item", next: list };
```

중간 요소를 제거하려면 이전 요소의 `next`를 변경해주면 된다.

```javascript
list.next = list.next.next;
```

`list.next`가 `1`이 아닌 `2`를 `value`로 갖는 객체를 가리키게 만들어보았다. 이제 `value` `1`은 체인에서 제외된다. 이 객체는 다른 곳에 따로 저장하지 않으면 자동으로 메모리에서 제거된다.

지금까지 살펴본 것과 같이 연결 리스트는 배열과는 달리 대량으로 요소 번호를 재할당하지 않으므로 요소를 쉽게 재배열할 수 있다는 장점이 있다.

물론 연결 리스트가 항상 배열보다 우월하지는 않다. 그렇지 않았다면 모든 사람들이 연결 리스트만 사용할 것이다.

연결 리스트의 가장 큰 단점은 **번호(인덱스)만 사용해 요소에 쉽게 접근할 수 없다는 점**이다. 배열을 사용하면 `arr[n]`처럼 번호 `n`만으로도 원하는 요소에 바로 접근할 수 있다. 그러나 연결 리스트에선 `N`번째 값을 얻기 위해 첫 번째 항목부터 시작해 `N`번 `next`로 이동해야 한다.

그런데 중간에 요소를 삽입하거나 삭제하는 연산이 항상 필요한 것은 아니다. 이럴 땐 순서가 있는 자료형 중에 큐(queue)나 데크(deque)를 사용할 수 있다. 데크를 사용하면 양 끝에서 삽입과 삭제를 빠르게 수행할 수 있다.

위에서 구현한 연결 리스트는 아래와 같은 기능을 더해 개선할 수 있다.

* 이전 요소를 참조하는 프로퍼티 `prev`를 추가해 이전 요소로 쉽게 이동하게 할 수 있다.
* 리스트의 마지막 요소를 참조하는 변수 `tail`를 추가할 수 있다. 다만 이때 주의할 점은 리스트 마지막에 요소를 추가하거나 삭제할 때 `tail`도 갱신해 줘야 한다.
* 이 외에도 요구사항에 따라 구조를 변경할 수 있다.

### 요약

* *재귀(recursion)* – 함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 용어. 재귀 함수는 우아하게 원하는 문제를 해결할 때 자주 쓰이곤 한다.

  함수가 자신을 호출하는 단계를 *재귀 단계(recursion step)* 라고 부른다. basis라고도 불리는 재귀의 *베이스(base)* 는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수이다.

* 재귀적으로 정의된 자료 구조는 자기 자신을 이용해 자료 구조를 정의한다.

  재귀적으로 정의된 자료구조에 속하는 연결 리스트는 리스트 혹은 null을 참조하는 객체로 이루어진 데이터 구조를 사용해 정의된다.

  ```javascript
  list = {value, next -> list}
  ```

  HTML 문서의 HTML 요소 트리나 위에서 다룬 부서를 나타내는 트리 역시 재귀적인 자료 구조로 만들었다. 이렇게 재귀적인 자료 구조를 사용하면 가지가 여러 개인데 각 가지가 여러 가지로 뻗쳐 나가는 형태로 자료 구조를 만들 수 있다.

  예시에서 구현한 `sumSalary`같은 재귀 함수를 사용하면 각 분기(가지)를 순회할 수 있다.

모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있다. 최적화를 위해 반복문으로 다시 작성해야 할 수도 있다. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작한다. 재귀를 사용하면 구현과 유지보수가 쉽다는 장점도 있다.



## 나머지 매개변수와 스프레드 문법 - ⭐️⭐️

상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다. 

예시

- Math.max(arg1, arg2, ...argN) - 인수 중 가장 큰 수를 반환한다.
- Object.assign(dest, src1, ..., srcN) - src1..N의 프로퍼티를 dest로 복사한다.
- 기타 등등

임의의 수의 인수를 받는 방법에 대해 알아본다. 또한 함수의 매개변수에 배열을 전달하는 방법에 대해서도 알아보자.

### 나머지 매개변수 `...`

함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수에는 제약이 없다.

```javascript
function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
```

함수를 정의할 땐 인수를 두개만 받도록 하고 실제 함수를 호출할 땐 이보다 더 많은 여분의 인수를 전달했지만 에러는 발생하지 않는다. 다만 반환값은 처음 두 개의 인수만을 사용해 계산된다.

이렇게 매개변수는 그 값들을 담을 배열 이름을 마침표 세 개 `...`을 붙여주면 함수 선언부에 포함시킬 수 있다. 이때 마침표 세 개는 "**남아 있는 매개변수들을 한데 모아 배열에 집어넣어라**"는 것을 의미한다.

아래 예시에선 모든 인수가 배열 args에 모인다.

```javascript
function sumAll(...args) {
  let sum = 0;
  
  for(let arg of args) {
    sum += arg;
  }
  
  return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1,2)); // 3
alert(sumAll(1,2,3)); // 6
```

앞부분의 매개변수는 변수로, 남아있는 매개변수들은 배열로 모을 수도 있다.

아래 예시에선 처음 두 인수는 변수에 나머지 인수들은 titles라는 배열에 할당한다.

```javascript
function showName(firstName, lastName, ...titles) {
  alert(firstName + ' ' + lastName);
  
  // 나머지 인수들은 배열 titles의 요소가 된다.
  // titles= ["Software Engineer", "Researcher"]
  
  alert( titles[0] ); // Software Engineer
  alert( titles[1] ); // Researcher
  alert( titles.length ); // 2
}

showName("Bora", "Lee", "Software Engineer", "Researcher");
```

> ! 나머지 매개변수는 항상 마지막에 있어야 한다.

나머지 매개변수는 남아있는 인수를 모으는 역할을 하므로 아래 예시에서는 에러가 발생한다.

```javascript
function f(arg1, ...rest, arg2) { // ...rest 후에 arg2가 있으면 안됨.
  // 에러
}
```



### arguments 객체

유사 배열 객체인 arguments를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.

예시 :

```javascript
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg); 를 사용해 인수를 펼칠 수 있다.
}

// 2, Bora, Lee가 출력됨
showName("Bora", "Lee");

// 1, Bora, undefined가 출력됨(두 번째 인수는 없음)
showName("Bora");
```

나머지 매개변수 `...`은 비교적 최근에 나온 문법이다. 나머지 매개변수가 나오기 이전에는 함수의 인수 전체를 얻어내는 방법이 arguments를 사용하는 것밖에 없었다.

arguments는 유사 배열 객체이면서 iterable객체이다. 어쨌든 배열은 아니다. 따라서 배열 메서드를 사용할 수 없다는 단점이 있다. 예를 들어 arguments.map()을 호출할 수 없다. 또한 arguments는 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다.

**배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는게 좋다.**

> ! 화살표 함수는 arguments를 지원하지 않는다.

화살표 함수엥서 arguments 객체에 접근하면 외부에 있는 '일반'함수의 arguments 객체를 가져온다.

- 예시

```javascript
function f() {
  	let showArg = () => alert(arguments[0]);
  	showArg();
}

f(1); // 1
```

화살표 함수는 자체 this를 가지지 않는다. 여기에 더 해 화살표 함수는 arguments를 지원하지 않는다는 것을 확인해보았다.



### 스프레드 문법

매개변수 목록을 배열로 가져오는 방법이 있으면 반대의 기능인 배열을 통째로 매개변수에 넘겨주는 등의 기능은 없을까?

다음 예시를 보자

Math.max는 인수로 받은 숫자 중 가장 큰 숫자를 반환한다.

```javascript
alert(Math.max(3,5,1));
```

배열 [3,5,1]이 있고, 이 배열을 대상으로 Math.max를 호출하고 싶다고 가정할 때, 아무런 조작없이 배열을 있는 그대로 Math.max()에 넘기면 원하는대로 동작하지 않는다. Math.max는 숫자 목록을 인수로 받기 때문이다.

```javascript
let arr = [3, 5, 1];

alert( Math.max(arr) ); // NaN
```

배열 요소를 Math.max (arr[0], arr[1], arr[2])처럼 수동으로 나열하는 방법도 있지만 배열의 길이를 모르면 불가능한 일이다. 

이럴때 *스프레드 문법*을 사용하는데, `...`을 사용해 나머지 매개변수와 비슷해 보이지만 스프레드 문법은 나머지 매개변수와 반대되는 역할을 한다.

함수를 호출할 때 ...arr를 사용하면 이터러블 객체 arr이 인수 목록으로 '확장'된다.

```javascript
let arr = [3, 5, 1];

alert(Math.max(...arr)); // 5
```

아래와 같이 이터러블 객체 여러개를 전달하는 것도 가능하다.

```javascript
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(1, ...arr1, 2, ...arr2, 25)); // 25
```

스프레드 문법은 배열을 합칠 때도 활용할 수 있다.

```javascript
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0, 3, 5, 1, 2, 8, 9, 15
```

앞선 예시들에선 배열을 대상으로 스프레드 문법이 어떻게 동작하는지 살펴보았다.

그런데 배열이 아니더라도 이터러블 객체라면 스프레드 문법을 사용할 수 있다.

스프레드 문법을 사용해 문자열을 문자 배열로 변환 시켜보자.

```javascript
let str = "hello";

alert([...str]); // h,e,l,l,o
```

스프레드 문법은  for..of와 같은 방식으로 내부에서 이터레이터를 사용해 요소를 수집한다.

문자열에 for..of를 사용하면 문자열을 구성하는 문자가 반환된다. ...str도 h,e,l,l,o가 되는데, 이 문자 목록을 배열 초기자로 전달된다.
메서드 Array.from은 이터러블 객체인 문자열을 배열로 바꿔주기 때문에 Array.from을 사용해도 동일한 작업을 할 수 있다.

```javascript
let str = "hello";
// Array.from은 이터러블을 배열로 바꿔준다.
alert(Array.from(str)); // h,e,l,l,o
```

`[...str]`과 동일한 결과가 출력되는 것을 확인할 수 있다.

그런데 Array.from(obj)와 [...obj]는 다음과 같은 미묘한 차이가 있다.

- Array.from은 유사 배열 객체와 이터러블 객체 둘 다에 사용할 수 있다.
- 스프레드 문법은 이터러블 객체에만 사용할 수 있다.

**이런 이유 때문에 무언가를 배열로 바꿀 때는 스프레드 문법보다 Array.from이 보편적으로 사용된다.**



### 배열과 객체의 복사본 만들기

참조에 의한 객체 복사 챕터에서 Object.assign()을 사용해 객체를 복사한 예시가 있었다.

Object.assign() 말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있다.

```javascript
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음 매개변수 목록을 새로운 배열에 할당한다.

// 배열 복사본의 요소가 기존 배열 요소와 같은지 확인
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열은 같은지 확인
alert(arr === arrCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
alert(arr); // 1,2,3,4
alert(arrCopy); // 1,2,3
```

이번엔 객체를 복사하는 예시를 살펴보겠다.

```javascript
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에 매개변수 목록을 새로운 객체에 할당함

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 같은지 확인
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같은지 확인
alert(obj === objCopy); // false (참조가 다름)

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않는다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1, "b":2, "c":3, "d":4}
alert(JSON.stringify(objCopy)); // {"a":1, "b":2, "c":3}
```

이렇게 스프레드 문법을 사용하면 let objCopy = Object.assign({}, obj);`, `let arrCopy = Object.assign([], arr);보다 더 짧은 코드로 배열이나 객체를 복사할 수 있어서 사람들은 이 방법을 선호한다.



### 요약

"..."은 나머지 매개변수나 스프레드 문법으로 사용할 수 있다.

나머지 매개변수와 스프레드 문법은 아래의 방법으로 구분할 수 있다.

- ...이 함수 매개변수의 끝에 있으면 인수 목록의 나머지를 배열로 모아주는 `나머지 매개변수`이다.
- ...이 함수 호출 시 사용되거나 기타 경우엔 배열을 목록으로 확장해주는 `스프레드 문법`이다.

사용 패턴 :

- 인수 개수에 제한이 없는 함수를 만들 때 나머지 매개변수를 사용한다.
- 다수의 인수를 받는 함수에 배열을 전달할 때 스프레드 문법을 사용한다.

둘을 함께 사용하면 매개변수 목록과 배열 간 전환을 쉽게 할 수 있다.

조금 오래된 방법이긴 하지만 arguments라는 반복 가능한 유사 배열 객체를 사용해도 인수 모두를 사용할 수 있다.



## 변수의 유효범위와 클로저 - ⭐️⭐️⭐️⭐️

자바스크립트는 함수 지향 언어이다. 이런 특징은 개발자에게 많은 자유를 준다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문이다.

그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까? 함수는 새로운 값을 가져올까? 아니면 생성 시점 이전의 값을 가져올까?

매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까? 함수는 호출되는 곳을 기준으로 외부 변수에 접근할까? 

### 코드 블록

코드 블록 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.

예시 : 

```javascript
{
    // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없다.
    
    let message = "안녕하세요"; // 블록 내에서만 변숫값을 얻을 수 있다.
    alert(message);    
}

alert(message); // ReferenceError: message is not defined
```

이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다. 블록 안엔 작업 수행에만 필요한 변수가 들어간다.

```javascript
{
    // 메시지 출력
    let message = "안녕하세요";
    alert(message);
}

{
    // 또 다른 메시지 출력
    let message = "안녕히 가세요";
    alert(message);
}
```

> 블록이 없으면 에러가 발생한다.

이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 let으로 선언하면 에러가 발생한다.

```javascript
// 메시지 출력
let message = "안녕하세요";
alert(message);

// 또 다른 메시지 출력
let message = "안녕히 가세요."; // SyntaxError: Identifier 'message' has already been declared
alert(message);
```

if, for, while 등에서도 마찬가지로 `{...}`안에서 선언한 변수는 오직 블록안에서만 접근이 가능하다.

```javascript
if (true) {
  let phrase = "안녕하세요!";

  alert(phrase); // 안녕하세요!
}

alert(phrase); // ReferenceError: phrase is not defined
```

if 블록 밖에 있는 alert는 phrase에 접근할 수 없기 때문에 위 예시를 실행하면 에러가 발생한다.

이런 특징은 변수의 유효 범위를 블록 범위, 특히 if 분기문 범위로 한정시킬 수 있어서 아주 유용하다.

if뿐만 아니라 for, while 반복문에서도 동일한 특징이 적용된다.

```javascript
for (let i = 0; i < 3; i++) {
  // 변수 i는 for 안에서만 사용할 수 있다.
  alert(i); // 0, 1, 2가 출력
}

alert(i); // ReferenceError: i is not defined
```



### 중첩 함수

함수 내부에서 선언한 함수는 중첩함수라고 부른다.

자바스크립트에서는 손쉽게 중첩 함수를 만들 수 있다.

중첩 함수는 아래와 같이 코드르 정돈하는데 사용할 수 있다.

```javascript
function sayHiBye(firstName, lastName) {

  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );

}
```

위 예시에서 외부 변수에 접근해 이름 전체를 반환해주는 *중첩* 함수 `getFullName()`은 편의상 만든 함수이다.

중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다는 점에서 흥미롭다. 이렇게 반환된 중첩함수는 어디서든 호출해 사용할 수 있다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함이 없다.

아래 함수 makeCounter는 호출될 때마다 다음 숫자를 반환해주는 카운터 함수를 만든다

```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

예시의 `makeCounter`는 아주 단순하지만, 여기에 약간의 변형을 가하면 난수 생성기 같은 실용성 있는 함수를 만들 수 있다.

그런데 counter를 여러개 만들면 이 함수들은 서로 독립적일까? 함수와 중첩함수 내 count 변수엔 어떤 값이 할당될까? 같은 의문이 생기기 마련이다.

의문을 해결해보자.

### 렉시컬 환경

#### 단계 1.변수

자바스크립트에선 실행 중인 함수, 코드 블록{...}, 스크립트 전체는 렉시컬 환경(Lexical Environment)이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.

1. 환경 레코드(Environment Record) - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체.  this값과 같은 기타 정보도 여기 저장된다.
2. 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조 - 외부 코드와 연관됨

**변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다. 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미한다.**

아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재한다.![스크린샷 2022-09-16 00.25.28](https://tva1.sinaimg.cn/large/e6c9d24egy1h67pflp5mcj20dv02qaa0.jpg)

위 그림에서 네모 상자는 변수가 저장되는 환경 레코드를 나타내고 붉은 화살표는 외부 렉시컬 환경에 대한 참조를 나타낸다. 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리키는 걸 확인할 수 있다.

이렇게 스크립트 전체와 관련된 렉시컬 환경을 **전역 렉시컬 환경**이라고 한다.

코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화한다.

좀 더 긴 코드를 살펴보자.

![스크린샷 2022-09-16 00.25.21](https://tva1.sinaimg.cn/large/e6c9d24egy1h67pfh5oymj20ez04e74i.jpg)

우측의 네모 상자들은 코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 어떻게 변화하는지 보여준다.

1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다.(pre-populated)
   - 이 때, 변수의 상태는 **특수 내부 상태인  uninitialized**가 된다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만 let을 만나기 전까진 이 변수를 참조할 수 없다.
2. let phrase는 값을 할당하기 전이기 때문에 undefined이다. phrase는 이 시점 이후부터 사용할 수 있다.
3. phrase에 값이 할당된다.
4. phrase에 값이 변경된다.



- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 환경 레코드는 현재 실행중인 함수와 코드 블록, 스크립트와 연관되어 있다.
- 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.



> 렉시컬 환경은 명세서에만 존재한다.

렉시컬 환경은 명세서에서 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 이론상의 객체이다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.

자바스크립트 엔진들은 명세서에 언급된 사항을 준수하면서 엔진 고유의 방법을 사용해 렉시컬 환경을 최적화한다. 사용하지 않는 변수를 버려 메모리를 절약하거나, 다양한 내부 트릭을 사용한다.



#### 단계 2. 함수 선언문

함수는 변수와 마찬가지로 값이다.

다만 함수 선언문(*function declaration*)으로 선언한 함수는 일반 변수와는 달리 바로 초기화 된다는 점에서 차이가 있다.

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다. 변수는 let을 만나 선언이 될 때까지 사용할 수 없지만 말이다.

선언되기 전에도 함수를 사용할 수 있는 것은 바로 이 때문이다.

아래 그림은 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여준다.

![스크린샷 2022-09-16 23.10.54](https://tva1.sinaimg.cn/large/e6c9d24egy1h68swbzvb0j20k3060dg2.jpg)

이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. `let say = function(name)`같이 함수를 변수에 할당한 함수 표현식은 해당하지 않는다.



#### 단계 3. 내부와 외부 렉시컬 환경

함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경엔 함수 호출 시 넘겨 받은 매개변수와 함수의 지역 변수가 저장된다.

say("John")을 호출하면 아래와 같은 내부 변화가 일어난다.(현재 실행 흐름은 붉은색 화살표로 나타낸 줄에 멈춰 있는 상황이다)

![스크린샷 2022-09-16 23.16.55](https://tva1.sinaimg.cn/large/e6c9d24egy1h68t2j2llvj20l504mglx.jpg)

함수가 호출중인 동안엔 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 갖게 된다. 

- 예시의 냅부 렉시컬 환경은 현재 실행 중인 함수인 say에 상응한다. 내부 렉시컬 환경엔 함수의 인자인 name으로 부터 유래한 프로퍼티 하나만 있다. say("John")을 호출했기 떄문에  name의 값은  John이 된다.
- 예시의 외부 렉시컬 환경은 전역 렉시컬 환경이다. 전역 렉시컬 환경은 phrase와 함수 say를 프로퍼티로 갖는다.

그리고 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다.

코드에서 변수에 접근할 땐 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.

전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면 엄격 모드에선 에러가 발생한다. 참고로 비 엄격 모드에서는 정의되지 않은 변수에 값을 할당하려고 하면 에러가 발생하는 대신 새로운 전역 변수가 만들어지는데, 이는 하위 호환성을 위해 남아있는 기능이다.

예시와 그림을 보면서 변수 검색이 어떻게 진행되는지 다시 정리해보자.

- 함수 say 내부의 alert에서 변수  name에 접근할 땐, 먼저 내부 렉시컬 환경을 찾아본다. 내부 렉시컬 환경에서 변수 name을 찾았다.
- alert에서 변수 phrase에 접근하려는데, phrase에 상응하는 프로퍼티가 내부 렉시컬 환경엔 없다. 따라서 검색 범위는 외부 렉시컬 환경으로 확장된다. 외부 렉시컬 환경에서  phrase를 찾았다.

![스크린샷 2022-09-16 23.24.54](https://tva1.sinaimg.cn/large/e6c9d24egy1h68tauuilbj20lj04iq3a.jpg)



#### 단계 4. 함수를 반환하는 함수

makeCounter를 다시 보자.

```javascript
function makeCounter() {
    let count = 0;
    
    return function() {
        return count++:
    };  
}

let counter = makeCounter();
```

`makeCounter()`를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에  makeCounter를 실행하는데 필요한 변수들이 저장된다. 

위쪽에서 살펴본 say("John")과 마찬가지로 makeCounter()를 호출할 때도 두 개의 렉시컬 환경이 만들어진다.

![스크린샷 2022-09-16 23.26.50](https://tva1.sinaimg.cn/large/e6c9d24egy1h68td10zj8j20l1055t96.jpg)

그런데 위쪽에서 살펴본 say("John") 예시와 makeCounter() 예시에는 차이점이 하나 있다.

makeCounter()가 실행되는 도중엔 본문(return count++);.이 한줄 짜리인 중첩 함수가 만들어진다는 것이다. 현재는 중첩함수가 생성되기만 하고 실행은 되지 않은 상태이다.

여기서 중요한 사실이 하나 있다. 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 점이다. 함수는 [Environment]라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

![스크린샷 2022-09-16 23.31.15](https://tva1.sinaimg.cn/large/e6c9d24egy1h68thglimjj20ks04oglx.jpg)

따라서 counter.[[Environment]]에는 {count:0}이 있는 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관없이 자신이 태어난 곳을 기억할 수 있는건 바로 이 [[Environment]]프로퍼티 덕분이다. 

[[Environment]] 는 함수가 생성될 때 딱 한 번 값이 세팅되고 영원히 변하지 않는다.

counter()를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성된다. 그리고 이 렉시컬 환경은 counter.[[Environment]]에 저장된 렉시컬 환경을 외부 렉시컬 환경으로서 참조한다.

![스크린샷 2022-09-16 23.54.00](https://tva1.sinaimg.cn/large/e6c9d24egy1h68u53t4xuj20kr05ot93.jpg)

실행 흐름이 중첩 함수의 본문으로 넘어오면 count 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾는다. 익명 중첩 함수에는 지역 변수가 없기  때문에 이 렉시컬 환경은 비어있는 상황이다(<empty>). 이제 counter()의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count를 찾아본다.

count는 ++되면서 count값이 1증가해야 되는데, 변수값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄진다.

따라서 실행이 종료된 후의 상태는 다음과 같다.

![스크린샷 2022-09-16 23.57.01](https://tva1.sinaimg.cn/large/e6c9d24egy1h68u88rvx1j20l105qglz.jpg)

counter()를 여러번 호출하면  count 변수가 2,3,으로 증가하는 이유가 바로 여기에 있다.

> - 클로저란?
>
> 클로저(closure)는 개발자라면 알고 있어야 할 프로그래밍 용어이다.
>
> 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다. 몇몇 언어에서는 클로저를 구현하는게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있다. 하지만 자바스크립트에서는 모든 함수가 자연스럽게 클로저가 된다(예외가 하나 있다)
>
> 요점을 정리해보면 자바스크립트의 함수는 숨김 프로퍼티인  [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억한다. 함수 본문에선 [[Environment]]를 사용해 외부 변수에 접근한다.



### 가비지 컬렉션

함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다. 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유가 바로 여기에 있다. 자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지된다.

그런데 호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이 때는 이 중첩함수의 [[Environment]]프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. 도달 가능한 상태가 되는 것이다.

함수 호출은 끝났지만 렉시컬 환경이 메모리에 유지되는 이유는 바로 이 때문이다.

- 예시

```javascript
function f() {
    let value = 123;
    
    return function() {
        alert(value);
    }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.
```

그런데 이렇게 중첩함수를 사용할 떄는 주의할 점이 있다. f()를 여러 번 호출하고 그 결과를 어딘가에 저장하는 경우, 호출시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지된다는 점이다. 아래 예시를 실행하면 3개의 렉시컬 환경이 만들어는데, 각 렉시컬 환경은 메모리에서 삭제되지 않는다.

```javascript
function f() {
    let value = Math.random();
    
    return function() { alert(value); };
}

// 배열 안의 세 함수는 각각 f()를 호출할 때 생성된 렉시컬 환경과 연관 관계를 맺는다.
let arr = [f(), f(), f()];
```

렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제 된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.

아래 예시 같이 중첩함수가 메모리에서 삭제되고 난 후에야, 이를 감싸는 렉시컬 환경(그리고 그 안의 변수인 value)도 메모리에서 제거 된다.

- 예시

```javascript
function f() {
    let value = 123;
    
    return function() {
        alert(value);
    }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아 있다.

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제된다.
```



### 최적화 프로세스

앞에서 보았듯, 함수가 살아있는 동안엔 이론상으론 모든 외부 변수 역시 메모리에 유지된다. 

그러나 실제로는 자바스크립트 엔진이 이를 지속해서 최적화 한다. 자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.

**디버깅시 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8엔진의 주요 부작용이다.**

Chrome 브라우저에서 개발자 도구를 열고 아래 코드를 실행해보고 실행이 일시 중지 되었을 때의 콘솔에  alert(value)를 입력해보자.

```javascript
function f() {
  let value = Math.random();

  function g() {
    debugger; // Uncaught ReferenceError: value is not defined가 출력
  }

  return g;
}

let g = f();
g();
```

정의되지 않은 변수라는 에러가 출력된다. 이론상으로는 value에 접근할 수 있어야 하지만 최적화 대상이 되어서 이런 에러가 발생했다.

이런 외부 변수 최적화는 흥미로운 디버깅 이슈를 발생시키곤 한다. 원인을 찾는 데 많은 시간을 허비하게 되면 흥미롭진 않긴 하다. 발생할 수 있는 상황 중 하나를 확인해보자. 예시를 실행해 의도한 변수 대신 같은 이름을 가진 다른 외부 변수가 출력되는 걸 확인한다.

```javascript
let value = "이름이 같은 다른 변수";

function f() {
  let value = "가장 가까운 변수";

  function g() {
    debugger; // 콘솔에 alert(value);를 입력하면 '이름이 같은 다른 변수'가 출력된다.
  }

  return g;
}

let g = f();
g();
```

이런  V8만의 부작용은 미리 알아놓는 것이 좋다.



## 오래된  var - ⭐️

변수를 다루는 첫 번째 장에서 3가지의 변수 선언 방법을 배웠다.

1. let
2. const
3. var

var로 선언한 변수는  let으로 선언한 변수와 유사하다. 대부분의 경우에 let을  var로 var를 let으로 바꿔도 큰 문제 없이 잘 작동한다.

하지만 var는 초기 구현 방식 때문에 let과 const로 선언한 변수와는 다른 방식으로 동작한다. 근래에는 var를 쓰지 않아서 이를 만나는 건 흔치 않은 일이지만 var는 오래된 스크립트에서 자주 볼 수 있다.

var를 사용하는 오래된 스크립트를 let으로 바꿀 때, var에 대해 제대로 모른다면 예상치 못한 에러를 만날 수 있다

### var는 블록 스코프가 없다.

var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프이다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능하다.

- 예시

```javascript
if (true) {
   var test = true; 
}

alert(test); // true, if문이 끝나도 여전히 변수에 대한 접근이 가능
```

var는 코드 블록을 무시하기 때문에 test는 전역 변수가 된다. 전역 스코프에서 이 변수에 접근할 수 있다.

두번째 행에서 var test가 아닌  let test를 사용했다면 test는 if문 안에서만 접근할 수 있다.

```javascript
if (true) {
   let test = true; 
}

alert(test); // Error: test is not defined
```

반복문에서도 유사한 일이 일어난다. var는 블록이나 루프 수준의 스코프를 형성하지 않기 때문이다.

```javascript
for(var i = 0; i < 10; i++) {
    // ...
}

alert(i); // 10, 반복문을 종료되었지만 i는 전역 변수로 여전히 접근이 가능하다.
```

**코드블록이 함수 안에 있다면 var는 함수 레벨 변수가 된다.**

```javascript
function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // if문 바깥에서도 제대로 출력
}

sayHi();
alert(phrase); // Error: phrase is not defined
```

위에서 살펴본 바와 같이  var는  if, for등의 코드블록을 관통한다. 아주 오래전 자바스크립트에서는 블록 수준 렉시컬 환경이 만들어지지 않았기 때문이다.

### var는 변수의 중복 선언을 허용한다.

한 스코프에서 같은 변수를  let으로 두 번 선언하면 에러가 발생한다.

var로 같은 변수를 여러 번 중복으로 선언할 수 있다. 이미 선언된 변수에 var를 사용하면 두 번째 선언문은 무시된다.

```javascript
var user = "Pete";

var user = "John"; // 이 var는 이전에 이미 선언되어 아무것도 하지 않는다. 에러또한 발생하지 않는다.

alert(user); // John
```



### 선언되기 전 사용할 수 있는 var

var 선언은 함수가 시작될 때 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리된다.

함수 본문 내에서 var로 선언한 변수는 선언 위치와 상관없이 함수 본문이 시작되는지점에서 정의된다. (단, 변수가 중첨 함수 내에서 정의되지 않아야 이 규칙이 적용된다.)

따라서 아래 두 예제는 동일하게 동작한다.

```javascript
function sayHi() {
  phrase = "Hello";

  alert(phrase);

  var phrase;
}
sayHi();
```

`var phrase`가 위로 이동한 것처럼 말이다.

```javascript
function sayHi() {
  var phrase;

  phrase = "Hello";

  alert(phrase);
}
sayHi();
```

코드 블록은 무시되기 때문에 아래 코드 역시 동일하게 동작한다.

```javascript
function sayHi() {
    phrase = "Hello"'
    if (false) {
      var phrase;
  }

  alert(phrase);
}
sayHi();
```

이렇게 변수가 끌어올려 지는 현상을 호이스팅(hoisting)이라고 부른다. var로 선언한 모든 변수는 함수의 최상위로 끌어 올려진다. 

바로 위 예제에서 if(false) 블록 안 코드는 절대 실행되지 않지만 이는 호이스팅에 전혀 영향을 주지 않는다. if 내부의 var는 함수 sayHi()의 시작 부분에서 처리 되므로 phrase는 이미 정의가 된 상태인 것이다.

**선언은 호이스팅이 되지만, 하지만 할당은 호이스팅이 되지 않는다.**

- 예시

```javascript
function sayHi() {
    alert(phrase);
    
    var phrase = "Hello";
}

sayHi();
```

`var phrase = "Hello"`행에서 두 가지 일이 일어난다.

1. 변수 선언(var)
2. 변수에 값을 할당(=)

변수 선언은 함수 실행이 시작될떄 처리되지만(호이스팅) 할당은 호이스팅 되지 않기 때문에 할당 관련 코드에서 처리된다. 따라서 위 예제는 아래 코드처럼 동작하게 된다.

```javascript
fucntion sayHi() {
    var phrase; // 선언은 함수 시작시 처리된다.
    
    alert(phrase); // undefined
    phrase = "Hello"; // 할당은 실행 흐름이 코드에 도달했을 때 처리된다.
}

sayHi();
```

이처럼 모든 var 선언은 함수 시작시 처리되기 때문에 var로 선언한 변수는 어디서든 참조할 수 있다. 하지만 변수에 무언가를 할당하기 전까진 값이  undefined이다.

바로 위의 두 예시에서 alert()를 호출하기 전에 변수 phrase는 선언이 끝난 상태이기 때문에 에러 없이 alert창이 뜬다. 그러나 값이 할당되기 전이기 때문에 alert창은 undefined를 출력한다.



### 즉시 실행 함수 표현식

과거엔  var만 사용할 수 있었다. 그런데 var의 스코프는 블록 레벨 수준이 아니기 때문에 개발자들은 var도 블록 레벨 스코프를 가질 수 있게 방안을 고려했는데 이때 만들어진 것이 `즉시 실행 함수 표현식(Immediately-invoked function expression)`이다. 즉시 실행 함수 표현식은 IIFE라고 부르기도 한다.

즉시 실행 함수 표현식을 요즘에는 자주 쓰지 않는다. 하지만 오래된 스크립트에서 만날 수 있기 때문에 즉시 실행 함수 표현식이 무엇인지는 알아두어야 한다.

- IIFE 예시

```javascript
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```

함수 표현식이 만들어지고 바로 호출되면서 해당 함수가 바로 실행되었다. 이 함수는 자신만의 변수를 갖고 있다.

즉시 실행 함수를 만들 땐 함수 표현식을 괄호로 둘러쌓아 ``(function {...})``와 같은 형태로 만든다. 이렇게 괄호로 둘러싸지 않으면 에러가 발생한다. 자바스크립트는  function이라는 키워드를 만나면 함수 선언문이 시작될 것이라 예상한다. 그런데 함수 선언문으로 함수를 만들 땐 반드시 함수의 이름이 있어야 한다. 따라서 아래와 같은 예시를 실행하면 에러가 발생한다.

```javascript
// 함수를 선언과 동시에 실행하려고 함
function() { // Error: Function statements require a function name
    let message = "Hello";
    
    alert(message);
}();
```

이름을 넣으면 되는게 아닌가라는 의문이 생기지만 이름을 넣어도 에러는 발생한다. 자바스크립트 자체가 함수 선언문으로 정의한 함수를 정의와 동시에 바로 호출하는 것을 허용하지 않기 때문이다.

```javascript
// 맨 아래의 괄호 때문에 문법 에러가 발생한다.
function go() {
    
}(); // 함수 선언문은 선언 즉시 호출할 수 없다.
```

함수를 괄호로 감싸면 자바스크립트가 함수를 함수 선언문이 아닌 표현식으로 인식하도록 속일 수 있다. 함수 표현식은 이름이 없어도 괜찮고 즉시 호출도 가능하다.

괄호를 사용하는 방법 말고도, 자바스크립트가 함수 표현식이라고 인식하게 해주는 다른 방법들이 있다.

```javascript
// IIFE를 만드는 방법
(function() {
  alert("함수를 괄호로 둘러싸기");
})();

(function() {
  alert("전체를 괄호로 둘러싸기");
}());

!function() {
  alert("표현식 앞에 비트 NOT 연산자 붙이기");
}();

+function() {
  alert("표현식 앞에 단항 덧셈 연산자 붙이기");
}();
```

위와 같은 방법을 사용하면 함수 표현식처럼 인식되어 바로 실행이 가능하다. 그런데 모던자바스크립트에서는 이렇게 작성을 할 필요가 없다.



### 요약

var로 선언한  변수는  let이나 const로 선언한 변수와 다른 두 가지 주요한 특성을 보인다.

1. var로 선언한 변수는 블록 스코프가 아닌 함수 수준 스코프를 갖는다.
2. var 선언은 함수가 시작되는 시점(전역 공간에선 스크립트가 시작되는 시점)에서 처리된다.

이 외에도 전역 객체와 관련된 특성 하나가 더 있다.(다음 챕터에서 공부한다.)



## 전역 객체 - 

전역 객체를 사용하면 어디서나 사용 가능한 변수나 함수를 만들 수 있다. 전역 객체는 언어 자체나 호스트 환경에 기본 내장되어 있는 경우가 많다.

브라우저 환경에선 전역 객체를 `window`, Node.js 환경에선 `global`라고 부르는데, 각 호스트 환경마다 부르는 이름은 다르다.

전역 객체의 이름을 `globalThis`로 표준화하자는 내용이 최근에 자바스크립트 명세에 추가되었기 때문에 모든 호스트 환경이 이를 따라야 한다. Chromium 기반이 아닌 몇몇 브라우저는 아직 `globalThis`를 지원하진 않지만, 이에 대한 폴리필(polyfill)을 쉽게 만들 수 있다.

이 튜토리얼에서는 브라우저 환경에서 구동되기 때문에 `window`라는 전역 객체를 사용한다. 다른 호스트 환경에서 작업하고 있다면 `window`대신 `globalThis`를 사용하면 된다.

전역 객체의 모든 프로퍼티는 아래와 같이 직접 접근할 수 있다.

```javascript
alert("Hello");
// 위와 동일하게 동작
window.alert("Hello");
```

브라우저에서 `let`이나 `const`가 아닌 `var`로 선언한 전역 함수나 전역 변수는 전역 객체의 프로퍼티가 된다.

```javascript
var gVar = 5;

alert(window.gVar); // 5 (var로 선언한 변수는 전역 객체 window의 프로퍼티)
```

하위 호환성 때문에 이런 방식으로 전역 객체를 사용해도 동작은 하지만, 이 방법은 쓰지 않는게 좋다. 모듈을 사용하는 모던 자바스크립트는 이런 방식을 지원하지 않는다.

`var` 대신 `let`을 사용하면 위 예시와는 달리 전역 객체를 통해 변수에 접근할 수 없다.

```javascript
let gLet = 5;

alert(window.gLet); // undefined (let으로 선언한 변수는 전역 객체의 프로퍼티가 되지 않는다.)
```

중요한 변수라서 모든 곳에서 사용할 수 있게 하려면, 아래와 같이 전역 객체에 직접 프로퍼티를 추가해 주어야 한다.

```javascript
// 모든 스크립트에서 현재 사용자(current user)에 접근할 수 있게 이를 전역 객체에 추가함
window.currentUser = {
  name: "John"
};

// 아래와 같은 방법으로 모든 스크립트에서 currentUser에 접근할 수 있음
alert(currentUser.name);  // John

// 지역 변수 'currentUser'가 있다면
// 지역 변수와 충돌 없이 전역 객체 window에서 이를 명시적으로 가져올 수 있음
alert(window.currentUser.name); // John
```

전역 변수는 되도록 사용하지 않는 것이 좋다. 함수를 만들 땐 외부 변수나 전역 변수를 사용하는 것보다 ‘인풋’ 변수를 받고 이를 이용해 '아웃풋’을 만들어내게 해야 테스트도 쉽고, 에러도 덜 만들어낸다.

### 폴리필 사용하기

전역 객체를 이용해 현재 사용중인 브라우저가 최신 자바스크립트 기능을 지원하는지 여부를 확인할 수 있다.

내장 객체 `Promise`를 지원하는지 여부를 아래와 같이 테스트할 수 있는데, 구식 브라우저는 `Promise` 객체를 지원하지 않기 때문에 `alert` 창이 뜰 것이다.

```javascript
if (!window.Promise) {
  alert("구식 브라우저를 사용 중이시군요!");
}
```

명세에는 있는 기능이지만 해당 기능을 지원하지 않는 오래된 브라우저를 사용하고 있다면 직접 함수를 만들어 전역 객체에 추가하는 방식으로 "폴리필"을 만들 수 있다.

```javascript
if (!window.Promise) {
  window.Promise = ... // 모던 자바스크립트에서 지원하는 기능을 직접 구현함
}
```

### 요약

* 전역 객체를 사용하면 어디서든 접근 가능한 변수를 만들 수 있다.

  전역 객체엔 `Array`와 같은 내장 객체, `window.innerHeight`(뷰포트의 높이를 반환함)같은 브라우저 환경 전용 변수 등이 저장되어 있다.

* 전역 객체는 `globalThis`라는 보편적인 이름으로 불린다.

  하지만 '관습’에 따라 브라우저에서는 `window`, Node.js에서는 `global`이라는 이름으로 불릴 때가 많다. `globalThis`는 제안 목록에 추가 된 지 얼마 안 된 기능이기 때문에, 비 크로미움 기반 브라우저에선 지원하지 않는다(폴리필을 구현하면 사용할 수 있다).

* 프로젝트 전체에서 꼭 필요한 변수만 전역 객체에 저장하도록 하고, 전역 변수는 가능한 한 최소한으로 사용하자.

* 모듈을 사용하고 있지 않다면, 브라우저에서 `var`로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.

* 이해하기 쉽고 요구사항 변경에 쉽게 대응할 수 있는 코드를 구현하려면, `window.x`처럼 전역 객체의 프로퍼티에 직접 접근한다.
