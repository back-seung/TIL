# 코어 자바스크립트 - 자바스크립트 기본

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.
>
> 



## `<script>` 태그 - ⭐

HTML 문서 대부분의 위치에 삽입할 수 있는 태그

태그 안에는 자바스크립트 코드가 들어간다. 브라우저는 이 태그를 만났을 때 코드를 자동으로 처리한다.

```javascript
<!DOCTYPE HTML>
<html>

<body>

  <p>스크립트 전</p>

  <script>
    alert( 'Hello, world!' );
  </script>

  <p>스크립트 후</p>

</body>

</html>
```



### 모던 마크업

* `<script type ="text/javascript">` - HTML4에서는 스트립트에 타입을 명시하는 것이 필수였지만 현대에서는 타입 명시가 필수가 아니다.
* `<script language=...>` - 현재 사용하고 있는 스크립트 언어를 나타내지만 JavaScript가 기본언어 이므로 속성의 의미가 퇴색된 상황이라 사용할 필요가 없어졌다.
* `스크립트 전후에 위치한 주석` - 태그 옆에 붙은 주석은 스크립트 태그를 처리하지 못하는 브라우저가 해당 스크립트를 읽지 못하게 하려고 사용했지만 15년 간 출시된 브라우저는 모두 script 태그를 처리할 수 있기 때문에 아주 오래된 코드라는 것을 알 수 있다.



### 외부 스크립트

>  JavaScript 코드의 양이 많을 경우엔 파일로 소분하여 저장할 수 있다. 파일의 확장자는 `.js`이다.

* 소분된 파일은 src 속성을 사용해 HTML에 삽입한다.
  * src의 값에는 경로를 지정할 수 있는데 `절대경로`, `상대경로`, `URL`로 값을 줄 수 있다.
* 소분된 파일이 1개 이상일 경우에는 파일 당 처리할 script 태그를 추가하면 된다.

```javascript
<script src ="../../hello.js"></script>
<script src ="path/script/hello.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
```

* `<script>` 태그에 src 속성이 추가된 경우에는 내부의 코드는 무시된다.

```javascript
<script src ="../../hello.js">
	alert("hello world"); // src 속성이 사용되어 무시된다.
</script>
```



### 소분을 하는 이유?

* HMTL에 직접 코드를 작성하는 경우는 스크립트가 짧고 간단한 경우이다.

*  반대로 스크립트의 양이 많아질 때 소분하여 파일로 저장하게 되면 브라우저가 이를 캐시에 저장하기 때문에 성능상 이점이 생긴다.

  * 여러 페이지에서 동일한 스크립트를 사용할 때 HTMl에서 다시 가져오는 것이 아니라 브라우저 내의 캐시에서 저장된 스크립트를 가져와 사용한다 -> 트래픽이 절약된다. -> 웹 페이지의 속도가 빨라진다.

    

## 코드 구조 - ⭐

> 문, 세미콜론, 주석에 대해 배운다.



### 문

어떤 작업을 수행하는 문법 구조(*Syntax Structure*)와 명령어(*command*)를 의미한다.

서로 다른 문을 가진 경우 세미콜론(`;`)으로 구분한다.

```javascript
alert("hello);
alert("world");
```



### 세미콜론

줄 바꿈이 있다면 세미콜론(`;`)을 생략할 수 있다. 생략이 가능한 이유는 자바스크립트는 줄 바꿈이 발생하면 암시적 세미콜론으로 해석하기 때문인데, 이를 **세미콜론 자동 삽입**이라고 부른다.

```javascript
alert("hello)
alert("world")
```

하지만

* 세미콜론이 필요하지만 자바스크립트가 이를 추정하지 못하는 경우가 발생한다.

```javascript
alert("오류가 발생한다")
[1,2].forEach(alert)
```

위 코드는 다음과 같이 인식된다.

```javascript
alert("오류가 발생한다")[1,2].forEach(alert)
```

대괄호`[]` 앞에 `;`이 붙지 않은 상태인 단일문으로 인식하기 때문에 의도와 다르게 에러가 발생하게 되는 것이다. 

따라서

* 줄바꿈이 있을 때(문과 문 사이)는 세미콜론을 추가하여 문이 끝났음을 명시하자.



### 주석

주석은 프로그래머가 코드에 대해 설명하는데에 많이 사용한다. 주석을 작성하면 코드의 양이 늘어나는 것처럼 보이지만 배포하기 전에 코드를 압축해주는 도구가 많이 있고 이 도구는 주석을 삭제해주기 때문에 전혀 문제될 것이 없다.

* 주석은 스크립트 어느 곳에서나 작성할 수 있다. 자바스크립트 엔진은 주석을 무시하기 때문에 위치가 실행에 영향을 주지 않는다.

* 1줄 짜리 주석에는 `//`를 사용하며, 여러 줄 주석에는 `/**/`를  사용한다.



## 엄격 모드

자바스크립트는 꽤 오랫동안 호환성 이슈가 없었는데 ECMAScript5(ES5)가 등장하고 나서는 기존 기능 중 일부가 변경되었다. 기존 기능의 변경은 하위 호환성의 이슈를 발생시킨다.

그래서 변경사항 대부분은 ES5의 기본 모드에서 활성화되지 않도록 설계되었고, 대신 `usestrict`라는 특별 지시자를 사용해 엄격 모드를 활성화 했을 때는 변경사항이 활성화 되게 하였다.



### use strict

* `"use strict" || 'use strict'`를 스크립트 최상단에 작성하면 스크립트가 모던한 방식으로 동작한다.

```javascript
'use strict';
```

* 최상단이 아닌 다른 곳에 위치하면 엄격 모드가 적용되지 않음을 주의하자.

```javascript
alert("hello world");

"use strict"; // 엄격 모드가 활성화되지 않는다.
```

* 엄격모드가 적용되면 이를 취소할 방법은 없다.



### 브라우저 콘솔

브라우저 콘솔에서는 use strict가 기본으로 적용되어있지 않다. 만약 사용을 원한다면 'use strict';를 입력하고 `Shift + Enter`로 줄바꿈을 한뒤 원하는 코드를 작성하여 기대한 값을 얻어내면 된다.



### 그럼 항상 스크립트 상단엔 use strict를 적어야 할까?

코드를 **클래스(class)와 모듈(import)로 사용하여 구성한다면 use strict를 생략해도 된다**(자동으로 적용된다)





##  변수와 상수 - ⭐

> 변수는 데이터를 저장할 때 쓰이는 이름이 붙은 저장소의 개념이다. 자바스크립트에서는 let을 사용하여 변수를 생성한다.

```javascript
let message;

message = 'hello'; // 문자열 저장
message = 1; // 정수형 저장
```

* `var`를 사용하는 경우도 있는데 이건 오래된 버전에서의 JavaScript에서 사용된 방법이다.



### 변수 명명 규칙

* $, _을 제외한 특수문자는 사용할 수 없다.
* 일반적으로 카멜표기법을 사용한다. Ex) MyFirstName
* 숫자가 첫 글자로 올 수 없다.
* 예약어를 사용할 수 없다.
* 변수명은 영어로 사용하는 것을 권장한다.



### 상수

변화하지 않는 값인 상수는 `let`대신 `const`를 사용한다. 

```javascript
const jumin = '980521-1234567';s
```

* `const`로 선언한 상수를 변경하려고 하면 에러가 발생한다.



### 대문자 상수

기억하기 힘든 값을 변수에 할당해 별칭으로 사용한다. 대개 `대문자 + _`의 형태로 사용하는 것이 관습이다.

```javascript
const COLOR_RED = "#F00";
```

* 대문자를 사용하여 명명하는 상수는 언제 사용하는 걸까? 
  * 상수는 두 가지로 나눌 수 있다.
    1. 코드 실행전에 값을 이미 알 수 있는 상수 - 원주율, 지구의 지름 등
    2. 런타임 과정에서 계산되어 최초 할당되어 값이 바뀌지 않는 상수 - 페이지 로드 시간
  * 대문자를 사용하는 상수는 2의 경우에 해당한다



## 자료형 - ⭐

> 자바스크립트에서 값은 항상 문자열 || 숫자형 같은 특정한 자료형에 속한다.

- 자바스크립트는 8가지의 자료형이 있다.
- 자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있다. 따라서 변수가 문자열이 될 수도 있고 다른 순간에는 숫자가 될 수도 있다.



```javascript
let message = "hello";
message = 12345;
```

이처럼 자료의 타입은 있지만 변수에 저장되는 값의 타입이 언제든지 바뀔 수 있는 언어를 `동적 타입 언어`라고 부른다.



### 숫자형

숫자형은 정수 및 부동소수점 숫자를 나타낸다.

숫자형과 관련된 연산은 다양한데 대표적으로 +, -, /, * 등이 있다.

일반적인 숫자 외에 -Infinity, Infinity, NaN같은 특수 숫자 값이 포함된다.



### BigInt

내부 표현 방식 때문에 자바스크립트에서는 아주 큰 값을 숫자형으로 나타낼 수 없다. 이럴 때는 BigInt를 사용하여 길이에 상관없이 정수를 나타낼 수 있다. BigInt는 숫자 마지막에 `n`을 입력하면 만들 수 있다.

```javascript
let bigInt = 3245342509812375981347598014237509n;
```



### 문자형

자바스크립트에서는 문자열을 따옴표로 묶는다. 따옴표는 총 3가지로 큰 따옴표, 작은 따옴표, 백틱을 사용한다.

- 자바스크립트는 큰 따옴표와 작은 따옴표의 차이를 두지 않는다.
- 백틱은 변수 또는 표현식을 감싼 후, `${}`안에 넣어주면 원하는 변수, 표현식을 문자열 중간에 쉽게 넣을 수 있게 한다.
- 문자열 중간에 들어간 `${}`은 평가가 끝난 후 문자열의 일부가 된다.

```javascript
let name = "John";
alert("Hello `${name}`!"); 
alert("The result is `${1 + 2}`"); // 3
```



### boolean

boolean은 논리형 타입으로 true, false만 존재한다.



### null

어느 자료형에도 속하지 않는다. null값은 오로지 null 값만 포함하는 별도의 자료형을 만든다.

- 자바스크립트의 null은 다른 언어의 null과는 성격이 다르다. 다른 언어에서는 null을 ***존재하지 않는 객체에 대한 참조*** 또는 ***널 포인터***를 나타낼 때 사용한다.
- 자바스크립트에서의 null은 ***존재하지 않는 값, 비어있는 값, 알 수 없는 값***을 나타내는데 사용한다.

### undefined

null처럼 자신만의 자료형을 형성한다

- 값이 할당되지 않은 상태를 나타낼 때 사용한다.
- 변수는 선언했지만 초기화는 되지 않은 상태에 자동으로 할당된다.
- 개발자가 명시적으로 할당을 할 수도 있지만 권하지는 않는다.



### 객체와 심볼

객체(object)형은 특수한 자료형이다.

- 객체를 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시형(Primitive type)이라고 불린다.
- 객체는 데이터 컬렉션이나 복잡한 개체(Entity)를 표현할 수 있다.

- 심볼(Symbol)형은 객체의 고유한 식별자를 만들 때 사용된다.



### typeof 연산자

typeof는 인수의 자료형을 반환한다. 자료형에 따라 처리방식을 다르게 하고 싶거나 자료형을 빠르게 알아내고자 할 때 유용하다.

- typeof는 두가지의 방법으로 사용할 수 있다.
  - 연산자 : typeof x
  - 함수 : typeof(x)
- 둘 중 무엇을 사용하든 결과는 같다. typeof의 결과값은 x의 자료형을 나타내는 문자열을 반환한다.



## alert, prompt, confirm을 이용한 상호작용 - ⭐



### alert

```javascript
alert("Hello");
```

모달창을 띄워 확인 버튼을 누를 때까지 메시지를 보여주는 창을 띄운다.



### prompt

브라우저에서 제공하는 prompt는 2개의 인수를 받는다. 

```javascript
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
```



### confirm

매개변수로 받은 질문과 확인 및 취소 버튼이 있는 모달창을 보여준다. 확인(true), 취소(false)

```javascript
let isBoss = confirm("당신이 주인인가요?");

alert( isBoss ); // 확인 버튼을 눌렀다면 true가 출력됩니다.
```



## 형 변환 - ⭐

### 문자형으로 변환

String(value)를 사용하여 문자열로 변환한다.

```javascript
let value = true;
alert(typeof value); // boolean

value = String(value); // "true"
alert(typeof value) // string
```



### 숫자형으로 변환

숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.

- 숫자형 값으로 바꾸기 위해서는 Number(value)를 사용한다.

- 숫자 이외의 글자가 포함된 문자열을 숫자로 변환하려고 하면 NaN을 반환한다.

```javascript
alert( "6" / "2" ); // 3, 문자열이 숫자형으로 자동변환된 후 연산이 수행됩니다.

let str = "123";
alert(typeof str); // string

let num = Number(str); // 문자열 "123"이 숫자 123으로 변환됩니다.

alert(typeof num); // number

let age = Number("임의의 문자열 123");

alert(age); // NaN, 형 변환이 실패합니다.
```



* 숫자형으로 변환시 적용되는 규칙

| 전달받은 값    | 형 변환 후                                                   |
| -------------- | ------------------------------------------------------------ |
| `undefined`    | `NaN`                                                        |
| `null`         | `0`                                                          |
| `true / false` | `1 / 0`                                                      |
| `string`       | 전달받은 문자열을 “그대로” 읽되, 처음과 끝의 공백을 무시합니다. 문자열이 비어있다면 `0`이 되고, 오류 발생 시 `NaN`이 됩니다. |



### Boolean으로 변환

Boolean(value)을 사용하여 true, false를 반환하는데 다음의 규칙을 따른다.

| 전달받은 값                           | 형 변환 후 |
| :------------------------------------ | :--------- |
| `0`, `null`, `undefined`, `NaN`, `""` | `false`    |
| 그 외의 값                            | `true`     |



## 기본 연산자와 수학 - ⭐

### 거듭 제곱 연산자 - **

a ** b를 평가하면 a를 b번 곱한 값이 반환된다.

```javascript
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```



### 단항 연산자 +와 숫자형으로의 변환

덧셈 연산자는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있다.

숫자에 단항 덧셈연산자를 붙히면 아무일도 일어나지 않지만, 숫자가 아닌 다른 타입에서는 이를 숫자형으로 변환한다.

```javascript
// 숫자에는 아무런 영향을 미치지 않습니다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
```

HTML 폼 등에서 입력한 숫자는 대게 문자열로 인식되는데 이 때 이항 덧셈 연산자를 사용하면 문자열로 변해서 연결된다. 하지만 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변환시키면 된다.

```javascript
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5
```



### 쉼표 연산자

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야 한다.

- 쉼표의 연산 우선순위는 매우 낮다.

```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```



## 비교 연산자 - ⭐⭐

### 일치 연산자 - ===

일치 연산자는 엄격한 동등 연산자이다.

- 자료형의 동등 여부까지 검사한다. 따라서 값이 같아도 자료형이 다르면 false를 반환한다.
- 일치 연산자의 반대인 불일치 연산자 !==는 부등 연산자의 엄격한 버전이다.



### null이나 undefined 비교

- 일치 연산자(===)를 사용하여 null과 undefined 비교

```javascript
alert( null === undefined ); // false
```

- 동등 연산자(==)를 사용하여 null과 undefined 비교

```javascript
alert( null == undefined ); // true
```

동등 연산자는 null과 undefined를 비교하면 특별한 규칙이 적용돼 true가 반환된다. 동등 연산자는 null과  defined를 각별한 커플처럼 취급한다. 서로는 잘 어울리지만, 다른 값들과는 잘 어울리지 못한다.



### null과 0비교

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

1과 2는 false를 반환하지만 3은 true를 반환하는 이유가 뭘까?

- 이런 결과가 나타나는 이유는 동등 연산자 `==`와 기타 비교 연산자 `<`, `>`, `<=`, `>=`의 동작 방식이 다르기 때문이다. 
- 1에서 `null > 0`이 거짓을, 3에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문이다.
- 동등 연산자(==)는 피연산자가 undefined, null일 때는 형 변환을 하지 않는다. undefined, null을 서로 비교할 때만 true를 반환하고 그 이외의 경우에는 false를 반환한다.

### undefined와의 비교

undefined를 null을 제외한 다른 값과 비교하면 무조건 false를 반환한다.



## nullish 병합 연산자 '??'

nullish 병합 연산자를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 확정되어있는 변수를 찾을 수 있다.

- a ?? b의 결과
  - a가 null도 아니고 undefined도 아니면 a
  - 그 외의 경우는 b
- nullish 병합 연산자 없이 x = a ?? b와 동일한 동작을 하는 코드 예제

```javascript
x = (a !== null && a !== undefined) ? a : b;
// == 
a ?? b;
```



### '??'과 '||'의 차이

nullish는 병합 연산자 `||`와 상당히 유사해보인다. 하지만 두 연산자 사이에는 중요한 차이가 있다.

- `||`는 첫 번째 truthy값을 반환한다.
- `??`는 첫 번째 정의된 값을 반환한다.

위 차이점은 null과 undefined, 숫자 0을 구분지어 다뤄야 할 때 매우 중요한 역할을 한다. 

* 예시

```javascript
let height = 0;

height = height ?? 100; // null, undefined가 아니면 height

alert(height || 100); // 100
alert(height ?? 100); // 0
```

`height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리한다. 따라서 `height || 100`의 평가 결과는 `100`이다.

반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 된다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 alert창엔 `0`이 출력된다.

> 0이 할당될 변수를 사용하여 개발할 땐 `??`가 적합하다.



### 요약

- nullish 병합 연산자 ??를 사용하면 피연산자 중 값이 할당된 변수를 빠르게 찾을 수 있다.
- ??는 변수에 기본값을 할당하는 용도로 사용할 수 있다.(변수가 null, undefined가 아닐 때 기본값을 사용)





## while과 for 반복문 - ⭐

### while

```javascript
while(조건) {
    ...
}
```

조건이 true일 때 반복문안의 코드가 실행된다.

### do-while

```javascript
do {
    ...
} while(조건);
```

최소한 한번이라도 실행하고 싶을 때만 사용해야 한다. do안의 본문이 먼저 실행되고 조건(true인지)을 확인하기 떄문이다.

### for

```javascript
for(시작; 조건; 증감연산자) {
    본문
}
```

1. 시작으로 한 차례 실행된다.
2. 조건을 확인하고 본문을 실행한뒤 증감연산자를 실행한다.
3. 조건이 false일 때까지 2반복



### 반복문 빠져나오기

- break를 사용하면 조건문을 바로 종료한다.



### 다음 반복으로 넘기기

* 반복문 실행 중 continue에 맞는 조건을 만나면 전체 반복을 멈추지 않으며 해당 본문만을 실행하지 않고 다음 반복문으로 넘어간다.



## switch문 - ⭐

복수의 if 조건문은 switch문으로 바꿀 수 있다.

switch문을 사용하면 특정 변수를 다양한 상황에서 비교할 수 있게 해준다.

```javascript
switch(x) {
    case 'value1':
        ...
        [break]
    case 'value2':
        ...
        [break]
    default:
}
```



## 함수 - ⭐⭐

스크립트 작성 시 유사한 동작을 하는 코드가 여러 곳에서 필요할 때가 있다(중복된 코드의 함수화).

함수는 프로그램을 구성하는 주요 구성요소이다. 함수를 이용하면 중복없이 유사한 동작을 하는 코드를 여러번 호출할 수 있다.



### 함수 선언

함수 선언 방식은 아래와 같이 작성할 수 있다.

```javascript
function showMessage() {
    alert("안녕하세요");
}
```

function 키워드, 함수이름, 괄호도 둘러싼 매개변수를 차례로 써주면 함수를 선언할 수 있다.



### 지역변수와 외부변수

- 지역변수 : 함수 내에서 선언한 변수인 지역변수는 함수 안에서만 접근이 가능하다.
- 외부 변수 : 함수 내부에서 외부의 변수인 외부 변수에 접근할 수 있다.

```javascript
// 지역 변수
function showMessage() {
	let message = "안녕하세요";
}

showMessage();

alert(message); // 에러. message는 함수 내 지역변수이다.

// 외부 변수
let userName = 'John';

function showMessage() {
    let message = 'Hello' + userName;
    alert(message);
}

showMessage(); // Hello John
```



### 매개변수

매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다.

```javascript
function showMessage(from, text) {
    alert(from + " : " + text);
}

showMessage("Ahn", "Hello");
```

- 전역 변수 from을 따로 설정하고 함수 내에서 값을 수정하면 전역 변수의 값은 변하지 않는다.

```javascript
function showMessage(from, text) {
    from = "*" + from + "*"
    alert(from + " : " + text);
}
let from = "Ahn"
showMessage(from, "Hello"); // *Ahn* Hello

alert(from); // Ahn
```



### 기본값

매개변수에 값을 전달하지 않을 때 그 값은 에러가 아닌 undefined가 할당된다. undefined가 되지 않게 하려면 기본값을 설정하면 되는데 매개변수 오른쪽에 `=`을 사용하여 설정해줄 수 있다.

```javascript
function showMessage(from, text= "no text given") {
    alert(from + " : " + text);
}

showMessage("Ahn"); // Ahn : no text given
```

- 조건문을 통해서 기본값을 지정해 줄수도 있다.

```javascript
function showMessage(text) {
    if(text == undefined) {
        text = "빈 문자열";
    }
    alert(text);
}

showMessage(); // 빈 문자열
```



### 반환

함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환할 수 있다(return). 반환값은 어디서든 사용할 수 있다.

```javascript
function sum(a, b) {
    return a + b;
}

let result = sum(1,3);

alert(result); // 4
```



### 함수 이름짓기 

함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것이다. 따라서 함수의 이름은 대개 동사이다. 작성한 사람이 아닌 다른 사람이 함수를 보고 이런 동작을 하겠구나 유추가 가능해야한다.

그리고 함수는 동작 하나만 담당해야 한다.



### 함수 == 주석

함수는 간결하고 한 가지 기능만 수행할 수 있게 해야한다. 그러므로 함수의 코드가 길어지면 그건 잘게 쪼갤 때가 되었다는 신호로 받아들여야 한다. 

함수를 간결하게 만들면 디버깅, 테스트가 쉬워진다. 그리고 함수 그자체가 주석의 역할까지한다. 



## 함수 표현식 - ⭐⭐

자바스크립트는 함수를 특별한 종류의 값으로 취급한다. 다른 언어에서처럼 "특별한 동작을 하는 구조"로 취급되지 않는다.

자바스크립트는 함수 선언 방식 외에 함수 표현식을 사용해서 함수를 만들 수 있다.



- 함수 선언문(Function Declaration)

```javascript
function sayHi() {
  alert("Hello");
}
```

- 함수 표현식(Function Expression)

```javascript
let sayHi = function() {
  alert("Hello");
};
```

함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었다. 함수가 어떤 방식으로 만들어졌는지에 관계없이 함수는 값이 되어 변수에 할당할 수 있다.

함수는 값이기 때문에 alert()를 통해 코드를 출력할 수도 있다.

```javas
function sayHi() {
  alert("Hello");
};

alert(sayHi);
```

마지막 줄에서 `()`가 없기 때문에 함수는 실행되지 않는다. 자바스크립트는 괄호가 있어야 함수가 호출된다.

자바스크립트에서 함수는 값이다. 따라서 함수를 값처럼 취급할 수 있다. 위 코드를 실행할 때 코드가 문자형으로 바뀌어 출력된 것처럼 말이다.



함수는 값이기 때문에 함수를 복사할 수도 있다.

```javascript
function sayHi() {
  alert("Hello");
}

let func = sayHi;

func();
sayHi();
```



### 콜백 함수

매개변수가 3개 있는 함수를 작성해본다.

```javascript
funciton asK(question, yes, no) {
  if(confirm(question)) {
   	yes(); 
  } else {
    no();
  }
}

function showOK() {
  alert("동의하셨습니다.");
}

function showCancel() {
  alert("취소 버튼을 누르셨습니다");
}

ask("동의하십니까?", showOK, showCancel);
```

함수 ask의 인수, showOK와 showCancel은 콜백 함수 또는 콜백이라고 불린다.

함수를 함수의 인자로 전달하고 필요하다면 인수로 전달한 그 함수를 **나중에 호출하는 것**이 콜백의 개념이다.

함수 표현식으로 위 코드의 길이를 줄일 수도 있다.

```javascript
funciton asK(question, yes, no) {
  if(confirm(question)) {
   	yes(); 
  } else {
    no();
  }
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다"); }
);
```

ask안에 함수를 선언했는데 이름 없이 선언한 함수는 익명 함수라고 부른다. 익명 함수는 ask 바깥에선 접근할 수 없다.

> 함수는 동작을 나타내는 값이다.
>
> - 문자열이나 숫자 등의 일반적인 값들은 *데이터*를 나타낸다.
> - 함수는 하나의 *동작*을 나타낸다.
> - 동작을 대변하는 값인 함수를 변수 간 전달하고 동작이 필요할 때 이 값을 실행할 수 있다.



### 함수 표현식 vs 함수 선언문

둘의 차이에 대해 알아본다.

1. 문법

   - 함수 선언문 : 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재

   ```javascript
   function sum(a, b) {
     return a + b;
   }
   ```

   - 함수 표현식 : 함수는 표현식이나 구문 구성 내부에 생성된다. 

   ```javascript
   let sum = function(a, b) {
     return a + b;
   };
   ```

2. 자바스크립트 엔진이 함수를 생성하는 시기

   - 함수 선언문 : 선언문이 정의되기 전에도 호출이 가능하다. 이유는 자바스크립트가 스크립트 실행 전 준비 단계에서 전역에 선언된 함수 선언문을 찾고 해당 함수를 생성하기 때문인데, 스크립트가 진짜 실행되기 전 초기화 단계에서 함수 선언 방식으로 정의한 함수가 생성되는 것이다. 스크립트는 함수 선언문의 처리가 된 이후에 실행된다.
   - 함수 표현식 : 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다

- 스코프

  - 함수 선언문 : 엄격모드에서 코드 블록내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.

  ```javascript
  let age = prompt("나이를 알려주세요.", 18);
  
  // 조건에 따라 함수를 선언함
  if (age < 18) {
  
    function welcome() {
      alert("안녕!");
    }
  
  } else {
  
    function welcome() {
      alert("안녕하세요!");
    }
  
  }
  
  // 함수를 나중에 호출함.
  welcome(); // Error: welcome is not defined
  ```

  선언된 코드 블록 내에서만 유효하기 때문에 에러가 발생한다.

  

  - 함수 표현식 : if문 밖에서 welcome 함수를 호출할 방법을 함수 표현식을 사용하여 해결할 수 있다.

  ```javascript
  let age = prompt("나이를 알려주세요", 18);
  
  let welcome;
  
  if(age < 18) {
    welcome = function() {
      alert("안녕!");
    };
  } else {
    welcome = function() {
      alert("안녕하세요");
    };
  }
  
  welcome(); // 정상 작동
  ```

  물음표 연산자 ? 를 사용하면 좀 더 단순화할 수 있다.

  ```javascript
  let age = prompt("나이를 알려주세요", 18);
  
  let welcome = (age < 18) ? 
      function() { alert("안녕"); } :
  		function() { alert("안녕하세요"); };
  
  welcome();
  ```

  

### 요약 

- 함수는 값이다. 따라서 함수도 할당, 복사, 선언할 수 있다.
- 함수 선언 방식으로 함수를 생성하면 함수가 독립된 구문 형태로 존재하게 된다.
- 함수 표현식 방식으로 함수를 생성하면 함수가 표현식의 일부로 존재하게 된다.
- 함수 선언문은 코드 블록이 실행되기도 전에 처리된다. 따라서 블록 내 어디서든 활용이 가능하다.
- 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다.
