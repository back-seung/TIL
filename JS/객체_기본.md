# 코어 자바스크립트 - 객체: 기본

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.

## 객체 - ⭐⭐⭐

자바스크립트에는 8가지 자료형이 있다. 이 중 7개는 오직 하나의 데이터만 담을 수 있어 원시형(Primitive Type)이라고 한다.

그러나 객체형은 원시형과 다르게 다양한 데이터를 담을 수 있다. 키로 구분된 데이터 집합이나 복잡한 객체를 저장할 수 있다. 

자바스크립트를 잘 다루려면 객체를 잘 이해하고 있어야 한다.

객체는 중괄호`{}`를 이용해 만들 수 있다. 중괄호 안에는 `키 : 값`이 쌍으로 이루어진 프로퍼티를 여러개 넣을 수 있다.

- 키 : 문자열만 넣을 수 있다.
- 값 : 모든 자료형이 허용된다.



빈 객체를 생성하는 방법은 두가지가 있다.

```javascript
let user = new Object(); // 객체 생성자
let user = {};	// 객체 리터럴
```

객체를 선언할 땐 주로 객체 리터럴 방법을 사용한다.



### 리터럴과 프로퍼티

```javascript
let user {
  name: "John",
  age: 30
};
```

콜론을 기준으로 왼쪽에는 키 오른쪽에는 값이 위치한다. 

현재 객체 user에는 두 가지의 프로퍼티가 있다.

개발자는 프로퍼티를 추가, 삭제 할 수 있으며 `.`을 사용하여 프로퍼티 값을 읽는 것도 가능하다.

```javascript
alert(user.name); // John
alert(user.age);	// 30
```

프로퍼티를 추가할 수도 있다.

```javascript
user.isAdmin = true; // 불린형을 추가하였다
```

delete 연산자를 사용하여 삭제할 수도 있다.

```javascript
delete user.age;

alert(user.age); // undefined
```

여러개의 단어로 사용해 프로퍼티 이름을 만들 땐 따옴표로 감싸야 한다. 또한 마지막 프로퍼티 끝에는 `,`로 끝낼 수 있다.

```javascript
let user {
  name: "John",
  age: 30,
	"likes birds": true,
};
```



#### 상수 수정 주의점

```javascript
const user = {
	name: "John"
};

user.name = "Pete"; // O

user = ...; // X
```

객체 안의 프로퍼티는 수정할 수 있음을 주의하자. 

하지만 객체 그 자체를 수정하려고 하면 에러가 난다.



### 대괄호 표기법

여러 단어를 조합해 프로퍼티 키를 만든 경우, 점 표기법을 사용해 프로퍼티 값을 읽을 수 없다. 자바스크립트는 점 표기법에서 공백을 인식하지 못하기 떄문이다.

```
user.likes birds = true; // 문법 에러
```

이럴땐 대괄호 표기법을 사용해야 한다.

```javascript
user["likes birds"] = true;
```

대괄호 표기법을 사용하면 변수를 키로 사용한 것과 같이 문자열 뿐 아니라 모든 표현식의 평과 결과를 프로퍼티 키로 사용할 수 있다.

```javascript
let key = "likes birds";
user[key] = true;
```

변수 key는 런타임에 평가되기 때문에 사용자 입력값 변경 등에 따라 값이 변경될 수 있다. 어떤 경우든 평가가 끝난 이후의 결과가 프로퍼티 키로 사용된다. 이를 통해 코드를 유연하게 작성할 수 있다.

```javascript
let user = {
  name: "John",
  age: 30
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

// 변수로 접근
alert(user[key]); // John 프롬프트 창에 name을 입력한 경우
```

하지만 점 표기법은 이런 방식이 불가능하다.

### 계산된 프로퍼티

`계산된 프로퍼티` - 객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우를 말한다.

- 예

```javascript
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온다.
};

alert(bag.apple); // fruit에 apple이 할당 되었다면 5가 출력된다.
```

`[fruit]`는 프로퍼티 이름을 변수 fruit에서 가져오겠다는 의미이다. 사용자가 프롬프트 대화상자에 apple을 입력했다면 bag엔 {apple: 5}가 할당되었을 것이다. 아래처럼 말이다.

```javascript
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {};

// 변수 fruit을 이용해 프로퍼티 이름을 만들었다.
bag[fruit] = 5;
```

- 또다른 예시

```javascript
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력하다. 하지만 작성하기 번거롭다.

일반적으로 단순한 프로퍼티 이름을 사용할 땐, 점 표기법을 사용하다가 복잡한 상황이 발생했을 때 대괄호 표기법으로 바꾸는 경우가 많다. 



### 단축 프로퍼티

실무에서는 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 종종 있다.

```javascript
function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...등등
  };
}

let user = makeUser("John", 30);
alert(user.name); // John

```

- 프로퍼티 값 단축 구문을 사용하여 코드를 짧게 줄일 수 있다.

```javascript
function makeUser(name, age) {
  return {
    name, // name: name과 같다
    age, 	// age: age와 같다.
    // ...
  };
}
```

- 한 객체에서 일반 프로퍼티와 단축 프로퍼티를 함께 사용하는 것도 가능하다.

```javascript
let user = {
  name, // name: name과 같음
  age: 30
};
```



### 프로퍼티 이름의 제약사항

변수에서는 예약어를 사용하면 안된다. 하지만 프로퍼티엔 이런 제약이 없다(*\_\_proto\_\_*를 제외하고).

- 객체의 프로퍼티 이름은 예약어를 사용해도 제약이 없다.

```javascript
// 예약어를 키로 사용해도 괜찮습니다.
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
```

- 숫자 0을 넣으면 문자열 "0"으로 자동 변환된다.

```javascript
let obj = {
  0: "test",
};

alert(obj[0]); // "test"
alert(obj["0"]); // "test"
```



### 'in' 연산자로 프로퍼티 존재 여부 확인

선언되지 않은 객체에 접근하면 에러가 아닌 `undefined`를 반환한다.

```javascript
let user = {};

alert(user.noSuchProperty === undefined); // true는 프로퍼티가 존재하지 않음을 의미한다.
```

`in`을 사용하여 존재 여부를 쉽게 확인할 수 있다.

```javascript
"key" in object // 문법

let user = {
	name: "John",
  age: 30
};

alert("age" in user); // true
alert("hello" in user); // false
```

`in` 왼쪽엔 프로퍼티 이름(따옴표 포함)이 와야 한다. 따옴표를 생략하면 엉뚱한 변수가 조사 대상이 된다.

#### undefined로 비교하지 않고 in 연산자를 사용하는 이유

프로퍼티는 존재하는데 값이 undefined인 경우를 살펴보자

```javascript
let user = {
	test: undefined
};

alert(obj.test); // undefined;
alert("test" in obj); // true
```

실제 존재하는 프로퍼티이다. 따라서 in 연산자는 정상적으로 true를 반환한다.

하지만 undefined는 변수가 정의되었지만 값이 할당되지 않은 경우에 쓰기 때문에 프로퍼티 값이 undefined인 경우는 흔치 않다. 값을 알 수 없거나 비어있을 때는 null을 주로 사용한다. 예시가 좀 이상하다(라고 튜토리얼에서 말한다).



### for...in 반복문

`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있다.

- 문법

```javascript
for (key in object) {
  // 각 프로퍼티 키를 이용하여 본문을 실행한다.
}
```

- 예시

```javascript
let user = {
    name: "A",
    age: 30,
    sex: "M"
};

for(let key in user) {
    alert(key);
    alert(user[key]);
}
```

변수명은 굳이 key를 쓰지 않아도 괜찮다.



### 객체 정렬 방식

객체는 특별한 방식으로 정렬된다. 정수 프로퍼티는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서대로 정렬된다.

- 예시

```javascript
let codes = {
  "49": "독일",
  "41": "스위스",
  "44": "영국",
  // ..,
  "1": "미국"
};

for(let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```

- 정수 프로퍼티 - 변형 없이 정수에서 왔다 갔다 할 수 있는 문자열
  - 문자열 "49"는 숫자로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 변형이 없기 때문에 정수 프로퍼티이다. 하지만 +49, '1.2'등은 정수 프로퍼티가 아니다.


한편 키가 정수가 아닌 경우엔 작성된 순서대로 프로퍼티가 나열된다.

```javascript
let user = {
    name: "John",
    surname: "Smith"
};

user.age = 25; // 프로퍼티 추가

// 정수 프로퍼티가 아닌 프로퍼티는 추가된 순서대로 나열된다
for(let prop in user) {
 	alert(prop); // name, surname, age   
}
```

위 예시에서 49를 가장 위에 출력되게 하려면 나라 번호가 정수로 취급되지 않도록 속임수를 쓰면 된다.

```javascript
let codes = {
  "+49": "독일",
  "+41": "스위스",
  "+44": "영국",
  // ..,
  "+1": "미국"
};

for(let code in codes) {
  alert(code); // 49, 41, 44, 1
}
```

이제 원하는 대로 독일 나라 번호가 가장 먼저 출력되는 것을 알 수 있다.



### 요약

객체는 몇 가지 특수한 기능을 가진 연관 배열이다.

객체는 프로퍼티(키-값)를 저장한다.

- 프로퍼티 키는 문자열이나 심볼이어야 한다. 보통은 문자열이다.
- 값은 어떤 자료형도 가능하다.

아래와 같은 방법을 사용하면 프로퍼티에 접근할 수 있다.

- 점 표기법: obj.property
- 대괄호 표기법: obj["property"] 대괄호 표기법을 사용하면 obj[varWithKey]같이 변수에서 키를 가져올 수 있다.

객체엔 다음과 같은 추가 연산자를 사용할 수 있다.

- 프로퍼티를 삭제하고 싶을 떄 : delete obj.prop
- 해당 키를 가진 프로퍼티가 객체 내에 있는지 확인하고자 할 때: "key" in obj
- 프로퍼티를 나열할 때 : for (let key in obj)

지금까지는 순수 객체라고 불리는 일반 객체에 대해 학습했다.



## 참조에 의한 객체 복사 - ⭐️⭐️⭐️

객체와 원시 타입의 근본적인 차이 중 하나는 객체는 `참조에 의해 저장되고 복사된다는 것이다. `원시값은 값 그대로 저장 할당되고 복사된다.

- 예시

```javascript
let message = 'Hello';
let phrase = message;
```

객체의 동작방식은 이와 다르다.

**변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 메모리 주소인 객체에 대한 참조 값이 저장된다.**

```javascript
let user = {
  name: "John"  
};
```

객체는 메모리 내 어딘가에 저장되고, 변수 user엔 객체를 참조할 수 있는 값이 저장된다.

따라서 객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않는다.

- 예시

```javascript
let user = { name: "John" };

let adim = user; // 객체의 참조값을 복사함
```

변수는 두 개이지만 각 변수에는 동일 객체에 대한 참조 값이 저장된다.

```javascript
let user = { name: "John" };
let admin = user;

admin.name =  "Pete";
alert(user.name); // Pete 가 출력된다. user 참조 값을 이용해 변경사항을 확인함
```



### 참조에 의한 비교

객체 비교시 동등 연산자(`==`)와 일치 연산자(`===`)는 동일하게 동작한다.

**비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.**

```javascript
let a = {};
let b= a; // Call By Reference

alert(a == b); // true
alert(a === b); // true
```

하지만 다음의 예제를 보자. 둘 다 비어있다는 공통점이 있지만 독립된 객체이기 때문에 일치, 동등 비교하면 거짓이 반환된다.

```javascript
let a = {};
let b = {};

alert(a == b); // false
alert(a === b); // false
```

obj1 > obj2 같은 대소 비교나 obj == 5같은 원시값과의 비교에선 객체가 원시형으로 변환된다. 하지만 이러한 비교가 필요한 경우는매우 드물다.



### 객체 복사, 병합과 Object.assign

객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어진다는 것을 배웠다.

자바스크립트는 객체 복제 내장 메서드를 지원하지 않기 때문에 객체를 복제하고 싶을 때는 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 된다.

```javascript
let user = {
    name: "John",
    age: 30
};

let clone = {};

for (let key in user) {
    clone[key] = user[key];
}

clone.name = "Pete";

alert(user.name); // John
```

Object.assign을 통해서도 복제할 수 있다. 문법과 동작은 다음과 같다.

```javascript
Object.assign(dest, [src1, src2, src3 ...])
```

- 첫 번째 인수 dest는 목표로 하는 객체이다.
- 이어지는 src1 ,,, srcN은 복사하고자 하는 객체이다. 필요시 언제든지 객체를 인수로 추가할 수 있다.
- 마지막으로 dest를 반환한다.

```javascript
let user = { name: "John" };

let permission1 = { canView: true };
let permission2 = { canEdit: true };

// permission1과 permission2의 프로퍼티를 user로 복사한다.
Object.assign(user, permission1, permission2);

//현재 user = {
//  name: "John",
//	canView: true,
//  canEdit: true
//}
```

목표 객체에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 덮어 씌워진다.

```javascript
let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // user = { name: "Pete" }
```

Object.assign을 사용하면 반복문 없이 간단하게 객체를 복사할 수 있다.

```javascript
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
```

user의 모든 프로퍼티가 빈 배열에 복사되고 변수에 할당된다.

### 중첩 객체 복사

지금까진 user의 모든 프로퍼티가 원시값인 경우만 가정했다. 하지만 프로퍼티의 값은 모든 자료형이 가능하다. 다른 객체에 대한 참조값일 수도 있다는 뜻이다. 이 경우는 어떻게 할까

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert(user.sizes.height);
```

clone.sizes = user.sizes로 프로퍼티를 복사하는 것만으로는 객체를 복제할 수 없다. 객체이기 때문에 참조값이 복사되기 때문이다. clone.sizes = user.sizes로 복사하면 같은 값을 공유하게 된다.

```javascript
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체입니다.

// user와 clone는 sizes를 공유합니다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경합니다.
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다.
```

이런 경우는 **깊은 복사**라는 방식으로 객체를 복사해야 한다. 깊은 복사란 user[key]의 각 값을 검사하면서 그 값이 객체인 경우 객체의 구조도 복사해주는 것이다.

- 깊은 복사 시 사용되는 표준 알고리즘은 Structured cloning algorithm이다.

- 자바스크립트의 라이브러리인 lodash의 \_.cloneDeep(obj)를 사용하면 이 알고리즘을 직접 구현하지 않고도 깊은 복사를 처리할 수 있다.



## 가비지 컬렉션 - ⭐️⭐️⭐️⭐️⭐️

원시값, 객체 함수 등 우리가 만드는 모든 것은 메모리를 차지한다. 더는 쓸모 없어지게 된 것들은 어떻게 처리될까, 자바스크립트 엔진이 어떻게 필요 없는 것들을 찾아내 삭제하는지 알아보자.



### 가비지 컬렉션 기준

자바스크립트는 *도달 가능성*이라는 개념을 사용해 메모리 관리를 수행한다.

도달 가능한 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미한다. 도달 가능한 값은 메모리에서 삭제되지 않는다.

1. 명백한 이유 없이 삭제되지 않는 도달 가능값

   - 현재 함수의 지역 변수와 매개변수
   - 중첩 함수의 체인에 있는 함수에서 사용되는 변수, 매개변수
   - 전역 변수
   - 기타 등등

   이런 값을 루트라고 한다.

2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.

   - 전역 변수에 객체가 저장되어있다라는 가정에, 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면 프로퍼티가 참조하는 객체는 도달 가능한 값이 된다. 이 객체가 참조하는 다른 모든 것들도 도달 가능하다고 여겨진다.

> 자바스크립트 엔진 내에선 가비지 컬렉터가 끊임없이 동작한다. 가비지 컬렉터는 모든 객체를 모니터링하고 도달할 수 없는 객체는 삭제한다.

### 간단한 예시

```javascript
let user = {
    name: "John";
};
```

user가 전역 변수라고 가정하자. user는 {name: "John"}이라는 객체를 참조한다. John의 프로퍼티 "name"은 원시값을 저장하고 있기 때문에 객체 안에 표현한다.

user의 값을 다른 값으로 덮어쓰면 참조가 사라진다.

```javascript
user = null;
```

이제 John은 도달할 수 없다. John에 접근할 방법, 참조하는 값은 어디에도 없다. 가비지 컬렉터는 이제 John에 저장된 데이터를 삭제하고 메모리에서 삭제한다.



### 참조 두 개

참조를 user -> admin으로 복사했다고 가정하자.

```javascript
// user엔 객체 참조 값이 저장됩니다.
let user = {
  name: "John"
};

let admin = user;
```

그리고 user의 값을 다른 값으로 덮어써본다.

```javascript
user = null;
```

전역 변수 admin을 통하면 여전히 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않는다.
