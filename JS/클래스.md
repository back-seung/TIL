# 클래스

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## 클래스와 기본 문법 - ⭐️⭐️

> 클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 일종의 틀로 객체를 정의하기 위한 상태와 메서드로 구성된다.

실무에선 사용자나 물건같이 동일한 종류의 객체를 여러 개 생성해야 하는 경우가 잦다.

이럴 때 new 연산자와 생성자 함수에서 배운 new Function을 사용할 수 있다. 

여기에 더하여 모던 JS에 도입된 class라는 문법을 사용하면 객체 지향 프로그래밍에서 사용되는 다양한 기능을 자바스크립트에서도 사용할 수 있다.



### 기본 문법

클래스느 다음과 같은 기본 문법을 사용해 만들 수 있다.

```javascript
class MyClass {
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }  
  ...
}         
```

이렇게 클래스를 만들고 new MyClass()를 호출하면 내부에서 정의한 메서드가 들어있는 객체가 생성된다.

객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화 할 수 있다.

- 예시

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  
  sayHi() {
    alert(this.name);
  }
}

// 사용법
let user = new User("John");
user.sayHi(); // John
```

new User("John")을 호출하면 다음과 같은 일이 일어난다. 

1. 새로운 객체가 생성된다.
2. 넘겨받은 인수와 함께 생성자가 자동으로 실행된다. 이때 인수(John)가 this.name에 할당된다.

이 과정 거친 뒤, user.sayHi()같은 객체 메서드를 호출할 수 있다.



> - 메서드 사이엔 쉼표가 없다.
>
> 클래스와 관련된 표기법은 *객체 리터럴 표기법*과 차이가 있다. 클래스에선 메서드 사이에 쉼표를 넣지 않아도 된다. 

### 클래스란

이 시점에서 클래스가 정확히 뭘까? 라는 의문이 생긴다. 클래스는 JS에서 새롭게 창안한 개체가 아니다. 

자바스크립트에서 클래스는 함수의 한 종류이다.

- 예시

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// User가 함수라는 증거
alert(typeof User); // function
```

`class User{...}`의 문법 구조는 다음과 같은 일을 한다.

1. User라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 constructor에서 가져온다. 생성자 메서드가 없으면 본문이 비워진채로 함수가 만들어진다.
2. sayHi같은 클래스 내에서 정의한 메서드를 User.prototype에 저장한다.

`new User`를 호출해 객체를 만들고 객체의 메서드를 호출하면 함수의 prototype 프로퍼티에서 설명했던 것처럼 메서드를 prototype 프로퍼티를 통해 가져온다. 이 과정이 있기 때문에 객체에서 클래스 메서드에 접근할 수 있다.

`claas User`선언 결과를 그림으로 나타내면 아래와 같다.

![스크린샷 2022-10-11 22.51.26](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-11%2022.51.26.png)

지금까지의 설명을 코드로 표현하면 다음과 같다.

```javascript
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// 클래스는 함수이다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일하다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장된다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개이다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

### 클래스는 단순한 편의 문법이 아니다

어떤 사람들은 class라는 키워드 없이 클래스 역할을 하는 함수를 선언할 수 있기 때문에 클래스는 편의 문법에 불과하다고 얘기한다.

참고로 기능은 동일하나 기존 문법을 쉽게 읽을 수 있게 만든 문법을 편의문법(syntatic sugar, 문법 설탕)이라고 한다.

```javascript
// class User와 동일한 기능을 하는 순수 함수 만들어보기

// 1. 생성자 함수를 만든다.
function User(name) {
  this.name = name;
}

// 모든 함수의 프로토타입은 'constructor' 프로퍼티를 기본으로 갖고 있기 때문에 constructor 프로퍼티를 명시적으로 만들 필요가 없다.

// 2. prototype에 메서드를 추가한다.
User.prototype.sayHi = function() {
  alert(this.name);
};

let user = new User("John");
user.sayHi();
```

위 예시처럼 순수 함수로 클래스 역할을 하는 함수를 선언하는 방법과 `class`키워드를 사용하는 방법의 결과는 거의 같다. class가 단순한 편의 문법이라고 생각하는 이유가 여기에 있다.

하지만 두 방법에는 중요한 차이 몇가지가 있다.

1. class로 만든 함수엔 특수 내부 프로퍼티인 `[[IsClassConstructor]] : true`가 이름표처럼 붙는다. 이것만으로도 두 방법엔 분명한 차이가 있음을 알 수 있다.

   자바스크립트는 다양한 경우에 `[[IsClassConstructor]] : true`를 활용한다. 클래스 생성자를 new와 함께 호출하지 않으면 에러가 발생하는데 이때 `[[IsClassConstructor]] : true`가 사용된다.

   ```javascript
   class User {
     constructor() {}
   }
   
   alert(typeof User); // User의 타입은 함수이긴 하지만 그냥 호출할 수 없다.
   User(); // TypeError: Class constructor User cannot be invoked without 'new'
   ```

   클래스 생성자를 문자열로 형변환하면 'class...'로 시작하는 문자열이 되는데 이때도`[[IsClassConstructor]] : true`가 사용된다.

   ```javascript
   class User {
     constructor() {}
   }
   
   alert(User); // class User { ... }
   ```

2. 클래스에 정의된 메서드는 열겨할 수 없다(Non-Enumerable). 클래스의 prototype 프로퍼티에 추가된 메서드의 enumerable 플래그는  false이다.

   **`for .. in`으로 객체를 순회할 때 메서드는 순회 대상에서 제외하고자 하는 경우가 많으므로** 이 특징은 꽤 유용하다.

3. 클래스는 항상 엄격 모드(use strict)로 실행된다. 클래스 생성자 안 코드 전체엔 자동으로 엄격 모드가 적용된다.

이 외에도 class를 사용하면 다양한 기능이 따라오는데, 차차 다룬다.

### 클래스 표현식

함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.

먼저 클래스 표현식을 만들어보자.

```javascript
let User = class {
  sayHi() {
    alert("안녕하세요?");
  }
};
```

기명 함수 표현식(Named Function Expression)과 유사하게 클래스 표현식에도 이름을 붙힐 수 있다.

클래스 표현식에 이름을 붙이면 이 이름은 오직 클래스 내부에서만 사용할 수 있다.

```javascript
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass라는 이름은 오직 클래스 안에서만 사용할 수 있다.
  }
};

new User.sayHi(); // 원하는 대로 MyClass의 정의를 보여준다.
alert(MyClass); // ReferenceError: MyClass is not defined, MyClass는 클래스 밖에서 사용할 수 없다.

```

필요에 따라 클래스를 동적으로 생성하는 것도 가능하다.

```javascript
function makeClass(phrase) {
  // 클래스를 선얺아고 이를 반환
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// 새로운 클래스 생성
let User = makeClass("안녕하세요?");

new User().sayHi(); // 안녕하세요?
```

### getter, setter

리터럴을 사용해 만든 객체처럼 클래스도 getter, setter, 계산된 프로퍼티를 지원한다.

get, set을 이용해  user.name을 조작할 수 있게 해보자.

```javascript
class User {
  constructor(name) {
		this.name = name;
  }
  
  get name() {
    return this._name;
  }
  
  set name(value) {
    if(value.length < 4) {
      alert("이름이 너무 짧습니다.");
      return;
    }
    this._name = value;
  }
}

let User = new User("보라");
alert(User.name); // 보라
user = new User(""); // 이름이 너무 짧습니다.
```

참고로 getter, setter는 User.prototype에 정의된다.



### 계산된 메서드 이름 [...]

대괄호 `[...]`를 이용해 계산된 메서드 이름(computed method name)을 만드는 예시를 살펴보자.

```javascript
class User {
  ['say' + 'Hi']() {
    alert('hello');
  }
}

new User.sayHi();
```

계산된 메서드 이름은 리터럴 객체와 유사한 형태를 띠기 때문에 사용법을 외우기 쉽다는 장점이 있다.

### 클래스 필드

> - 구식 브라우저에서는 폴리필이 필요할 수 있다
>
>   
>
> 클래스 필드는 최근에 더해진 기능이기 때문이다.

지금까지 살펴본 예시에는 메서드가 하나만 있었다.

'클래스 필드(class field)'라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.

클래스  User에 name 프로퍼티를 추가해보자.

```javascript
class User {
  name = '보라';
  
  sayHi() {
    alert(`${this.name}님 안녕하세요!`); ㄴ
  }
}

new User().sayHi(); // 보라님 안녕하세요!
```

클래스를 정의할 때 `<프로퍼티 이름> = <값>`을 써주면 간단히 클래스 필드를 만들 수 있다.

클래스 필드가 중요한 특징 중 하나는 User.prototype이 아닌 개별 객체에만 클래스 필드가 설정된다는 점이다. 

```javascript
class User {
  name = '보라';
  
}

let user = new User()
alert(user.name); // 보라
alert(User.prototype.name); // undefined
```

아울러 클래드 필드엔 복잡한 표현식이나 함수 호출 결과를 사용할 수 있다.

```javascript
class User {
	name = prompt("이름이 무엇인가요?", "보라");
}

let user = new User();
alert(user.name); // 보라
```

### 클래스 필드로 바인딩 된 메서드 만들기

함수 바인딩 챕터에서 살펴본 것처럼 JS에서 this는 동적으로 할당된다.

따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않는다.

관련 예시를 보자

```javascript
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button("안녕하세요.");

setTimeout(button.click, 1000); // undefined
```

이렇게 this의 컨텍스트를 알 수 없게되는 문제를 잃어버린 this(losing this)라고 한다.

문제는 두 방법을 사용해 해결할 수 있는데 함수 바인딩에서 이 방법을 배운적이 있다.

1. setTimeout(() => button.click(), 1000)같이 래퍼 함수를 전달하기
2. 생성자 안 등에서 메서드를 객체에 바인딩하기

이 두 방법 말고 클래스 필드를 사용해도 문제를 해결할 수 있다.

```javascript
class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button("안녕하세요");

setTimeout(button.click, 1000);
```

클래스 필드 click(() => { ... })는 각 `Button`객체마다 독립적인 함수를 만들어주고, 이 함수의  this를 해당 객체에 바인딩 시켜준다. 따라서 button.click을 아무 곳에나 전달할 수 있고, this엔 항상 의도한 값이 들어가게 된다.

클래스 필드의 이런 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용하다.



### 요약

아래와 같은 기본 문법을 사용해 클래스를 만들 수 있다.

```javascript
class MyClass {
  prop = value; // 프로퍼티

  constructor(...) { // 생성자 메서드
    // ...
  }

  method(...) {} // 메서드

  get something(...) {} // getter 메서드
  set something(...) {} // setter 메서드

  [Symbol.iterator]() {} // 계산된 이름(computed name)을 사용해 만드는 메서드 (심볼)
  // ...
}
```

MyClass는 constructor의 코드를 본문으로 갖는 함수이다. MyClass에서 정의한 일반 메서드나 getter, setter는 MyClass.prototype에 쓰인다.



## 클래스 상속

클래스 상속을 사용하면 클래스를 다른 클래스로 확장할 수 있다.

기존에 존재하던 기능을 토대로 새로운 기능을 만들 수 있는 것이다.



### extends 키워드

먼저, 클래스 Animal을 만들어본다.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
    this.speed = 0;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name}은/는 속도 ${this.speed}로 달린다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name}이/가 멈췄다.`);
  }
}
let animal = new Animal("동물");
```

현재 객체  animal과 Animal 클래스의 관계를 그림으로 나타내면 다음과 같다.

![스크린샷 2022-10-13 22.13.35](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-13%2022.13.35.png)

이제 Animal 클래스를 상속받는 Rabbit을 한 번 만들어보자.

```javascript
class Rabbit extends Animal {
  hide() {
    alert(`${this.name}이/가 숨었다.`);
  }
}

let rabbit = new Rabbit("흰 토끼");
rabbit.run(5); // 흰 토끼 은/는 속도 5로 달린다.
rabbit.hide(); // 흰 토끼 이/가 숨었다
```

클래스 Rabbit을 사용해 만든 객체는 는  `rabbit.hide()`같은 Rabbit에 정의된 메서드와 Animal의 메서드인  `run()`에도 접근할 수 있다.

키워드  `extends`는 프로토타입을 기반으로 동작한다. `extends`는 `Rabbit.prototype.[[Prototype]]`을 `Animal.prototype`으로 설정한다. 그렇기 때문에 Rabbit.prototype에서 메서드를 찾지 못하면  Animal.prototype에서 메서드를 가져온다.

![스크린샷 2022-10-13 22.34.10](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-13%2022.34.10.png)

엔진은 다음 절차에 따라 메서드  rabbit.run의 존재를 확인한다.

1. 객체 rabbit에 run이 있나 확인한다. 하지만 run메서드가 없다.
2. rabbit의 프로토타입인 Rabbit.prototype에 메서드가 있나 확인한다. hide는 있는데 run은 없다.
3. extends를 통해 관계가 만들어진 Rabbit.prototype의 프로토타입인  Animal.prototype에 메서드가 있나 확인한다. run이 있다.

내장 객체의 프로토타입에서 알아본 것처럼 자바스크립트의 내장 객체는 프로토타입을 기반으로 상속 관계를 맺는다. `Date.prototype.[[Prototype]]`이 `Object.prototype`인 것처럼 말이다. Date 객체에서 일반 객체 메서드를 사용할 수 있는 이유가 바로 여기에 있다.

> `extends`뒤에 표현식이 올 수도 있다.
>
> 클래스 문법은  extends뒤에 표현식이 와도 처리해준다.
>
> 아래 예시처럼 extends 뒤에서 부모 클래스를 만들어주는 함수를 호출할 수 있다.
>
> ```javascript
> function f(phrase) {
> 	return class {
>   	sayHi() { alert(phrase); }
> 	}
> }
> 
> class User extends f("Hello") {}
> 
> new User().sayHi(); // Hello
> ```
>
> 여기서 class User는  f("Hello")의 반환 값을 상속받는다.
>
> 이 방법은 조건에 따라 다른 클래스를 상속받고 싶을 때 유용하다. 조건에 따라 다른 클래스를 반환하는 함수를 만들고, 함수 호출 결과를 상속받게 하면 된다.



### 메서드 오버라이딩

이제 한발 더 나아가 메서드를 오버라이딩 해보자. 특별한 사항이 없으면 class Rabbit은 class Animal에 있는 메서드를 그대로 상속받는다.

그런데 Rabbit에서 stop()등의 메서드를 자체적으로 정의하면, 상속받은 메서드가 아닌 자체 메서드가 사용된다.

```javascript
class Rabbit extends Animal {
  stop() {
    // rabbit.stop()을 호출할 때
    // Animal의 stop()이 아닌, 이 메서드가 사용된다.
  }
}
```

개발을 하다보면 부모 메서드 전체를 교체하지 않고 부모 메서드를 토대로 일부 기능만 변경하고 싶을 때가 생긴다. 부모 메서드의 기능을 확장하고 싶을 때도 있고 말이다. 이럴 때 커스텀 메서드를 만들어 작업하게 되는데, 이미 커스텀 메서드를 만들었더라도 이 과정 전, 후에 부모 메서드를 호출하고 싶을때가 있다.

키워드 super는 이럴 때 사용된다.

- super.method(...)는 부모 클래스에 정의된 메서드 method를 호출한다.
- super(...)는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용할 수 있다.

이런 특징을 이용해 토끼가 멈추면 자동으로 숨도록하는 코드를 만들어보자.



```javascript
class Animal {
  
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name}가 속도 ${this.speed}로 달린다.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name}가 멈췄다.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었다!`);
  }

  stop() {
    super.stop(); // 부모 클래스의 stop을 호출해 멈추고,
    this.hide(); // 숨는다.
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼가 속도 5로 달린다.
rabbit.stop(); // 흰 토끼가 멈췄습니다. 흰 토끼가 숨었다!
```

Rabbit은 이제 실행 중간에 부모 클래스에 정의된 메서드  `super.stop()`을 호출하는 stop을 가지게 되었다.

> - 화살표 함수엔  super가 없다.
>
> 화살표 함수는  super를 지원하지 않는다. super에 접근하면 super를 외부에서 가져온다.
>
> ```javascript
> class Rabbit extends Animal {
>   stop() {
>     setTimeout(() => super.stop(), 1000); // 1초 후에 부모 stop을 호출한다.
>   }
> }
> ```
>
> 화살표 함수의 super는 stop()의 super와 같아서 위 예시는 의도한 대로 동작한다. 그렇지만 setTimeout안에서 '일반'함수를 사용했다면 에러가 발생했을 것이다.
>
> ```javascript
> // Unexpected super
> setTimeout(function() { super.stop() }, 1000);
> ```



### 생성자 오버라이딩

생성자 오버라이딩은 메서드 오버라이딩보다 조금 더 까다롭다.

지금까진  Rabbit에 자체  constructor가 없었다.

클래스가 다른 클래스를 상속받고 constructor가 없는 경우엔  아래처럼 비어있는 constructor가 만들어진다.

```javascript
class Rabbit extends Animal {
  constructor(...args) {
    super(...args)
  }
}
```

생성자는 기본적으로 부모 constructor를 호출한다. 이때 부모 constructor에도 인수를 모두 전달한다.

클래스에 자체 생성자가 없는 경우엔 이런 일이 모두 자동으로 일어난다.

이제  Rabbit에 커스텀 생성자를 추가해보겠다. 커스텀 생성자에서 name과 earLength를 지정해보자.

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// 동작하지 않는다
let rabbit = new Rabbit("흰 토끼", 10); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

에러가 발생하는 이유는 다음과 같다.

- 상속 클래스의 생성자에서는 반드시 super(...)를 호출해야 하는데, super(...)를 호출하지 않아 에러가 발생한다. super(...)는 this를 사용하기 전에 반드시 호출해야 한다.

그런데 왜 super(...)를 호출해야 할까? 번거롭게

상속 클래스의 생성자가 호출될 때 자바스크립트는 상속 클래스의 생성자 함수와 그렇지 않은 생성자 함수를 구분한다. 상속 클래스의 생성자 함수에는 특수 내부 프로퍼티인 [[ConstructorKind]]: "derived"가 이름표처럼 붙는다.

일반 클래스의 생성자 함수와 상속 클래스의 생성자 함수 간 차이는 new와 함께 드러난다.

- 일반 클래스가 new와 함께 실행되면 빈 객체가 만들어지고 this에 이 객체를 할당한다.
- 반면, 상속 클래스의 생성자 함수가 실행되면 일반 클래스에서 일어난 일이 일어나지 않는다. 상속 클래스의 생성자 함수는 빈 객체를 만들고 this에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대한다.

이런 차이 때문에 상속 클래스의 생성자에선 super를 호출해 부모 생성자를 실행해 주어야 한다. 그렇지 않으면 this가 될 객체가 만들어지지 않아 에러가 발생한다.

아래 예시와 같이 this를 사용하기 전에 super()를 호출하면 Rabbit의 생성자가 제대로 동작한다.

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// 이제 에러없이 동작한다.
let rabbit = new Rabbit("흰 토끼", 10);
alert(rabbit.name); // 흰 토끼
alert(rabbit.earLength); // 10
```

