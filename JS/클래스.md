# 클래스

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## 클래스와 기본 문법 - ⭐️⭐️

> 클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 일종의 틀로 객체를 정의하기 위한 상태와 메서드로 구성된다.

실무에선 사용자나 물건같이 동일한 종류의 객체를 여러 개 생성해야 하는 경우가 잦다.

이럴 때 new 연산자와 생성자 함수에서 배운 new Function을 사용할 수 있다. 

여기에 더하여 모던 JS에 도입된 class라는 문법을 사용하면 객체 지향 프로그래밍에서 사용되는 다양한 기능을 자바스크립트에서도 사용할 수 있다.



### 기본 문법

클래스느 다음과 같은 기본 문법을 사용해 만들 수 있다.

```javascript
class MyClass {
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }  
  ...
}         
```

이렇게 클래스를 만들고 new MyClass()를 호출하면 내부에서 정의한 메서드가 들어있는 객체가 생성된다.

객체의 기본 상태를 설정해주는 생성자 메서드 constructor()는 new에 의해 자동으로 호출되므로, 특별한 절차 없이 객체를 초기화 할 수 있다.

- 예시

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  
  sayHi() {
    alert(this.name);
  }
}

// 사용법
let user = new User("John");
user.sayHi(); // John
```

new User("John")을 호출하면 다음과 같은 일이 일어난다. 

1. 새로운 객체가 생성된다.
2. 넘겨받은 인수와 함께 생성자가 자동으로 실행된다. 이때 인수(John)가 this.name에 할당된다.

이 과정 거친 뒤, user.sayHi()같은 객체 메서드를 호출할 수 있다.



> - 메서드 사이엔 쉼표가 없다.
>
> 클래스와 관련된 표기법은 *객체 리터럴 표기법*과 차이가 있다. 클래스에선 메서드 사이에 쉼표를 넣지 않아도 된다. 

### 클래스란

이 시점에서 클래스가 정확히 뭘까? 라는 의문이 생긴다. 클래스는 JS에서 새롭게 창안한 개체가 아니다. 

자바스크립트에서 클래스는 함수의 한 종류이다.

- 예시

```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}

// User가 함수라는 증거
alert(typeof User); // function
```

`class User{...}`의 문법 구조는 다음과 같은 일을 한다.

1. User라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 constructor에서 가져온다. 생성자 메서드가 없으면 본문이 비워진채로 함수가 만들어진다.
2. sayHi같은 클래스 내에서 정의한 메서드를 User.prototype에 저장한다.

`new User`를 호출해 객체를 만들고 객체의 메서드를 호출하면 함수의 prototype 프로퍼티에서 설명했던 것처럼 메서드를 prototype 프로퍼티를 통해 가져온다. 이 과정이 있기 때문에 객체에서 클래스 메서드에 접근할 수 있다.

`claas User`선언 결과를 그림으로 나타내면 아래와 같다.

![스크린샷 2022-10-11 22.51.26](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-11%2022.51.26.png)

지금까지의 설명을 코드로 표현하면 다음과 같다.

```javascript
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// 클래스는 함수이다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일하다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장된다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개이다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

### 클래스는 단순한 편의 문법이 아니다

어떤 사람들은 class라는 키워드 없이 클래스 역할을 하는 함수를 선언할 수 있기 때문에 클래스는 편의 문법에 불과하다고 얘기한다.

참고로 기능은 동일하나 기존 문법을 쉽게 읽을 수 있게 만든 문법을 편의문법(syntatic sugar, 문법 설탕)이라고 한다.

```javascript
// class User와 동일한 기능을 하는 순수 함수 만들어보기

// 1. 생성자 함수를 만든다.
function User(name) {
  this.name = name;
}

// 모든 함수의 프로토타입은 'constructor' 프로퍼티를 기본으로 갖고 있기 때문에 constructor 프로퍼티를 명시적으로 만들 필요가 없다.

// 2. prototype에 메서드를 추가한다.
User.prototype.sayHi = function() {
  alert(this.name);
};

let user = new User("John");
user.sayHi();
```

위 예시처럼 순수 함수로 클래스 역할을 하는 함수를 선언하는 방법과 `class`키워드를 사용하는 방법의 결과는 거의 같다. class가 단순한 편의 문법이라고 생각하는 이유가 여기에 있다.

하지만 두 방법에는 중요한 차이 몇가지가 있다.

1. class로 만든 함수엔 특수 내부 프로퍼티인 `[[IsClassConstructor]] : true`가 이름표처럼 붙는다. 이것만으로도 두 방법엔 분명한 차이가 있음을 알 수 있다.

   자바스크립트는 다양한 경우에 `[[IsClassConstructor]] : true`를 활용한다. 클래스 생성자를 new와 함께 호출하지 않으면 에러가 발생하는데 이때 `[[IsClassConstructor]] : true`가 사용된다.

   ```javascript
   class User {
     constructor() {}
   }
   
   alert(typeof User); // User의 타입은 함수이긴 하지만 그냥 호출할 수 없다.
   User(); // TypeError: Class constructor User cannot be invoked without 'new'
   ```

   클래스 생성자를 문자열로 형변환하면 'class...'로 시작하는 문자열이 되는데 이때도`[[IsClassConstructor]] : true`가 사용된다.

   ```javascript
   class User {
     constructor() {}
   }
   
   alert(User); // class User { ... }
   ```

2. 클래스에 정의된 메서드는 열겨할 수 없다(Non-Enumerable). 클래스의 prototype 프로퍼티에 추가된 메서드의 enumerable 플래그는  false이다.

   **`for .. in`으로 객체를 순회할 때 메서드는 순회 대상에서 제외하고자 하는 경우가 많으므로** 이 특징은 꽤 유용하다.

3. 클래스는 항상 엄격 모드(use strict)로 실행된다. 클래스 생성자 안 코드 전체엔 자동으로 엄격 모드가 적용된다.

이 외에도 class를 사용하면 다양한 기능이 따라오는데, 차차 다룬다.

### 클래스 표현식

함수처럼 클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.

먼저 클래스 표현식을 만들어보자.

```javascript
let User = class {
  sayHi() {
    alert("안녕하세요?");
  }
};
```

기명 함수 표현식(Named Function Expression)과 유사하게 클래스 표현식에도 이름을 붙힐 수 있다.

클래스 표현식에 이름을 붙이면 이 이름은 오직 클래스 내부에서만 사용할 수 있다.

```javascript
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass라는 이름은 오직 클래스 안에서만 사용할 수 있다.
  }
};

new User.sayHi(); // 원하는 대로 MyClass의 정의를 보여준다.
alert(MyClass); // ReferenceError: MyClass is not defined, MyClass는 클래스 밖에서 사용할 수 없다.

```

필요에 따라 클래스를 동적으로 생성하는 것도 가능하다.

```javascript
function makeClass(phrase) {
  // 클래스를 선얺아고 이를 반환
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// 새로운 클래스 생성
let User = makeClass("안녕하세요?");

new User().sayHi(); // 안녕하세요?
```

### getter, setter

리터럴을 사용해 만든 객체처럼 클래스도 getter, setter, 계산된 프로퍼티를 지원한다.

get, set을 이용해  user.name을 조작할 수 있게 해보자.

```javascript
class User {
  constructor(name) {
		this.name = name;
  }
  
  get name() {
    return this._name;
  }
  
  set name(value) {
    if(value.length < 4) {
      alert("이름이 너무 짧습니다.");
      return;
    }
    this._name = value;
  }
}

let User = new User("보라");
alert(User.name); // 보라
user = new User(""); // 이름이 너무 짧습니다.
```

참고로 getter, setter는 User.prototype에 정의된다.



### 계산된 메서드 이름 [...]

대괄호 `[...]`를 이용해 계산된 메서드 이름(computed method name)을 만드는 예시를 살펴보자.

```javascript
class User {
  ['say' + 'Hi']() {
    alert('hello');
  }
}

new User.sayHi();
```

계산된 메서드 이름은 리터럴 객체와 유사한 형태를 띠기 때문에 사용법을 외우기 쉽다는 장점이 있다.

### 클래스 필드

> - 구식 브라우저에서는 폴리필이 필요할 수 있다
>
>   
>
> 클래스 필드는 최근에 더해진 기능이기 때문이다.

지금까지 살펴본 예시에는 메서드가 하나만 있었다.

'클래스 필드(class field)'라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.

클래스  User에 name 프로퍼티를 추가해보자.

```javascript
class User {
  name = '보라';
  
  sayHi() {
    alert(`${this.name}님 안녕하세요!`); ㄴ
  }
}

new User().sayHi(); // 보라님 안녕하세요!
```

클래스를 정의할 때 `<프로퍼티 이름> = <값>`을 써주면 간단히 클래스 필드를 만들 수 있다.

클래스 필드가 중요한 특징 중 하나는 User.prototype이 아닌 개별 객체에만 클래스 필드가 설정된다는 점이다. 

```javascript
class User {
  name = '보라';
  
}

let user = new User()
alert(user.name); // 보라
alert(User.prototype.name); // undefined
```

아울러 클래드 필드엔 복잡한 표현식이나 함수 호출 결과를 사용할 수 있다.

```javascript
class User {
	name = prompt("이름이 무엇인가요?", "보라");
}

let user = new User();
alert(user.name); // 보라
```

### 클래스 필드로 바인딩 된 메서드 만들기

함수 바인딩 챕터에서 살펴본 것처럼 JS에서 this는 동적으로 할당된다.

따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서호출하게 되면 this는 메서드가 정의된 객체를 참조하지 않는다.

관련 예시를 보자

```javascript
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button("안녕하세요.");

setTimeout(button.click, 1000); // undefined
```

이렇게 this의 컨텍스트를 알 수 없게되는 문제를 잃어버린 this(losing this)라고 한다.

문제는 두 방법을 사용해 해결할 수 있는데 함수 바인딩에서 이 방법을 배운적이 있다.

1. setTimeout(() => button.click(), 1000)같이 래퍼 함수를 전달하기
2. 생성자 안 등에서 메서드를 객체에 바인딩하기

이 두 방법 말고 클래스 필드를 사용해도 문제를 해결할 수 있다.

```javascript
class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button("안녕하세요");

setTimeout(button.click, 1000);
```

클래스 필드 click(() => { ... })는 각 `Button`객체마다 독립적인 함수를 만들어주고, 이 함수의  this를 해당 객체에 바인딩 시켜준다. 따라서 button.click을 아무 곳에나 전달할 수 있고, this엔 항상 의도한 값이 들어가게 된다.

클래스 필드의 이런 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용하다.



### 요약

아래와 같은 기본 문법을 사용해 클래스를 만들 수 있다.

```javascript
class MyClass {
  prop = value; // 프로퍼티

  constructor(...) { // 생성자 메서드
    // ...
  }

  method(...) {} // 메서드

  get something(...) {} // getter 메서드
  set something(...) {} // setter 메서드

  [Symbol.iterator]() {} // 계산된 이름(computed name)을 사용해 만드는 메서드 (심볼)
  // ...
}
```

MyClass는 constructor의 코드를 본문으로 갖는 함수이다. MyClass에서 정의한 일반 메서드나 getter, setter는 MyClass.prototype에 쓰인다.



## 클래스 상속 - ⭐️

클래스 상속을 사용하면 클래스를 다른 클래스로 확장할 수 있다.

기존에 존재하던 기능을 토대로 새로운 기능을 만들 수 있는 것이다.



### extends 키워드

먼저, 클래스 Animal을 만들어본다.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
    this.speed = 0;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name}은/는 속도 ${this.speed}로 달린다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name}이/가 멈췄다.`);
  }
}
let animal = new Animal("동물");
```

현재 객체  animal과 Animal 클래스의 관계를 그림으로 나타내면 다음과 같다.

![스크린샷 2022-10-13 22.13.35](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-13%2022.13.35.png)

이제 Animal 클래스를 상속받는 Rabbit을 한 번 만들어보자.

```javascript
class Rabbit extends Animal {
  hide() {
    alert(`${this.name}이/가 숨었다.`);
  }
}

let rabbit = new Rabbit("흰 토끼");
rabbit.run(5); // 흰 토끼 은/는 속도 5로 달린다.
rabbit.hide(); // 흰 토끼 이/가 숨었다
```

클래스 Rabbit을 사용해 만든 객체는 는  `rabbit.hide()`같은 Rabbit에 정의된 메서드와 Animal의 메서드인  `run()`에도 접근할 수 있다.

키워드  `extends`는 프로토타입을 기반으로 동작한다. `extends`는 `Rabbit.prototype.[[Prototype]]`을 `Animal.prototype`으로 설정한다. 그렇기 때문에 Rabbit.prototype에서 메서드를 찾지 못하면  Animal.prototype에서 메서드를 가져온다.

![스크린샷 2022-10-13 22.34.10](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-13%2022.34.10.png)

엔진은 다음 절차에 따라 메서드  rabbit.run의 존재를 확인한다.

1. 객체 rabbit에 run이 있나 확인한다. 하지만 run메서드가 없다.
2. rabbit의 프로토타입인 Rabbit.prototype에 메서드가 있나 확인한다. hide는 있는데 run은 없다.
3. extends를 통해 관계가 만들어진 Rabbit.prototype의 프로토타입인  Animal.prototype에 메서드가 있나 확인한다. run이 있다.

내장 객체의 프로토타입에서 알아본 것처럼 자바스크립트의 내장 객체는 프로토타입을 기반으로 상속 관계를 맺는다. `Date.prototype.[[Prototype]]`이 `Object.prototype`인 것처럼 말이다. Date 객체에서 일반 객체 메서드를 사용할 수 있는 이유가 바로 여기에 있다.

> `extends`뒤에 표현식이 올 수도 있다.
>
> 클래스 문법은  extends뒤에 표현식이 와도 처리해준다.
>
> 아래 예시처럼 extends 뒤에서 부모 클래스를 만들어주는 함수를 호출할 수 있다.
>
> ```javascript
> function f(phrase) {
> 	return class {
>   	sayHi() { alert(phrase); }
> 	}
> }
> 
> class User extends f("Hello") {}
> 
> new User().sayHi(); // Hello
> ```
>
> 여기서 class User는  f("Hello")의 반환 값을 상속받는다.
>
> 이 방법은 조건에 따라 다른 클래스를 상속받고 싶을 때 유용하다. 조건에 따라 다른 클래스를 반환하는 함수를 만들고, 함수 호출 결과를 상속받게 하면 된다.



### 메서드 오버라이딩

이제 한발 더 나아가 메서드를 오버라이딩 해보자. 특별한 사항이 없으면 class Rabbit은 class Animal에 있는 메서드를 그대로 상속받는다.

그런데 Rabbit에서 stop()등의 메서드를 자체적으로 정의하면, 상속받은 메서드가 아닌 자체 메서드가 사용된다.

```javascript
class Rabbit extends Animal {
  stop() {
    // rabbit.stop()을 호출할 때
    // Animal의 stop()이 아닌, 이 메서드가 사용된다.
  }
}
```

개발을 하다보면 부모 메서드 전체를 교체하지 않고 부모 메서드를 토대로 일부 기능만 변경하고 싶을 때가 생긴다. 부모 메서드의 기능을 확장하고 싶을 때도 있고 말이다. 이럴 때 커스텀 메서드를 만들어 작업하게 되는데, 이미 커스텀 메서드를 만들었더라도 이 과정 전, 후에 부모 메서드를 호출하고 싶을때가 있다.

키워드 super는 이럴 때 사용된다.

- super.method(...)는 부모 클래스에 정의된 메서드 method를 호출한다.
- super(...)는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용할 수 있다.

이런 특징을 이용해 토끼가 멈추면 자동으로 숨도록하는 코드를 만들어보자.



```javascript
class Animal {
  
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name}가 속도 ${this.speed}로 달린다.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name}가 멈췄다.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었다!`);
  }

  stop() {
    super.stop(); // 부모 클래스의 stop을 호출해 멈추고,
    this.hide(); // 숨는다.
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼가 속도 5로 달린다.
rabbit.stop(); // 흰 토끼가 멈췄습니다. 흰 토끼가 숨었다!
```

Rabbit은 이제 실행 중간에 부모 클래스에 정의된 메서드  `super.stop()`을 호출하는 stop을 가지게 되었다.

> - 화살표 함수엔  super가 없다.
>
> 화살표 함수는  super를 지원하지 않는다. super에 접근하면 super를 외부에서 가져온다.
>
> ```javascript
> class Rabbit extends Animal {
>   stop() {
>     setTimeout(() => super.stop(), 1000); // 1초 후에 부모 stop을 호출한다.
>   }
> }
> ```
>
> 화살표 함수의 super는 stop()의 super와 같아서 위 예시는 의도한 대로 동작한다. 그렇지만 setTimeout안에서 '일반'함수를 사용했다면 에러가 발생했을 것이다.
>
> ```javascript
> // Unexpected super
> setTimeout(function() { super.stop() }, 1000);
> ```



### 생성자 오버라이딩

생성자 오버라이딩은 메서드 오버라이딩보다 조금 더 까다롭다.

지금까진  Rabbit에 자체  constructor가 없었다.

클래스가 다른 클래스를 상속받고 constructor가 없는 경우엔  아래처럼 비어있는 constructor가 만들어진다.

```javascript
class Rabbit extends Animal {
  constructor(...args) {
    super(...args)
  }
}
```

생성자는 기본적으로 부모 constructor를 호출한다. 이때 부모 constructor에도 인수를 모두 전달한다.

클래스에 자체 생성자가 없는 경우엔 이런 일이 모두 자동으로 일어난다.

이제  Rabbit에 커스텀 생성자를 추가해보겠다. 커스텀 생성자에서 name과 earLength를 지정해보자.

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// 동작하지 않는다
let rabbit = new Rabbit("흰 토끼", 10); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

에러가 발생하는 이유는 다음과 같다.

- 상속 클래스의 생성자에서는 반드시 super(...)를 호출해야 하는데, super(...)를 호출하지 않아 에러가 발생한다. super(...)는 this를 사용하기 전에 반드시 호출해야 한다.

그런데 왜 super(...)를 호출해야 할까? 번거롭게

상속 클래스의 생성자가 호출될 때 자바스크립트는 상속 클래스의 생성자 함수와 그렇지 않은 생성자 함수를 구분한다. 상속 클래스의 생성자 함수에는 특수 내부 프로퍼티인 [[ConstructorKind]]: "derived"가 이름표처럼 붙는다.

일반 클래스의 생성자 함수와 상속 클래스의 생성자 함수 간 차이는 new와 함께 드러난다.

- 일반 클래스가 new와 함께 실행되면 빈 객체가 만들어지고 this에 이 객체를 할당한다.
- 반면, 상속 클래스의 생성자 함수가 실행되면 일반 클래스에서 일어난 일이 일어나지 않는다. 상속 클래스의 생성자 함수는 빈 객체를 만들고 this에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대한다.

이런 차이 때문에 상속 클래스의 생성자에선 super를 호출해 부모 생성자를 실행해 주어야 한다. 그렇지 않으면 this가 될 객체가 만들어지지 않아 에러가 발생한다.

아래 예시와 같이 this를 사용하기 전에 super()를 호출하면 Rabbit의 생성자가 제대로 동작한다.

```javascript
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// 이제 에러없이 동작한다.
let rabbit = new Rabbit("흰 토끼", 10);
alert(rabbit.name); // 흰 토끼
alert(rabbit.earLength); // 10
```



### 클래스 필드 오버라이딩 : 까다로운 내용

오버라이딩은 메서드뿐만 아니라 클래스 필드를 대상으로도 적용할 수 있다.

부모 클래스의 생성자 안에 있는 오버라이딩한 필드에 접근하려고 할 때 자바스크립트는 다른 프로그래밍 언어와는 다르게 조금 까다롭다.

- 예시

```javascript
class Animal {
	name = 'animal';
  
  constructor(name) {
    alert(`${this.name}`); // (*)
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal
```

Animal을 상속받는 Rabbit에서 name필드를 오버라이딩 했다.

Rabbit에는 따로 생성자가 정의되어 있지 않기 때문에 Rabbit을 사용해 인스턴스를 만들면 Animal의 생성자가 호출된다.

흥미로운 점은  new Animal()과 new Rabbit()을 실행할 때 두 경우 모두 (*)로 표시한 줄에 있는 alert 함수가 실행되면서 알럿 창에 animal이 출력된다는 것이다.

이를 통해 **부모 생성자는 자식 클래스에서 오버라이딩한 값이 아닌 부모 클래스 안의 필드를 사용한다**는 사실을 알 수 있다.

상속을 받고 필드 값을 오버라이딩 했는데 새로운 값 대신 부모 클래스 안에 있는 기존 필드 값을 사용하는 것은 이상하다. 이해를 하기 위해 이 상황을 메서드와 비교해보자.

- this.name 대신에  this.showName()을 사용한 예시

```javascript
class Animal {
  showName() {  // this.name = 'animal' 대신 메서드 사용
    alert('animal');
  }

  constructor() {
    this.showName(); // alert(this.name); 대신 메서드 호출
  }
}

class Rabbit extends Animal {
  showName() {
    alert('rabbit');
  }
}

new Animal(); // animal
new Rabbit(); // rabbit
```

필드를 오버라이딩한 위 예시와 결과값이 다르다.

위와 같이 자식 클래스에서 부모 생성자를 호출하면 오버라이딩한 메서드가 실행되어야 한다. 이게 원하는 결과다.

그런데 클래스 필드는 자식 클래스에서 필드를 오버라이딩해도 부모 생성자가 오버라이딩한 필드값을 사용하지 않는다. 부모 생성자는 항상 부모 클래스에 있는 필드의 값을 사용한다.

이런 차이가 존재하는 이유는 필드 초기화 순서 때문이다. 클래스 필드는 다음과 같은 규칙에 따라 초기화 순서가 달라진다.

- 아무것도 상속받지 않는 베이스 클래스는 생성자 실행 이전에 초기화 된다.
- 부모 클래스가 있는 경우엔 엔  super()실행 직후 초기화된다.

위 예시에서 Rabbit은 하위 클래스이고 constructor()가 정의되어 있지 않다. 이런 경우 앞서 설명한 바와 같이 생성자는 비어있는데 그 안에 super(...args)만 있다고 보면된다.

따라서 new Rabbit()을 실행하면 super()가 호출되고 그 결과 부모 생성자가 실행된다. 그런데 이때 하위 클래스 필드 초기화 순서에 따라 하위 클래스 Rabbit의 필드는 super() 실행 후에 초기화된다. 부모 생성자가 실행되는 시점에 Rabbit의 필드는 아직 존재하지 않는다. 이런 이유로 필드를 오버라이딩 했을 때 Animal에 있는 필드가 사용된 것이다.

이렇게 자바스크립트는 오버라이딩 시에 필드와 메서드의 동작 방식이 미묘하게 다르다.

다행히도 이런 문제는 오버라이딩한 필드를 부모 생성자에서 사용할 때만 발생한다. 이런 차이가 왜 발생하는지 모르면 결과를 해석할 수 없는 상황이 발생하기 때문에 별도의 공간을 만들어 필드 오버라이딩시 내부에서 벌어지는 일에 대해 자세히 알아보았다.

개발하다가 필드 오버라이딩이 문제가 되는 상황이 발생한다면  필드 대신 getter, setter 또는 메서드를 사용해 해결하면 된다.



### super키워드와 [[HomeObject]]

"내부에서 super는 ‘어떻게’ 동작할까?"라는 질문을 자신에게 던져보자. "객체 메서드가 실행되면 현재 객체가 `this`가 된다. 이 상태에서 `super.method()`를 호출하면 엔진은 현재 객체의 프로토타입에서 `method`를 찾아야 한다."까진 떠올릴 수 있다. 그런데 이런 과정은 ‘어떻게’ 일어나는 걸까?

쉬워 보이는 질문 같지만 실제론 그렇지 않다. 엔진은 현재 객체 `this`를 알기 때문에 `this.__proto__.method`를 통해 부모 객체의 `method`를 찾을 수 있을 것 같지만  불행하게도 이런 ‘나이브한’ 생각은 들어맞지 않는다.

구체적인 코드와 함께 문제를 재현해보자. 간결성을 위해 클래스가 아닌 일반 객체를 사용해 예시를 구성한다.

아래 예시의 `rabbit.__proto__`은 `animal`이다.  `rabbit.eat()`에서 `this.__proto__`를 사용해 `animal.eat()`을 호출해보겠다.

```javascript
let animal = {
  name: "동물",
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "토끼",
  eat() {
    // 예상대로라면 super.eat()이 동작해야 한다
    this.__proto__.eat.call(this); // (*)
  }
};

rabbit.eat(); // 토끼 이/가 먹이를 먹습니다.
```

`(*)`로 표시한 줄에선 `eat`을 프로토타입(`animal`)에서 가져오고 현재 객체의 컨텍스트에 기반하여 `eat`을 호출한다. 여기서 주의해서 봐야 할 부분은 `.call(this)`이다. `this.__proto__.eat()`만 있으면 현재 객체가 아닌 프로토타입의 컨텍스트에서 부모 `eat`을 실행하기 때문에 `.call(this)`이 있어야 한다.

예시를 실행하면 예상한 내용이 얼럿창에 출력되는 것을 확인할 수 있다.

이제 체인에 객체를 하나 더 추가해보자. 이제 슬슬 문제가 발생하기 시작한다

```javascript
let animal = {
  name: "동물",
  eat() {
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  eat() {
    // call을 사용해 컨텍스트를 옮겨가며 부모(animal) 메서드를 호출한다.
    this.__proto__.eat.call(this); // (*)
  }
};

let longEar = {
  __proto__: rabbit,
  eat() {
    // longEar를 가지고 무언가를 하면서 부모(rabbit) 메서드를 호출한다.
    this.__proto__.eat.call(this); // (**)
  }
};

longEar.eat(); // RangeError: Maximum call stack size exceeded
```

예상과 달리 `longEar.eat()`를 호출하니 에러가 발생한다.

원인이 석연치 않아 보이지만 `longEar.eat()`이 호출될 때 어떤 일이 발생하는지 하나씩 추척하다보면 이유를 알 수 있다. 먼저 살펴봐야 할 것은 `(*)`과 `(**)`로 표시한 줄인데 이 두 줄에서 `this`는 현재 객체인 `longEar`가 된다. 이게 핵심인데, 모든 객체 메서드는 프로토타입 등이 아닌 현재 객체를 `this`로 갖는다.

따라서 `(*)`과 `(**)`로 표시한 줄의 `this.__proto__`엔 정확히 같은 값, `rabbit`이 할당된다. 체인 위로 올라가지 않고 양쪽 모두에서 `rabbit.eat`을 호출하기 때문에 무한 루프에 빠지게 되는 것이다.

1. `longEar.eat()` 내부의 `(**)`로 표시한 줄에서 `rabbit.eat`을 호출하는데, 이때 `this`는 `longEar`이다.

   ```javascript
   // longEar.eat()안의 this는 longEar이다.
   this.__proto__.eat.call(this) // (**)
   // 따라서 윗줄은 아래와 같아진다.
   longEar.__proto__.eat.call(this)
   // longEar의 프로토타입은 rabbit이므로 윗줄은 아래와 같아진다
   rabbit.eat.call(this);
   ```

2. `rabbit.eat` 내부의 `(*)`로 표시한 줄에서 체인 위쪽에 있는 호출을 전달하려 했으나 `this`가 `longEar` 이기 때문에 또다시 `rabbit.eat`이 호출된다.

   ```javascript
   // rabbit.eat()안의 this 역시 longEar이다.
   this.__proto__.eat.call(this) // (*)
   // 따라서 윗줄은 아래와 같아진다.
   longEar.__proto__.eat.call(this)
   // longEar의 프로토타입은 rabbit이므로 윗줄은 아래와 같아진다.
   rabbit.eat.call(this);
   ```

3. 이런 내부 동작 때문에 `rabbit.eat`은 체인 위로 올라가지 못하고 자기 자신을 계속 호출해 무한 루프에 빠지게 되는 것이다.

이런 문제는 `this`만으론 해결할 수 없다.

### [[HomeObject\]]

자바스크립트엔 이런 문제를 해결할 수 있는 함수 전용 특수 내부 프로퍼티가 있다. 바로 `[[HomeObject]]`이다.

클래스이거나 객체 메서드인 함수의 `[[HomeObject]]` 프로퍼티는 해당 객체가 저장된다.

`super`는 `[[HomeObject]]`를 이용해 부모 프로토타입과 메서드를 찾는다.

예시를 통해 `[[HomeObject]]`가 어떻게 동작하는지 살펴보자. 먼저 일반 객체를 이용해 본다.

```javascript
let animal = {
  name: "동물",
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "토끼",
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "귀가 긴 토끼",
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// 이제 제대로 동작합니다
longEar.eat();  // 귀가 긴 토끼 이/가 먹이를 먹습니다.
```

`[[HomeObject]]`의 메커니즘 덕분에 메서드가 의도한 대로 동작하는 것을 확인해 보았다. 이렇게 `longEar.eat`같은 객체 메서드는 `[[HomeObject]]`를 알고 있기 때문에 `this` 없이도 프로토타입으로부터 부모 메서드를 가져올 수 있다

### 메서드는 자유롭지 않습니다

자바스크립트에서 함수는 대개 객체에 묶이지 않고 ‘자유롭다'. 이런 자유성 때문에 `this`가 달라도 객체 간 메서드를 복사하는 것이 가능하다.

그런데 `[[HomeObject]]`는 그 존재만으로도 함수의 자유도를 파괴한다. 메서드가 객체를 기억하기 때문이다. 개발자가 `[[HomeObject]]`를 변경할 방법은 없기 때문에 한 번 바인딩 된 함수는 더 이상 변경되지 않는다.

다행인 점은 `[[HomeObject]]`는 오직 `super` 내부에서만 유효하다는 것이다. 그렇기 때문에 메서드에서 `super`를 사용하지 않는 경우엔 메서드의 자유성이 보장된다. 객체 간 복사 역시 가능하다. 하지만 메서드에서 `super`를 사용하면 이야기가 달라진다.

객체 간 메서드를 잘못 복사한 경우에 `super`가 제대로 동작하지 않는 경우를 살펴보자.

```javascript
let animal = {
  sayHi() {
    console.log(`나는 동물입니다.`);
  }
};

// rabbit은 animal을 상속받습니다.
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    console.log("나는 식물입니다.");
  }
};

// tree는 plant를 상속받는다.
let tree = {
  __proto__: plant,
  sayHi: rabbit.sayHi // (*)
};

tree.sayHi();  // 나는 동물입니다. (?!?)
```

`tree.sayHi()`를 호출하니 "나는 동물입니다."가 출력된다.

원인은 꽤 단순하다.

* `(*)`로 표시한 줄에서 메서드 `tree.sayHi`는 중복 코드를 방지하기 위해 `rabbit`에서 메서드를 복사해왔다.
* 그런데 복사해온 메서드는 `rabbit`에서 생성했기 때문에 이 메서드의 `[[HomeObject]]`는 `rabbit`이다, 개발자는 `[[HomeObject]]`를 변경할 수 없다.
* `tree.sayHi()`의 코드 내부엔 `super.sayHi()`가 있다. `rabbit`의 프로토타입은 `animal`이므로 `super`는 체인 위에있는 `animal`로 올라가 `sayHi`를 찾는다.

### 함수 프로퍼티가 아닌 메서드 사용하기

`[[HomeObject]]`는 클래스와 일반 객체의 메서드에서 정의된다. 그런데 객체 메서드의 경우 `[[HomeObject]]`가 제대로 동작하게 하려면 메서드를 반드시 `method()` 형태로 정의해야 한다. `"method: function()"` 형태로 정의하면 안된다.

개발자 입장에선 두 방법의 차이는 그리 중요하지 않을 수 있지만, 자바스크립트 입장에선 아주 중요하다.

메서드 문법이 아닌(non-method syntax) 함수 프로퍼티를 사용해 예시를 작성해 보면 다음과 같다. `[[HomeObject]]` 프로퍼티가 설정되지 않기 때문에 상속이 제대로 동작하지 않는 것을 확인할 수 있다.

```javascript
let animal = {
  eat: function() { // 'eat() {...' 대신 'eat: function() {...'을 사용해
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // SyntaxError: 'super' keyword unexpected here ([[HomeObject]]가 없어서 에러가 발생함)
```

## 요약

1. 클래스 확장하기:

   ```
   class Child extends Parent
   ```

   * `Child.prototype.__proto__`가 `Parent.prototype`이 되므로 메서드 전체가 상속된다.

2. 생성자 오버라이딩:

   * `this`를 사용하기 전에 `Child` 생성자 안에서 `super()`로 부모 생성자를 반드시 호출해야 한다.

3. 메서드 오버라이딩:

   * `Child`에 정의된 메서드에서 `super.method()`를 사용해 `Parent`에 정의된 메서드를 사용할 수 있다.

4. super 키워드와 [[HomeObject]]

   * 메서드는 내부 프로퍼티 `[[HomeObject]]`에 자신이 정의된 클래스와 객체를 기억해놓는다. `super`는 `[[HomeObject]]`를 사용해 부모 메서드를 찾는다.
   * 따라서 `super`가 있는 메서드는 객체 간 복사 시 제대로 동작하지 않을 수 있다.

추가 사항:

* 화살표 함수는 `this`나 `super`를 갖지 않으므로 주변 컨텍스트에 잘 들어맞는다.



## 정적 메소드와 정적 프로퍼티 - ⭐️

`"prototype"`이 아닌 클래스 함수 자체에 메서드를 설정할 수 있다. 이런 메서드를 정적 메서드라도 부른다.

정적 메서드는 아래와 같이 클래스 안에서  static 키워드를 붙여 만들 수 있다.

```javascript
class User {
	stsatic staticMethod(){
    alert(this === User);
  }
}

User.staticMethod(); // true
```

정적 메서드는 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 일을 한다. 

```javascript
class user { }

User.staticMethod = function() {
  alert(this === User);
};

User.staticMethod(); // true
```

`User.staticMethod()`가 호출될 때 this의 값은 클래스 생성자인 User 자체가 된다. (점 앞의 객체 )

정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 주로 사용된다.

객체 Article이 여러개 있고 이들을 비교해 줄 함수가 필요하다고 가정해보자. 가장 먼저 아래와 같이  Article.compare를 추가하는 방법이 떠오를 것이다.

```javascript
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }
  
  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// 사용법
let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title );
```

여기서 Article.compare는 article을 비교해주는 수단으로 글 전체를 위에서 바라보며 비교를 수행한다.  Article.compare 이 글 하나의 메서드가 아닌 클래스의 메서드여야 하는 이유가 여기에 있다.

이번에 살펴볼 예시는 팩토리 메서드를 구현한 코드이다. 다양한 방법을 사용해 조건에 맞는 article 인스턴스를 만들어야 한다고 가정해보자.

1. 매개변수(tilte, date 등)을 이용해 관련 정보가 담긴 article 생성
2. 오늘 날짜를 기반으로 비어있는 article 생성
3. 기타 등등

첫 번째 방법은 생성자를 사용해 구현하는 것이다. 두 번째 방법은 클래스에 정적 메서드를 만들어 구현할 수 있다.

아래 `Article.createTodays()`같이 말이다.

```javascript
class Article {
  constructor(title, date) {
		this.title = title;
    this.date = date;
  }
  
  static createTodays = function() {
    // this는 Article이다
    return new this("Today's digest", new Date());
  }
}

let article = Article.createTodays();

alert(article.title); // Today's digest
```

이제 Today's digest라는 글이 필요할 때마다 Article.createTodays()를 호출하면 된다. 여기서도 마찬가지로 Article.createTodays()는 article의 메서드가 아닌 전체 클래스의 메서드이다.

정적 메서드는 아래 예시와 같이 항목 검색, 저장, 삭제 등을 수행해주는 DB관련  클래스에도 사용된다. 

```javascript
// Article은 article을 관리해주는 특별 클래스라고 가 
// article 삭제에 쓰이는 정적 메서드
Article.remove({id: 12345});
```



### 정적 프로퍼티

> - 최근에 추가
>
> 스펙에 추가된지 얼마 안된 문법이다. 예시는 Chrome에서만 작동한다.

정적 프로퍼티도 물론 만들 수 있다. 정적 프로퍼티는 일반 클래스 프로퍼티와 유사하게 생겼는데 앞에 static이 붙는다는 점만 다르다.

```javascript
class Aritcle {
  stsatic publisher = 'Ilya Kantor';
}

alert(Article.publisher); // Ilya Kantor
```



### 정적 프로퍼티와 메서드 상속

정적 프로퍼티와 메서드는 상속된다. 

아래 예시에서  Animal.compare와  Animal.planet은 상속되어서 각각 Rabbit.compare, Rabbit.planet에서 접근할 수 있다.

```javascript
class Animal {
  static planet = '지구';
  
  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }
  
  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name}가 속도 ${this.speed}로 달린다.`);
  }
  
  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}

// Animal을 상속받음
class Rabbit extneds Animal {
  hide() {
    alert(`${this.name}가 숨었다`);
  }
}

let rabbits = [
  new Rabbit("흰 토끼", 10),
  new Rabbit("검은 토끼", 5)
];

rabbits.sort(Rabbit.sort);

rabbits[0].run(); // 검은 토끼가 속도 5도 달린다.
alert(Rabbit.planet); // 지구
```

이제  Rabbit.compare를 호출하면  Animal.compare가 호출된다.

이게 가능한 이유는 프로토타입 때문이다. 이미 예상하겠지만 extends는 Rabbit의  [[Prototype]]이 Animal을 참조하도록 해준다.

![스크린샷 2022-10-15 18.44.47](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-15%2018.44.47.png)

따라서  Rabbit extends Animal은 두 개의  [[Prototype]] 참조를 만들어낸다.

1. 함수  Rabbit은 프로토타입을 통해 함수 Animal을 상속받는다.
2. Rabbit.prototype은 프로토타입을 통해  Animal.prototype을 상속받는다.

이런 과정이 있기 때문에 일반 메서드 상속과 정적 메서드 상속이 가능하다.

코드로 직접 확인해보자

```javascript
class Animal {}
class Rabbit extends Animal {}

// 정적 메서드
alert(Rabbit.__proto__ === Animal); // true

// 일반 메서드
alert(Rabbit.prototype.__proto__ === Animal.prototype); // true
```



### 요약

정적 메서드는 특정 클래스 인스턴스가 아닌 클래스 전체에 필요한 기능을 만들 때 사용할 수 있다.

인스턴스끼리 비교해주는 메서드 Article.compare(articleA, articleB)나 팩토리 메서드 Article.createTodays()를 만들 때 정적 메서드가 쓰인다.

정적 메서드는 클래스 선언부 안에 위치하고 앞에 `static`이라는 키워드가 붙는다.

정적 프로퍼티는 데이터를 클래스 수준에 저장하고 싶을 때 사용한다. 정적 프로퍼티 역시 개별 인스턴스에 묶이지 않는다.

- 문법

 

```javascript
class MyClass {
  static property = ...;
  
  static method() {
    ...
  }
}
```

static을 사용한 선언은 기술적으론 클래스 자체에 직접 할당하는 것과 동일하다.

```javascript
MyClass.property = ...
MyClass.method = ...
```

정적 프로퍼티와 정적 메서드는 상속이 가능하다.

class B exends A는 클래스  B의 프로토타입이 클래스  A를 가리키게 한다. `(B.[[Prototype]] = A).`따라서 B에서 원하는 프로퍼티나 메서드를 찾지 못하면  A에서 검색이 이뤄진다.



## private, protected 프로퍼티와 메서드 - ⭐️

객체 지향 프로그래밍에서 가장 중요한 원리 중 하나는 '내부 인터페이스와 외부 인터페이스를 구분 짓는 것'이다. 

단순히 'hello world'를 출력하는 것이 아닌 복잡한 애플리케이션을 구현하려면, 내부 인터페이스와 외부 인터페이스를 구분하는 방법을 '반드시' 알고 있어야 한다.

### 내부 인터페이스와 외부 인터페이스

객체 지향 프로그래밍에서 프로퍼티와 메서드는 두 그룹으로 분류된다.

- 내부 인터페이스(internal interface) - 동일한 클래스 내의 다른 메서드에선 접근할 수 있지만, 클래스 밖에선 접근할 수 없는 프로퍼티와 메서드
- 외부 인터페이스(external interface) - 클래스 밖에서도 접근 가능한 프로퍼티와 메서드

커피 머신으로 비유하자면 기계 안쪽에 숨어있는 뜨거운 물이 지나가는 관이나 발열 장치 등이 내부 인터페이스가 될 수 있다.

내부 인터페이스의 세부사항들은 서로의 정보를 이용하여 객체를 동작시킨다. 발열 장치에 부착된 관을 통해 뜨거운 물이 이동하는 것처럼 말이다.

커피 머신은 보호 커버에 둘러싸여 있기 때문에 보호 커버를 벗기지 않고는 커피머신 외부에서 내부로 접근할 수 없다. 밖에선 세부 요소를 알 수 없고, 접근도 불가능하다. 내부 인터페이스의 기능은 외부 인터페이스를 통해야만 사용할 수 있다.

이런 특징 때문에 외부 인터페이스만 알아도 객체를 가지고 무언가를 할 수 있다. 객체 안이 어떻게 동작하는지 알지 못해도 괜찮다는 점은 큰 장점으로 작용한다.

지금까진 내부 인터페이스와 외부 인터페이스의 개관에 대해 설명했다

자바스크립트에는 아래와 같은 두가지 타입의 객체 필드(프로퍼티와 메서드)가 있다.

- `public` - 어디서든지 접근할 수 있으며 외부 인터페이스를 구성한다. 
- `private` - 클래스 내부에서만 접근할 수 있으며 내부 인터페이스를 구성할 때 쓰인다.

자바스크립트 이외의 다수 언어에서 클래스 자신과 자손 클래스에서만 접근을 허용하는 `protected`필드를 지원한다. 

`protected` 필드는 `private`과 비슷하지만 *자손 클래스에서도 접근이 가능하다*는 점이 다르다. protected 필드도 내부 인터페이스를 만들 때 유용하다. 자손 클래스의 필드에 접근해야 하는 경우가 많기 때문에 protected 필드는 private 필드보다 조금 더 광범위하게 사용된다.

자바스크립트는 protected 필드를 지원하지 않지만 protected를 사용하면 편리한 점이 많기 때문에 이를 모방해서 사용하는 경우가 많다.

이제 지금까지 배운 프로퍼티 타입을 사용해 커피머신을 만들어보겠다. 실제 커피 머신은 아주 복잡하지만 여기서는 간결성을 위해 간이 모델을 만든다.

### 프로퍼티 보호하기

먼저, 간단한 커피 클래스를 만들어 보자.

```javascript
class CoffeeMachine {
  waterAmount = 0; // 물통에 차있는 물의 양
  
  constructor(power) {
    this.power = power;
    alert(`전력량이 ${this.power}인 커피 머신을 만듭니다.`);
  }
}

let coffeeMachine = new CoffeeMachine(100);

//  물 추가
coffeeMachine.waterAmount = 200
```

현재 프로퍼티 waterAmount와 power는 public이다. 손쉽게 waterAmount와 power를 읽고 원하는 값으로 변경하기 쉬운 상태이다. 

이제  waterAmount를 protected로 바꿔서 waterAmount를 통제해보자. 예시로  waterAmount를 0 미만의 값으로는 설정하지 못하도록 만들 것이다. 



**protected 프로퍼티 명 앞엔 밑줄`_`이 붙는다.**

자바스크립트에서 강제한 사항은 아니지만 밑줄은 프로그래머들 사이에서 외부 접근이 불가능한 프로퍼티나 메서드를 나타낼 때 쓴다.

waterAmount에 밑줄을 붙여 protected 프로퍼티로 만들어주자.



```javascript
class CoffeeMachine {
  _waterAmount = 0;
  
  set waterAmount(value) {
    if(value < 0) throw new Error('물의 양은 음수가 될 수 없습니다.');
    this._waterAmount = value;
  }
  
  get waterAmount() {
    return this._waterAmount;
  }
  
  constructor(power) {
    this.power = power;
  }
}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

// 물 추가
coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
```

이제 물의 양을 0 미만으로 설정하면 실패한다.



### 읽기 전용 프로퍼티

`power` 프로퍼티를 읽기만 가능하도록 만들어보자. 프로퍼티를 생성할 때만 값을 할당할 수 있고, 그 이후에는 값을 절대 수정하지 말아야 하는 경우가 종종 있는데 이럴 때 읽기 전용 프로퍼티를 활용할 수 있다.

커피 머신의 경우에는 전력이 이에 해당한다.

읽기 전용 프로퍼티를 만들려면 stter(설정자)는 만들지 않고, getter(획득자)만 만들어야 한다.

```javascript
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// 커피 머신 생성
let coffeeMachine = new CoffeeMachine(100);

alert(`전력량이 ${coffeeMachine.power}인 커피머신을 만듭니다.`); // 전력량이 100인 커피머신을 만듭니다.

coffeeMachine.power = 25; // Error (setter 없음)
```



> getter와 setter 함수
>
> 위에서는 get, set 문법을 사용해서 getter, setter 함수를 만들지만 보편적으로는  get.../set... 형식의 함수가 선호된다.
>
> ```javascript
> class CoffeeMachine {
>   _waterAmount = 0;
> 
>   setWaterAmount(value) {
>     if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
>     this._waterAmount = value;
>   }
> 
>   getWaterAmount() {
>     return this._waterAmount;
>   }
> }
> 
> new CoffeeMachine().setWaterAmount(100);
> ```
>
> 다소 길어보이긴 하지만 이렇게 함수를 선언하면 다수의 인자를 받을 수 있기 때문에 좀 더 유연하다.(위 예시에서는 인자가 하나뿐이긴 하다.)
>
> 반면  get, set 문법을 사용하면 코드가 짧아진다는 장점이 있다. 어떤걸 사용해야 한다는 규칙은 없으므로 원하는 방식을 선택해서 사용하자.

> protected 필드는 상속된다.
>
> `class MegaMachine extends CoffeeMachine`으로 클래스를 상속 받으면 새로운 클래스의 메서드에서 this._waterAmount나  this.\_power를 사용해 프로퍼티에 접근할 수 있다.
>
> 이렇게 protected 필드는 아래에서 보게 될 private 필드와 달리 자연스러운 상속이 가능하다.



### private 프로퍼티

> 스펙에 추가된지 얼마 안된 문법이다. 이 문법을 지원하지 않거나 부분적으로만 지원하는 엔진을 사용중이라면 폴리필을 구현해야 한다.

private 프로퍼티와 메서드는 제안(proposal)목록에 등재된 문법으로 명세서에 등재되기 직전 상태이다.

private 프로퍼티와 메서드는 `#`으로 시작한다. `#`이 붙으면 클래스 안에서만 접근할 수 있다.

물 용량 한도를 나타내는 private 프로퍼티  `#waterLimit`과 남아있는 물의 양을 확인해주는 private 메서드 `#checkWater`를 구현해보자.

```javascript
class CoffeeMachine {
  #waterLimit = 200;
  
  #checkWater(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    if (value > this.#waterLimit) throw new Error("물이 용량을 초과합니다");
  }
}

let coffeeMachine = new CoffeeMachine();

// 클래스 외부에서 private에 접근할 수 없음
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```

`#`은  자바스크립트에서 지원하는 문법으로 private 필드를 의미한다. private 필드는 클래스 외부나 자손 클래스에서 접근할 수 없다.

private 필드는 public 필드와 상충하지 않는다. private 프로퍼티  #waterAmount와 public 프로퍼티 waterAmount는 동시에 가질 수 있다.

\#waterAmount의 접근자 waterAmount를 만들어보자.

```javascript
class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;
alert(machine.#waterAmount); // Error
```

**protected 필드와 달리, private 필드는 언어 자체에 의해 강제된다는 점이 장점이다.**

그런데  coffeeMachine을 상속받는 클래스에선 #waterAmount에 직접 접근할 수 없다. #waterAmount에 접근하려면 waterAmount의 getter, setter를 통해야 한다.

```javascript
class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert( this.#waterAmount ); // Error: CoffeeMachine을 통해서만 접근할 수 있다.
  }
}
```

여러 시나리오에서 이런 제약은 너무 엄격하다. CoffeeMachine을 상속받는 클래스에선 CoffeeMachine의 내부에 접근해야 하는 정당한 사유가 있을 수 있기 때문이다. 언어 차원에서 protected 필드를 지원하지 않아도 더 자주 쓰이는 이유가 바로 여기에 있다.

> - private 필드는  this[name]로 사용할 수 없다.
>
> private 필드는 특별하다.
>
> 보통은  this[name]을 사용해 필드에 접근할 수 있다.
>
> ```javascript
> class User {
>   ...
>   sayHi() {
>     let fieldName = 'name';
>     alert(`Hello, ${this[fieldName]`);
>   }
> }
> ```
>
> 하지만  private 필드는 this[name]으로 접근할 수 없다. 이런 문법적 제약은 필드의 보안을 강화하기 위해 만들어졌다.



### 요약

객체 지향 프로그래밍에선 내부 인터페이스와 외부 인터페이스를 구분하는 것을 **캡슐화(encapsulation)**로 설명한다.

캡슐화의 이점은 다음과 같다.



- 사용자가 자신의 발등을 찍지 않도록 보호

커피 머신을 함께 사용하는 개발팀이 있다고 가정해보자. "Best CoffeMachine"이라는 회사에서 만든 이 커피머신은 현재 잘 작동하는데, 보호 커버가 없어서 내부 인터페이스가 노출되어 있다

팀원들은 의도에 맞게 사용을 하고 있었다. 하지만  John이라는 개발자가 자신의 능력대로 커피 머신 내부를 마구잡이로 재개발하다가 고장을 냈다.

커피 머신이 고장난 것은  John의 잘못이 아니라 John이 내부를 만질 수 있게한 사람의 잘못이다.

프로그래밍도 마찬가지다. 외부에서 의도치 않게 클래스를 조작하게 되면 그 결과를 예측할 수 없다.



- 지원 가능

실제 코드는 유지보수가 끊임없이 일어난다.

**내부 인터페이스를 엄격하게 구분하면 클래스 개발자들은 사용자에게 알리지 않고도 자유롭게 내부 프로퍼티와 메서드들을 수정할 수 있다.**

내부 인터페이스가 엄격히 구분된 클래스를 만지고 있다면, 그 어떤 외부 코드도 내부 private 메서드에 의존하고 있지 않기 때문에 private 메서드의 이름을 안전하게 바꿀 수 있고, 매개변수를 변경하거나 없앨 수도 있다는 것을 알아 두면 된다.

사용자 입장에선 새로운 버전이 출시되면서 내부 정비가 전면적으로 이뤄졌더라도 외부 인터페이스만 똑같다면 업그레이드가 용이하다는 장점이 있다.

- 복잡성 은닉

내부 인터페이스를 숨기려면 protected나 private 프로퍼티를 사용하면 된다.

* protected 필드는 `_`로 시작한다. `_`은 자바스크립트에서 지원하는 문법은 아니지만, protected 필드를 나타낼 때 관습처럼 사용된다. 개발자는 protected 프로퍼티가 정의된 클래스와 해당 클래스를 상속받는 클래스에서만 `_`가 붙은 필드에 접근해야 한다.
* private 필드는 `#`로 시작하며, 자바스크립트에서 지원하는 문법이다. `#`로 시작하는 필드는 해당 필드가 정의된 클래스 내부에서만 접근 가능하다.

모든 브라우저에서 private 필드를 지원하진 않지만 폴리필을 구현하여 사용할 수 있다.



​	
