## 에러 핸들링

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## try..catch와 에러 핸들링 -

에러를 핸들링 하는 방법에 대해 알아보자.

에러의 원인은 다양하다. 오타 같은 실수, 예상치 못한 클라이언트, 서버의 잘못된 응답 등이 있을 수 있다.

에러가 발생하면 스크립트는 즉시 중단된다.

그러나 try..catch를 사용하면 스크립트가 중단되는 것을 방지하고 에러를 catch하여 더 합당한 무언가를 할 수 있게 한다.

### try..catch 문법

try..catch의 문법은  try와 catch라는 두 개의 주요 블럭으로 구성된다.

```javascript
try {
  // 코드
} catch(err) {
  // 에러 핸들링
}
```

try..catch의 동작 알고리즘은 다음과 같다. 

1. 먼저 try안의 코드를 실행한다.
2. 에러가 없다면 try안의 마지막 줄까지 실행되고 catch문은 건너 뛴다.
3. 에러가 있다면 try안의 코드의 실행이 중단되며 즉시 catch로 제어 흐름이 넘어간다. 변수 err(아무이름이나 가능하다)는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.

![스크린샷 2022-10-20 22.48.48](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-20%2022.48.48.png)

이렇게 `try {...}`안에서 에러가 발생해도 `catch`에서 에러를 처리하기 때문에 스크립트는 죽지 않는다. 

예시를 보자.

- 에러가 없는 예시: (1)과 (2)를 alert창에 보여준다.

```javascript
try {
  alert('try 블럭 시작'); // (1)
  
  // 에러가 발생하지 않고 있다.
  
  alert('try 블록 끝'); // (2)
} catch(err) {
  
  alert('에러가 없으므로, catch는 무시된다.'); // (3)
  
}
```

- 에러가 있는 예시: (1)과 (3)을 보여준다.

```javascript
try {
  alert('try 블럭 시작'); // (1)
  
  // 에러가 발생했다.
  lalala; // 정의되지 않은 변수 // (2)
} catch(err) {
  
  alert('에러가 발생했습니다.'); // (3)
  
}
```

> - try...catch는 오직 런타임 에러에만 동작한다.
>
> try...catch는 실행 가능한(*runnable*)코드에만 동작한다. 실행 가능한 코드는 유효한 자바스크립트 코드를 의미한다.
>
> 중괄호 짝이 안맞는 것처럼 코드가 문법적으로 잘못된 경우에는 try..catch가 동작하지 않는다.
>
> ```javascript
> try {{{{{{{{{{{{{
>   
> } catch(e) {
>   alert('유효하지 않은 코드이기 때문에 자바스크립트 엔진은 이 스크립트를 이해할 수 없다.');
> }
> ```
>
> 자바스크립트 엔진은 코드를 읽고 난 후에 코드를 실행한다. 읽는 중에 발생하는 에러는 parse-time에러 라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time에러는 코드 안에서 복구가 불가능하다.
>
> try..catch는 유효한 코드에서 발생하는 에러만 처리할 수 있다. 이런 에러를 런타임 에러(*runtime error*) 또는 예외(*exception*)라고 부른다.



> - try..catch는 동기적으로 동작한다.
>
> setTimeout처럼 '스케줄 된(scheduled)' 코드에서 발생한 예외는 try...catch에서 잡아낼 수 없다.
>
> ```javascript
> try {
>   setTimeout(function() {
>    noSuchValue; // 스크립트는 여기서 죽는다. 
>   }, 1000);
> } catch(e) {
>   alert('작동 멈춤');
> }
> ```
>
> `setTimeout`.에 넘겨진 익명 함수는 엔진이 try-catch를 떠난 다음에서야 실행되기 때문이다.
>
> 스케줄 된 함수 내부의 예외를 잡으려면 try...catch를 반드시 함수 내부에 구현해야 한다.
>
> ```javascript
> setTimeout(function() {
>   try {
>     noSuchValue; // 이제 try..catch에서 에러를 핸들링 할 수 있다.
>   } catch(e) {
>     alert('에러를 잡았다');
>   }
> }, 1000);
> ```



### 에러 객체

에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성한다. 그 후, catch 블록에 이 객체를 인수로 전달한다.

```javas
try {
	// ...
} catch(e) { // <-- 'Error 객체', e 대신 다른 이름을 사용할 수 있다.
	// ...
}
```

내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가진다.

`name`

에러 이름. 정의되지 않은 변수 때문에 발생한 에러라면 "ReferenceError"가 이름이 된다.

`message` 

에러 상세 내용을 담고 있는 문자 메시지

표준은 아니지만 name, message 이외에 대부분의 호스트 환경에서 지원하는 프로퍼티도 있다. stack은 가장 널리 사용되는 비표준 프로퍼티 중 하나이다.

`stack`

현재 호출 스택. 에러를 유발한 중첩 호출들의 순서 정보를 가진 문자열로 디버깅 목적으로 사용된다.

- 예시

```javascript
try {
  lalala; // 에러. 정의 되지 않은 변수
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at ...(호출 스택)
  
  // 에러 전체를 보여줄 수도 있다. 이때 에러는 "name : message" 형태의 문자열로 변환된다.
  alert(err); // ReferenceError: lalala is not defined
} 
```



### 선택적 catch 바인딩

> 최근에 추가된 스펙이라 구식 브라우저는 폴리필이 필요하다.

에러에 대한 자세한 정보가 필요하지 않으면 catch에서 이를 생략할 수 있다.

```javascript
try {
  // ...
} catch {
  // ...
}
```



### try...catch 사용하기

실무에서는 어떻게 사용하는지 알아보자.

앞서 JSON으로 인코딩된 값을 읽을 수 있도록 해주는 JSON.parse(str) 메서드에 대해 배운바 있다.

이 메서드는 주로 서버 등에서 네트워크를 통해 전달받은 데이터를 디코딩 하는 데 사용한다.

전달 받은 데이터에 JSON.parse를 호출하는 식으로 사용된다. 

```javascript
let json = '{"name":"John", "age": 30}'; // 서버로부터 전달받은 데이터

let user = JSON.parse(json); // 전달받은 문자열을 자바스크립트 객체로 변환

// 문자열 형태로 전달받은 user가 프로퍼티를 가진 객체가 된다.
alert(user.name); // John
alert(user.age); // 30
```

잘못된 형식의 json이 들어온 경우, JSON.parse는 에러를 만들기 때문에 스크립트는 죽는다. 

서버에서 전달받은 데이터가 잘못되어 스크립트가 죽는 경우, 사용자는 개발자 콘솔을 열지 않는 이상 절대 원인을 알 수 없다.

`try..catch`를 사용해 이를 처리해 보자

```javascript
let json = "{bad json}";

try {
  let user = JSON.parse(json); // <-- 여기서 에러가 발생한다.
  alert(user.name); // 이 코드는 동작하지 않는다.
} catch(e) {
  // 에러가 발생하면 제어 흐름이 catch 문으로 넘어온다.
  alert("데이터에 에러가 있어 재요청을 시도한다.");
  alert(e.name);
  alert(e.message);
}
```

위 예시에서는 에러가 발생했다는 걸 보여주기 위해 간단한 예외 처리를 했지만  catch 블럭 안에서 새로운 네트워크로 요청 보내기, 사용자에게 대안 제시, 로깅 장치에 에러 정보 보내기 등과 같은 구체적인 일을 할 수 있다. 스크립트가 죽도록 놔두는 것보다 훨씬 낫게 말이다.