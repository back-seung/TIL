## 에러 핸들링

> 출처 : [모던 JavaScript 튜토리얼](https://ko.javascript.info) 
>
> - 챕터마다 지정한 별(0 ~ 5)는 작성자(백승한)가 느끼는 난이도에 따라 지정되었습니다.
> - 어떤 챕터는 모르는 것, 헷갈리는 것 위주로만 정리하기도 하였습니다.



## try..catch와 에러 핸들링 -

에러를 핸들링 하는 방법에 대해 알아보자.

에러의 원인은 다양하다. 오타 같은 실수, 예상치 못한 클라이언트, 서버의 잘못된 응답 등이 있을 수 있다.

에러가 발생하면 스크립트는 즉시 중단된다.

그러나 try..catch를 사용하면 스크립트가 중단되는 것을 방지하고 에러를 catch하여 더 합당한 무언가를 할 수 있게 한다.

### try..catch 문법

try..catch의 문법은  try와 catch라는 두 개의 주요 블럭으로 구성된다.

```javascript
try {
  // 코드
} catch(err) {
  // 에러 핸들링
}
```

try..catch의 동작 알고리즘은 다음과 같다. 

1. 먼저 try안의 코드를 실행한다.
2. 에러가 없다면 try안의 마지막 줄까지 실행되고 catch문은 건너 뛴다.
3. 에러가 있다면 try안의 코드의 실행이 중단되며 즉시 catch로 제어 흐름이 넘어간다. 변수 err(아무이름이나 가능하다)는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함한다.

![스크린샷 2022-10-20 22.48.48](https://raw.githubusercontent.com/back-seung/Today_I_Learned/master/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-10-20%2022.48.48.png)

이렇게 `try {...}`안에서 에러가 발생해도 `catch`에서 에러를 처리하기 때문에 스크립트는 죽지 않는다. 

예시를 보자.

- 에러가 없는 예시: (1)과 (2)를 alert창에 보여준다.

```javascript
try {
  alert('try 블럭 시작'); // (1)
  
  // 에러가 발생하지 않고 있다.
  
  alert('try 블록 끝'); // (2)
} catch(err) {
  
  alert('에러가 없으므로, catch는 무시된다.'); // (3)
  
}
```

- 에러가 있는 예시: (1)과 (3)을 보여준다.

```javascript
try {
  alert('try 블럭 시작'); // (1)
  
  // 에러가 발생했다.
  lalala; // 정의되지 않은 변수 // (2)
} catch(err) {
  
  alert('에러가 발생했습니다.'); // (3)
  
}
```

> - try...catch는 오직 런타임 에러에만 동작한다.
>
> try...catch는 실행 가능한(*runnable*)코드에만 동작한다. 실행 가능한 코드는 유효한 자바스크립트 코드를 의미한다.
>
> 중괄호 짝이 안맞는 것처럼 코드가 문법적으로 잘못된 경우에는 try..catch가 동작하지 않는다.
>
> ```javascript
> try {{{{{{{{{{{{{
>   
> } catch(e) {
>   alert('유효하지 않은 코드이기 때문에 자바스크립트 엔진은 이 스크립트를 이해할 수 없다.');
> }
> ```
>
> 자바스크립트 엔진은 코드를 읽고 난 후에 코드를 실행한다. 읽는 중에 발생하는 에러는 parse-time에러 라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time에러는 코드 안에서 복구가 불가능하다.
>
> try..catch는 유효한 코드에서 발생하는 에러만 처리할 수 있다. 이런 에러를 런타임 에러(*runtime error*) 또는 예외(*exception*)라고 부른다.



> - try..catch는 동기적으로 동작한다.
>
> setTimeout처럼 '스케줄 된(scheduled)' 코드에서 발생한 예외는 try...catch에서 잡아낼 수 없다.
>
> ```javascript
> try {
>   setTimeout(function() {
>    noSuchValue; // 스크립트는 여기서 죽는다. 
>   }, 1000);
> } catch(e) {
>   alert('작동 멈춤');
> }
> ```
>
> `setTimeout`.에 넘겨진 익명 함수는 엔진이 try-catch를 떠난 다음에서야 실행되기 때문이다.
>
> 스케줄 된 함수 내부의 예외를 잡으려면 try...catch를 반드시 함수 내부에 구현해야 한다.
>
> ```javascript
> setTimeout(function() {
>   try {
>     noSuchValue; // 이제 try..catch에서 에러를 핸들링 할 수 있다.
>   } catch(e) {
>     alert('에러를 잡았다');
>   }
> }, 1000);
> ```



### 에러 객체

에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성한다. 그 후, catch 블록에 이 객체를 인수로 전달한다.

```javas
try {
	// ...
} catch(e) { // <-- 'Error 객체', e 대신 다른 이름을 사용할 수 있다.
	// ...
}
```

내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가진다.

`name`

에러 이름. 정의되지 않은 변수 때문에 발생한 에러라면 "ReferenceError"가 이름이 된다.

`message` 

에러 상세 내용을 담고 있는 문자 메시지

표준은 아니지만 name, message 이외에 대부분의 호스트 환경에서 지원하는 프로퍼티도 있다. stack은 가장 널리 사용되는 비표준 프로퍼티 중 하나이다.

`stack`

현재 호출 스택. 에러를 유발한 중첩 호출들의 순서 정보를 가진 문자열로 디버깅 목적으로 사용된다.

- 예시

```javascript
try {
  lalala; // 에러. 정의 되지 않은 변수
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at ...(호출 스택)
  
  // 에러 전체를 보여줄 수도 있다. 이때 에러는 "name : message" 형태의 문자열로 변환된다.
  alert(err); // ReferenceError: lalala is not defined
} 
```



### 선택적 catch 바인딩

> 최근에 추가된 스펙이라 구식 브라우저는 폴리필이 필요하다.

에러에 대한 자세한 정보가 필요하지 않으면 catch에서 이를 생략할 수 있다.

```javascript
try {
  // ...
} catch {
  // ...
}
```



### try...catch 사용하기

실무에서는 어떻게 사용하는지 알아보자.

앞서 JSON으로 인코딩된 값을 읽을 수 있도록 해주는 JSON.parse(str) 메서드에 대해 배운바 있다.

이 메서드는 주로 서버 등에서 네트워크를 통해 전달받은 데이터를 디코딩 하는 데 사용한다.

전달 받은 데이터에 JSON.parse를 호출하는 식으로 사용된다. 

```javascript
let json = '{"name":"John", "age": 30}'; // 서버로부터 전달받은 데이터

let user = JSON.parse(json); // 전달받은 문자열을 자바스크립트 객체로 변환

// 문자열 형태로 전달받은 user가 프로퍼티를 가진 객체가 된다.
alert(user.name); // John
alert(user.age); // 30
```

잘못된 형식의 json이 들어온 경우, JSON.parse는 에러를 만들기 때문에 스크립트는 죽는다. 

서버에서 전달받은 데이터가 잘못되어 스크립트가 죽는 경우, 사용자는 개발자 콘솔을 열지 않는 이상 절대 원인을 알 수 없다.

`try..catch`를 사용해 이를 처리해 보자

```javascript
let json = "{bad json}";

try {
  let user = JSON.parse(json); // <-- 여기서 에러가 발생한다.
  alert(user.name); // 이 코드는 동작하지 않는다.
} catch(e) {
  // 에러가 발생하면 제어 흐름이 catch 문으로 넘어온다.
  alert("데이터에 에러가 있어 재요청을 시도한다.");
  alert(e.name);
  alert(e.message);
}
```

위 예시에서는 에러가 발생했다는 걸 보여주기 위해 간단한 예외 처리를 했지만  catch 블럭 안에서 새로운 네트워크로 요청 보내기, 사용자에게 대안 제시, 로깅 장치에 에러 정보 보내기 등과 같은 구체적인 일을 할 수 있다. 스크립트가 죽도록 놔두는 것보다 훨씬 낫게 말이다.

### 직접 에러를 만들어서 던지기

`json`이 문법적으로 잘못되진 않았지만 스크립트 내에서 사용 중인 필수 프로퍼티 name을 가지고 있지 않다면 무슨일이 발생할까?

```javascript
let json = '{ "age": 30 }'; // 불완전 데이터

try {
  let user = JSON.parse(json); // <-- 에러 없음
  alert(user.name); // 이름이 없다
} catch(e) {
  alert("실행되지 않는다.");
}
```

위 예시에서 JSON.parse는 정상적으로 실행되었지만 name이 없는건 에러를 유발하는 상황이다.

이제 throw 연산자를 사용해 에러 처리를 통합해 보도록 하겠다.



#### 'throw' 연산자

throw 연산자는 에러를 생성한다.

문법은 다음과 같다. 

```javascript
throw <error object>
```

이론적으로는 숫자, 문자열 같은 원시형 자료를 포함한 어떤 것이든 에러 객체(error object)로 사용할 수 있다. 하지만 내장 에러와의 호환을 위해 되도록 에러 객체에 name과 message 프로퍼티를 넣어주는 것을 권장한다.

자바스크립트는 Error, SyntaxError, ReferenceError, TypeError 등의 표준 에러 객체 관련 생성자를 지원한다. 이 생성자들을 이용해 에러 객체를 만들 수도 있다.

- 예시

```javascript
let error = new Error(message);
// or
let error = new SyntaxError(message);
let error = new ReferenceError(mesasge);
// ...
```

일반 객체가 아닌 내장 생성자를 사용해 만든 내장 에러 객체의 name프로퍼티는 생성자 이름과 동일한 값을 갖는다. 프로퍼티 message의 값은 인수에서 가져온다. 

- 예시

```javascript
let error = new Error("이상한 일이 발생했다.");

alert(error.name); // Error
alert(error.message); // 이상한 일이 발생했다.
```

잘못된 데이터를 받았을 때 JSON.parse가 어떤 종류의 에러를 만들어내는지 아래 코드를 통해 살펴보자.

```javascript
try {
  JSON.parse("{ 잘못된 형식의 json }");
} catch(e) {
  alert(e.name); // SyntaxError
  alert(e.message); // Unexpected token b in JSON at position 2
}
```

SyntaxError가 발생한다.

사용자를 나타내는 객체에 name 프로퍼티는 반드시 있어야 하므로, 이제 name이 없으면 에러가 발생한 것으로 간주하고 예외 처리를 해보자.

throw 연산자를 사용해 에러를 던져보겠다.

```javascript
let json = '{ "age": 30 }'; // 불완전한 데이터

try {
  let user = JSON.parse(json); // <-- 에러 없음
  
  if(!user.name) {
    throw new SyntaxError("불완전한 데이터 : 이름 없음"); // (*)
  }
  
  alert(user.name);
} catch(e) {
  alert("JSON Error: " + e.message); // JSON Error: 불완전한 데이터 : 이름 없음
}
```

(*)로 표시한 줄에서 throw 연산자는 message를 이용해 SyntaxError를 생성한다. 에러 생성 방식은 자바스크립트가 자체적으로 에러를 생성하는 방식과 동일하다. 에러가 발생했으므로 try의 실행은 즉시 중단되고 제어 흐름이 catch로 넘어간 것을 얼럿 창을 통해 확인할 수 있다.

이제 JSON.parse에서 에러가 발생한 경우를 포함해서 모든 에러를 catch 블럭 안에서 처리할 수 있게 되었다.

### 에러 다시 던지기

위 예시에선 불완전한 데이터를 try..catch로 처리하였습니다. 그런데 또 다른 *예기치 않은 에러*가 try {...} 블록 안에서 발생 할 수도 있다. 정의되지 않은 변수 사용 등의 프로그래밍 에러가 발생할 가능성은 항상 있다.

- 예시

```javascript
let json = '{ "age": 30 }';

try {
  user = JSON.parse(json); // <-- user 앞에 let을 붙이는 걸 잊었다.
  
  // ...
} catch(err) {
  alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined
  // 실제론 JSON Error가 아니다.
}
```

에러는 어떤 상황에서도 발생할 수 있다. 몇십 년간 사용한 오픈소스 유틸리티에서도 끔찍한 해킹으로 이어질 수 있는 엄청난 버그가 발견된다.

위에선 '불완전한 데이터'를 다루려는 목적으로 try..catch를 썼다. 그런데 catch는 원래 try 블럭에서 발생한 모든 에러를 잡으려는 목적으로 만들어졌다. 그런데 위 예시에서 catch는 예상치 못한 에러를 잡아내주긴 했지만 에러 종류와 관계없이 "JSON Error"메시지를 보여준다. 이렇게 에러 종류와 관계없이 동일한 방식으로 에러를 처리하는 것은 디버깅을 어렵게 만들기 때문에 좋지 않습니다.

이런 문제를 피하고자 '다시 던지기(rethrowing)' 기술을 사용한다. 규칙은 간단하다.

**catch는 알고 있는 에러만 처리하고 나머지는 '다시 던져야' 합니다.**

'다시 던지기' 기술을 더 자세히 설명하겠다.

1. catch가 모든 에러를 받는다.
2. catch(err) {...} 블럭 안에서 에러 객체 err를 분석한다.
3. 에러 처리 방법을 알지 못하면 throw err를 한다.

보통 에러 타입을 instanceof 명령어로 체크한다. 

```javascript
try {
  user = { /*...*/ };
} catch(err) {
  if(err instanceof ReferenceError) {
    alert('ReferenceError'); // 정의되지 않은 변수에 접근하여 'ReferenceError' 발생
  }
}
```

`err.name` 프로퍼티로 에러 클래스 이름을 알 수도 있다. 기본형 에러는 모두 `err.name` 프로퍼티를 가진다. 또는 `err.constructor.name`를 사용할 수도 있다.

에러를 다시 던져서 catch 블럭에선 SyntaxError만 처리되도록 해보자.

```javascript
let json = '{ "age": 30 }'; // 불완전 데이터
try {
  let user = JSON.parse(json);
  
  if(!user.name) {
    throw new SyntaxError("불완전한 데이터: 이름 없음");
  }
  
  blabla(); // 예상치 못한 에러
  
  alert(user.name);
} catch(e) {
  if(e instanceof SyntaxError) {
    alert("JSON Error: " + e.message);
  } else {
    throw e; // 에러 다시 던지기(*)
  }
}
```

catch블럭 안의 (*)로 표시한 줄에서 다시 던져진(rethrow) 에러는 try..catch"밖으로 던져진다."  이때 바깥에 try..catch가 있다면 여기서 에러를 잡는다. 아니라면 스크립트는 죽을 것이다.

이렇게 하면 catch 블럭에서는 어떻게 다룰지 알고 있는 에러만 처리하고 알 수 없는 에러는 스킵할 수 있다.

이제 try..catch를 하나 더 만들어 다시 던져진 예상치 못한 에러를 처리해보자.

```javascript
function readData() {
  let json = '{ "age": 30 }';
  
  try {
    // ...
    blabla(); // 에러
  } catch(e) {
    // ...
    if(!(e instanceof SyntaxError)) {
      throw e; // 알 수 없는 에러 다시 던지기
    }
  }
}

try {
  readData();
} catch(e) {
  alert("External catch got: " + e); // 에러를 잡음
}
```

readData는 SyntaxError만 처리할 수 있지만 함수 바깥의 try..catch에서는 예상치 못한 에러도 처리할 수 있게 되었다.