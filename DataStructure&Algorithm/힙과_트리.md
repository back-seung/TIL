# 힙과 트리

> 참고
>
> - https://yoongrammer.tistory.com/68
> - https://www.boostcourse.org/cs204/joinLectures/212812?isDesc=false

## 트리

![image](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212012257672.png)

### 트리란

노드들이 나무 가지처럼 연결된 비선형 계층적 자료구조이다.

트리는 트리 내의 다른 하위 트리가 있고 그 하위 트리 안에는 또 다른 트리가 있는 재귀적 자료구조이다.

### 트리의 용어들

- 루트 노드(root node) - 부모가 없는 노드이다. 트리는 하나의 루트 노드를 가지고 있다. 최상위 레벨에 있다.
- 간선(edge, branch) - 각 노드를 잇는 연결 고리
- 단말 노드(leaf node) - 자식이 없는 노드이다. 최하위 레벨에 있다.
- 형제(sibling) - 같은 부모를 가지고 있는 노드들의 집합을 형제 관계라고 한다. 예를 들어 [A - B] [A -C]라는 관계에서 A가 부모 노드라면 B와 C는 형제 관계이다.
- 레벨(level) - 트리의 특정 깊이를 가지는 노드의 집합이다.
- 깊이(depth) - 루트에서 어떤 노드까지의 간선 수이다.
- 넓이(WIdth) - 어떠한 레벨에 있는 노드의 개수이다. 레벨 2의 넓이는 4이다. 
- 크기(size) - 자신을 포함한 모든 자식 노드의 개수이다.
- 높이(height) - 루트 노드부터 가장 먼 단말 노드까지 가는데 거치게 되는 간선의 개수이다. 높이는  전체 노드의 개수를 알고 있으면 log2(n+1) - 1의 공식으로 구할 수 있다.
  - 레벨 0에서의 노드는 1개이다. 위 식에 대입하면 log2(0 + 1) - 1 = 0이 된다. 따라서 높이는 0이다.
  - 레벨 1에서의 노드는 3개이다. 위 식에 대입하면 log2(3 + 1) - 1 = 1이 된다. 따라서 높이는 1이다.
  - ..
  - 레벨 3에서의 노드는 15개이다. 위 식에 대입하면 log2(15 + 1) -1 = 3이 된다. 따라서 높이는 3이다.
- 노드 차수(degree) - 각 노드의 자식 수(하위 트리 개수 / 간선 수)이다.
- 트리의 차수(degree of tree) - 트리의 최대 차수이다. 

### 트리의 특징

- 하나의 루트 노드와 0개 이상의 하위 트리로 구성된다.
- 데이터를 순차적으로 저장하지 않기 때문에 비선형 자료구조이다.
- 트리 내에 또 다른 트리가 있는 재귀적 자료구조이다.
- 단순 순환을 갖지 않고 연결된 무방향 그래프 구조이다.
  - 그래프의 한 종류로 '최소 연결 트리'라고도 부른다.
- 노드 간에 부모 자식 관계를 갖는 계층형 자료구조이다. 모든 자식은 하나의 부모 노드를 가진다.
- 노드가 n개인 트리는 항상 n -1개의 간선을 가진다.
- 순회는 Pre-order, In-order, Post-order로 이루어진다.
  - 전위 순회(Pre-order) - 루트 노드에서 시작하여 왼쪽 자식 노드에 갔다가 오른쪽 자식 노드로 가는 순회 방법이다. 다른 모든 노드를 지나기 전에 루트 노드를 방문하기 때문에 이름에 전(Pre)이 들어간다.
  - 중위 순회(In-order) - 왼쪽 자식 노드에서 시작하여 루트 노드에 갔다가 오른쪽 자식 노드로 가는 순회 방법이다.
  - 후위 순회(Post-order) - 왼쪽 자식 노드에서 시작하여 오른쪽 자식 노드에 갔다가 루트 노드로 가는 순회 방법이다. 

### 트리의 종류

- 이진 트리
  - 각 노드가 최대 두 개의 자식을 갖는 트리
- 이진 탐색 트리 (Binary Search Tree)
  - 순서화된 이진 트리 
  - 노드의 왼쪽 자식은 부모의 값보다 작은 값을 가지고, 오른쪽 자식 노드는 부모의 값보다 커야 한다.

- 편향 트리(Skew tree)
  - 모든 노드들이 자식을 하나만 가진다.
  - 왼쪽 방향으로만 하나씩만 가질 때 left skew tree, 마찬가지로 오른쪽으로만 하나씩 가질 때는 right skew tree이다.
- 균형 트리(Balanced Tree, B-Tree)
  - m원 탐색 트리에서 높이 균형을 유지하는 트리
  - height-balanced m-way tree라고도 한다.
- 원 탐색 트리(M-way Search Tree)
  - 최대 m개의 서브 트리를 가지는 탐색 트리
  - 이진 탐색 트리의 확장된 형태. 높이를 줄이기 위해 사용한다.

- 완전 이진 트리(Full Binary Tree)
  - 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리, 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.
  - 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
  - 마지막 레벨 h에서 (1 ~ 2h-1)개의 노드를 가질 수 있다. 
- 정 트리(Full Binary Tree) 
  - 모든 트리가 0개 또는 2개의 자식 노드를 갖는 트리
- 포화 이진 트리(Perfect Binary Tree)
  - 정 트리면서 완전 이지 트리인 경우
  - 모든 말단 노드는 같은 높이에 있어야 하며 마지막 레벨에서 노드 개수는 최대 개수여야 한다.
  - 리프를 제외한 모든 노드가 두개의 또 다른 자식 노드를 가져야 한다.
  - 모든 리프 노드는 같은 레벨에 있어야 한다.
  - 노드의 개수 = 2^(height -1)개여야 한다. 



### 중위 표기법, 후위 표기법

컴퓨터는 괄호, 연산자의 우선순위를 따로 처리하지 않고 왼쪽에서 오른쪽으로 표기된 순서대로 처리하면 결과가 올바르게 나오는 후위 표기법을 사용한다.

- 중위 표기법 : 연산자를 피연산자의 가운데에 표기한다.
  - 예) 2 + 3
- 후위 표기법 : 연산자를 피연산자의 뒤에 표기한다.
  - 예) 23 +



### 트리의 구현

- 트리 - 노드(부모 노드에 접근하는 구현은 제외함)

```java
class Node<E> {
  E data;
  Node<E> left, right;
  public Node(E obj) {
		this.data = obj;
    left = null;
    right =null;
  }
}
```

- 트리 - 새로운 노드 추가(재귀 구현)
  - 루트에서부터 시작한다.
  - 트리의 규칙에 따라 내려간다
  - null인 부분에 새로운 노드를 추가한다.

```java
// 메서드 오버로딩 사용
public void add(E obj) {
  if(root == null) {
		root = new Node<E>(obj);
  } else {
    add(obj, root);
  }
}

private void add(E obj, Node<E> node) {
	if(((Comparable<E>)obj).compareTo(node.data) >= 0) {
    // 오른쪽으로 이동
    if(node.right == null) {
      node.right = new Node<E>(obj);
      return;
    }
    return add(obj, node.right); 
  }
  // 왼쪽으로 이동
  if(node.left == null) {
    node.left = new Node<E>(obj);
    return;
  }
  return add(obj, node.left);
}
```

- 트리 - contains
  - 루트에서부터 찾는다.
  - 트리의 규칙에 따라 내려간다
  - 그 요소를 찾으면 true를 반환하고 null인 노드에 다다르면  false를 반환한다.

```java
public boolean contains(E obj) {
  return contains(obj, root);
}

private boolean contains(E obj, Node<E> node) {
  // 트리의 끝이 null일 때
  if(node == null) {
    return false;
	}
	// 찾으려는 값과 일치할 때 
  if(((Comparable<E>)obj).compareTo(node.data) == 0) {
    return true;
  }
  if(((Comparable<E>)obj).compareTo(node.data) > 0) {
    // 오른쪽으로 이동
    return contains(obj, node.right);
  }
  // 왼쪽으로 이동
 	return contains(obj, node.left);
}
```

- 트리 - remove

  자식 노드의 개수에 따라 트리의 특정 요소를 제거하는 방법은 다음과 같다.

  1. 리프 노드를 제거할 경우

     - 제거할 노드의 부모 노드의 포인터를 null로 설정한다.

  2. 자식 노드가 하나인 노드를 제거할 경우

     - 제거할 노드의 부모 노드의 포인터를 제거할 노드의 자식 노드로 향하게 한다. 주의할 점은 부모 노드에서 사용했던 포인터와 같은 포인터(left || right)를 사용해야 한다는 것이다.

  3. 자식 노드가 2개인 노드를 제거할 경우

     ![스크린샷 2022-12-04 16.02.55](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041603846.png)

     - 중위 후속자 또는 중위 선임자 중 하나와 자리를 바꾼 후 그 리프 노드를 제거한다.

     > - 중위 후속자(In order Successsor)
     >
     >   : 제거할 노드의 왼쪽(작은 값) 자식 노드 중 그 값이 제일 큰 노드이다. 중위 순회 방식으로 노드를 탐색할 때 루트 노드를 방문하기 직전에 만나게 되는 노드이기 때문에 중위 후속자라고 부른다.
     >
     > - 중위 선임자(In order Prodessor)
     >
     >   : 제거할 노드의 오른쪽(큰 값)자식 노드 중 그 값이 가장 작은 노드이다.

     - 제거 흐름

       1. 

       ![스크린샷 2022-12-04 16.32.01](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041632625.png)

       2.

       ![스크린샷 2022-12-04 16.33.40](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041633273.png)

       3. 

       ![](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041634091.png)

     - 삭제를 할 때 중위 후속자 또는 중위 선임자 노드가 제거 대상 노드의 자리와 스왑하는 이유는 다음과 같다. 트리는 부모 노드보다 작은 값을 부모의 왼쪽에, 부모 노드 보다 큰 값은 오른쪽에 위치 시킨다. 자식 노드가 2개인 부모 노드를 제거할 땐 위 트리의 규칙을 지켜주어야 하는데 이 규칙을 만족시키는 노드가 중위 후속자 또는 중위 후임자이다.

### 트리의 회전

```java
int arr[] = {2, 4, 6, 8, 10, 12, 14, 16, 18};
```

위 배열을 트리로 표현해보자

- 1번 트리

![](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041721793.png)



- 2번 트리

  <img src="https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041724159.png" alt="스크린샷 2022-12-04 17.22.48" style="zoom:50%;" />

위 두 트리의 차이는 균형이다. 첫 번째 그림인 트리는 균형이 잡혀 있고 두 번째 트리는 그렇지 않다.

2번 트리는 연결 리스트처럼 한 방향으로 나열된 트리이고, 이런 트리를 균형이 잡히지 않은 트리라고 한다. 그리고 이렇게 균형 잡히지 않은 트리의 균형을 잡기 위해 노드 위치를 바꾸는 과정을 **회전**이라고 한다. 

균형 잡힌 트리에서 특정 요소를 탐색하는 시간 복잡도는 O(log n)이다. 반면에 균형 잡히지 않은 트리에서는 연결리스트와 같은 O(n)이 된다. 따라서 데이터를 효율적으로 관리하려면 트리를 균형있게 만들어야 한다.

조부모, 부모, 자식 노드의 크기 관계에 따라 우측 회전 또는 좌측 회전을 한다. 트리를 재정렬하면 항상 중간 크기의 요소가 가장 위에 있는 노드가 된다.

1. 불균형이 왼쪽 서브트리에서 나타날 경우

   ![스크린샷 2022-12-04 17.40.07](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041740806.png)

   크기 관계는 조부모 > 부모 > 자식 순이다. 우측 회전을 하여 조부모 노드를 부모의 우측 자식 위치로 옮긴다.

   ```java
   public Node<E> rightRotate(Node<E> node) {
     Node<E> temp = node.left;
     node.left = temp.right; null
     temp.right = node; 
     return tmp;
   }
   ```

   

2. 불균형이 오른쪽 서브트리에서 나타날 경우

   ![스크린샷 2022-12-04 17.44.09](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041744133.png)

   크기 관계는 자식 > 부모 > 조부모이다. 좌측 회전을 하여 조부모 노드를 부모 노드의 왼쪽 자식 위치로 옮긴다.
   
   ```java
   public Node<E> leftRotate(Node<E> node) {
     Node<E> temp = node.right;
     node.right = temp.left;
     temp.left = node;
     return tmp;
   }
   ```
   
   

3. 불균형이 오른쪽 자식의 왼쪽 서브트리에서 나타날 경우

   ![스크린샷 2022-12-05 22.08.37](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212052208066.png)

   크기 관계는 부모 > 자식 > 조부모이다. 자식 노드에 대해 부모 노드를 우측 회전 후, 좌측 회전을 하여 조부모 노드를 부모 노드의 왼쪽 자식 노드 위치로 옮긴다.

   ```java
   public Node<E> rightLeftRotate(Node<E> node) {
   	node.right = rightRotate(node.right);
     return leftRotate(node);
   }
   ```

   

4. 불균형이 왼쪽 자식의 오른쪽 서브트리에서 나타날 경우

   ![스크린샷 2022-12-05 22.12.31](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212052212277.png)

   크기 관계는 부모 > 조부모 > 자식이다. 자식 노드에 대해 부모 노드를 좌측 회전 후, 우측 회전을 하여 조부모 노드를 부모 노드의 오른쪽 자식 노드 위치로 옮긴다.

   ```java
   public Node<E> leftRightRotate(Node<E> node) {
     node.left = leftRotate(node.left);
     return rightRotate(node);
   }
   ```

   

## 힙(Heap)

### 힙이란

힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리 기반의 자료구조이다.

힙은 규칙에 의해 느슨한 정렬 상태인 반정렬 상태를 유지한다.

> 완전 이진 트리란?
>
> 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있다. 마지막 레벨 h에서 1부터 2h-1 개의 노드를 가질 수 있다. 출처 : https://ko.wikipedia.org/wiki



### 힙의 종류

어떤 종류의 힙인지에 따라 두 가지의 다른 규칙이 존재한다.

1. 부모 노드가 자식 노드보다 크다. *MAX HEAP
2. 부모 노드가 자식 노드보다 작다 *MIN HEAP

가장 큰 숫자가 루트 노드가 되게 하려면 MAX HEAP의 규칙을, 가장 작은 숫자가 루트 노드가 되게 하려면 MIN HEAP의 규칙을 사용하면 된다.

### 힙의 추가와 제거

힙에 새로운 데이터를 추가하거나 제거할 때는 힙의 규칙을 지켜야 한다. 최대 힙이면 부모 노드가 자식 노드보다 커야 하고 최소 힙일 때는 자식 노드가 부모 노드보다 커야 한다.

#### 노드 추가(MAX HEAP)

- 완전 이진 트리이기 때문에 노드의 위치는 다음과 같은 성질을 가진다.
  - children : 2 * parent + 1 또는 2 * parent + 2
  - parent : floot((children-1)/2)
- 삽입 과정
  1. 비어있는 공간에 노드를 추가한다.
  1. 부모 노드보다 큰 숫자인지 확인하고 만약 그렇다면 두 노드를 바꾼다(TRICKLE UP)

- 삽입 구현

```java
int lastposition; // 어디까지 요소를 넣었는지 기록
E[] array = (E[]) new Object[size]; // 힙이 구현될 배열
public void add(E obj){ //
	array[++lastposition] = obj; // 1. 노드 추가
	trickleup(lastposition); // 2. trickle up
}
public void swap(int from, int to){ // 위치 변경
	E tmp = array[from];
	array[from] = array[to];
	array[to] = tmp;
}
public void trickleup(int position){
	if (position == 0) // 루트 노드일 때는 이미 작업이 모두 끝난 상태
		return;
	int parent = (int) Math.floor((position-1)/2); // 매개변수 포지션으로 부모 노드의 위치를 구함
	if (((Comparable<E>) array[position]).compareTo(array.parent)>0) { // 포지션 위치의 노드가 부모 노드 보다 값이 크다면 swap
		swap(position, parent);
		trickleup(parent); // 루트 값까지 비교할 수 있게 재귀 사용
	}
}
```



#### 노드 제거(MAX HEAP)

힙에서의 노드 제거는 무조건 루트를 제거해야 한다.

1. 루트를 제거한다.
2. 트리의 마지막 요소를 루트에 넣는다.
   - 마지막 요소를 루트에 넣지 않고 루트의 자식 중 값이 큰 노드로 바꿔주게 되면 최하위 레벨의 단말 노드까지 노드의 위치를 바꿔야 하기 때문에 마지막 요소를 루트에 넣는 것이다.
3. 루트에서 시작하여 두 자식 중 큰 노드와 위치를 바꿔주며 힙의 규칙을 만족하게 한다.(TRICKLE DOWN)

- 삭제 구현

```java
public E remove(){
	E tmp = array[0];
	swap(0, lastposition--); // 루트와 마지막 노드를 바꿔주고 lastposition을 줄여 배열에서 제거합니다.
	trickleDown(0);
	return tmp;
}
public void trickleDown(int parent){
	int left = 2*parent + 1;
	int right = 2*parent + 2;
	// 마지막에 왼쪽 자식이 클 때
	if (left==lastposition && (((Comparable<E>)array[parent]).compareTo(array[left])<0){
		swap(parent, left)
		return;
	}
	// 마지막에 오른쪽 자식이 클 때
	if (right==lastposition && (((Comparable<E>)array[parent]).compareTo(array[right])<0){
		swap(parent, right)
		return;
	}
	// 마지막에 부모가 클 때
	if (left >= lastposition || right >= lastposition)
		return;
	// 왼쪽 자식이 클 때
	if (array[left] > array[right] && array[parent] < array[left]) {
		swap(parent, left);
		trickleDown(left);
	}
	// 오른쪽 자식이 클 때
	else if (array[parent] < array[right]){
		swap(parent, right);
		trickleDown(right);
	}
}
```



## AVL 트리

### AVL 트리란

위 트리의 회전에서 언급한 회전을 사용하여 스스로 균형을 잡는이진 탐색 트리의 속성을 가진 트리이다.

### AVL 트리의 특징

- AVL 트리에서는 왼쪽과 오른쪽의 높이가 항상 1보다 작거나 같아야 한다. 
- 높이 차이가 1보다 커지면 회전을 통해 균형을 맞춰 높이 차이를 줄인다.
- 추가, 삭제, 검색의 시간 복잡도가 O(log N)이다.

### AVL 트리 불균형 종류

> 헷갈려서 다시 정리했다.

- **LL(Left Left)** - 왼쪽 자식 노드의 왼쪽 서브트리에서 불균형 발생

  <img src="https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041740806.png" alt="스크린샷 2022-12-04 17.40.07" style="zoom:50%;" />

  - 우회전을 적용하면 불균형이 해소된다.

- **RR(Right Right)** - 오른쪽 자식 노드의 오른쪽 서브트리에서 불균형 발생

  <img src="https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212041744133.png" alt="스크린샷 2022-12-04 17.44.09" style="zoom:50%;" />

  - 좌회전을 적용하면 불균형이 해소된다.

- **LR(Left Right)** - 왼쪽 자식 노드의 오른쪽 서브트리에서 불균형 발생

  ![스크린샷 2022-12-05 22.12.31](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212052212277.png)

  - 좌회전 적용 후 우회전을 적용하면 불균형이 해소된다.

- **RL(Right Left)** - 오른쪽 자식 노드의 왼쪽 서브트리에서 불균형 발생

  ![스크린샷 2022-12-05 22.08.37](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212052208066.png)

  - 우회전 적용 후 좌회전을 적용하면 불균형이 해소된다.

### AVL 트리 구현

- 노드

```java
class Node<T> {
  T data;
	Node<T> left;
  Node<T> right;
  Node<T> parent;  
  public Node(T obj) {
    this.data = obj;
    left = right = parent = null;
  }
}
```

- 추가

```java
public AVLTree() {
  root = null;
  currentSize = 0;
}

public void add(E obj) {
  Node<E> node = new Node<E>(obj);
  // 트리가 비어있을 경우
  if(root = null) {
    root = node;
    currentSize++;
    return;
  }
  // 트리에 노드가 있을 경우 add메서드를 재귀로 호출
  add(root, node);
}

// 재귀 add
public void add(Node<E> parent, Node<E> newNode) {
  if(((Comparable<E>)newNode.data.compareTo(parent.data) > 0) {
    if(parent.right == null) {
      parent.right = newNode;
      newNode.parent = parent;
      currentSize;
    } else {
      add(parent.right, newNode);
    }
  } else {
    if(parent.left == null) {
      if(parent.left == null) {
        parent.left = newNode;
        newNode.parent = parent;
        currentSize++;
      } else {
        add(parent.left, newNode);
      }
    }
  }
  checkBalance(newNode);
}
```

- 균형 확인

```java
public void checkBalance(Node<E> node) {
  // 높이 차이가 1 초과 또는 미만
  if(
    (height(node.left) - height(node.right) > 1) ||
    (height(node.left) - height(node.right) < -1)
  ) {
  		rebalance(node); 
  }
  // 부모 노드를 계속 확인해서 루트까지 간다.
  if(node.parent == null) {
    return;
  }
  checkBalance(node.parent);
} 
```

- 균형 맞추기

```java
public void rebalance(Node<E> node) {
	// 왼쪽 자식 > 오른쪽 자식
  if(height(node.left) - height(node.right) > 1) {
    // 노드의 왼쪽 자식의 왼쪽 서브트리가 오른쪽 서브 트리보다 크다면 우측 회전
    if(height(node.left.left) > height(node.left.right)) {
      node = rightRotate(node); 
    // 노드의 왼쪽 자식의 오른쪽 서브트리가 왼쪽 서브 트리보다 크다면 좌측-우측 회전
    } else {
      node = leftRightRotate(node);
    }
  } else {
		// 노드의 오른쪽 자식의 왼쪽 서브트리가 오른쪽 서브 트리보다 크다면 우측-좌측 회전
    if(height(node.right.left) > height(node.right.right)) {
      node = rightLeftRotate(node); 
    // 노드의 왼쪽 자식의 오른쪽 서브트리가 왼쪽 서브 트리보다 크다면 좌측 회전
    } else {
      node = leftRotate(node);
    }
  }
  if(node.parent == null) {
    root = node;
  }
}
```

