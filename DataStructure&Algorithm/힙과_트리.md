# 힙과 트리

## 트리

![image](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212012258232.png)

### 트리의 용어들

- 루트 노드(root node) - 부모가 없는 노드이다. 트리는 하나의 루트 노드를 가지고 있다. 최상위 레벨에 있다.
- 간선(edge, branch) - 각 노드를 잇는 연결 고리
- 단말 노드(leaf node) - 자식이 없는 노드이다. 최하위 레벨에 있다.
- 형제(sibling) - 같은 부모를 가지고 있는 노드들의 집합을 형제 관계라고 한다. 예를 들어 [A - B] [A -C]라는 관계에서 A가 부모 노드라면 B와 C는 형제 관계이다.
- 레벨(level) - 트리의 특정 깊이를 가지는 노드의 집합이다.
- 높이(height) - 루트 노드부터 가장 먼 단말 노드까지 가는데 거치게 되는 간선의 개수이다. 높이는  전체 노드의 개수를 알고 있으면 log2(n+1) - 1의 공식으로 구할 수 있다.
  - 레벨 0에서의 노드는 1개이다. 위 식에 대입하면 log2(0 + 1) - 1 = 0이 된다. 따라서 높이는 0이다.
  - 레벨 1에서의 노드는 3개이다. 위 식에 대입하면 log2(3 + 1) - 1 = 1이 된다. 따라서 높이는 1이다.
  - ..
  - 레벨 3에서의 노드는 15개이다. 위 식에 대입하면 log2(15 + 1) -1 = 3이 된다. 따라서 높이는 3이다.




## 힙(Heap)

힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리 기반의 자료구조이다.

힙은 규칙에 의해 느슨한 정렬 상태인 반정렬 상태를 유지한다.

> 완전 이진 트리란?
>
> 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있다. 마지막 레벨 h에서 1부터 2h-1 개의 노드를 가질 수 있다. 출처 : https://ko.wikipedia.org/wiki



### 힙의 종류

어떤 종류의 힙인지에 따라 두 가지의 다른 규칙이 존재한다.

1. 부모 노드가 자식 노드보다 크다. *MAX HEAP
2. 부모 노드가 자식 노드보다 작다 *MIN HEAP

가장 큰 숫자가 루트 노드가 되게 하려면 MAX HEAP의 규칙을, 가장 작은 숫자가 루트 노드가 되게 하려면 MIN HEAP의 규칙을 사용하면 된다.

### 힙의 추가와 제거

힙에 새로운 데이터를 추가하거나 제거할 때는 힙의 규칙을 지켜야 한다. 최대 힙이면 부모 노드가 자식 노드보다 커야 하고 최소 힙일 때는 자식 노드가 부모 노드보다 커야 한다.

#### 노드 추가(MAX HEAP)

- 완전 이진 트리이기 때문에 노드의 위치는 다음과 같은 성질을 가진다.
  - children : 2 * parent + 1 또는 2 * parent + 2
  - parent : floot((children-1)/2)
- 삽입 과정
  1. 비어있는 공간에 노드를 추가한다.
  1. 부모 노드보다 큰 숫자인지 확인하고 만약 그렇다면 두 노드를 바꾼다(TRICKLE UP)

- 삽입 구현

```java
int lastposition; // 어디까지 요소를 넣었는지 기록
E[] array = (E[]) new Object[size]; // 힙이 구현될 배열
public void add(E obj){ //
	array[++lastposition] = obj; // 1. 노드 추가
	trickleup(lastposition); // 2. trickle up
}
public void swap(int from, int to){ // 위치 변경
	E tmp = array[from];
	array[from] = array[to];
	array[to] = tmp;
}
public void trickleup(int position){
	if (position == 0) // 루트 노드일 때는 이미 작업이 모두 끝난 상태
		return;
	int parent = (int) Math.floor((position-1)/2); // 매개변수 포지션으로 부모 노드의 위치를 구함
	if (((Comparable<E>) array[position]).compareTo(array.parent)>0) { // 포지션 위치의 노드가 부모 노드 보다 값이 크다면 swap
		swap(position, parent);
		trickleup(parent); // 루트 값까지 비교할 수 있게 재귀 사용
	}
}
```



#### 노드 제거(MAX HEAP)

힙에서의 노드 제거는 무조건 루트를 제거해야 한다.

1. 루트를 제거한다.
2. 트리의 마지막 요소를 루트에 넣는다.
   - 마지막 요소를 루트에 넣지 않고 루트의 자식 중 값이 큰 노드로 바꿔주게 되면 최하위 레벨의 단말 노드까지 노드의 위치를 바꿔야 하기 때문에 마지막 요소를 루트에 넣는 것이다.
3. 루트에서 시작하여 두 자식 중 큰 노드와 위치를 바꿔주며 힙의 규칙을 만족하게 한다.(TRICKLE DOWN)

- 삭제 구현

```java
public E remove(){
	E tmp = array[0];
	swap(0, lastposition--); // 루트와 마지막 노드를 바꿔주고 lastposition을 줄여 배열에서 제거합니다.
	trickleDown(0);
	return tmp;
}
public void trickleDown(int parent){
	int left = 2*parent + 1;
	int right = 2*parent + 2;
	// 마지막에 왼쪽 자식이 클 때
	if (left==lastposition && (((Comparable<E>)array[parent]).compareTo(array[left])<0){
		swap(parent, left)
		return;
	}
	// 마지막에 오른쪽 자식이 클 때
	if (right==lastposition && (((Comparable<E>)array[parent]).compareTo(array[right])<0){
		swap(parent, right)
		return;
	}
	// 마지막에 부모가 클 때
	if (left >= lastposition || right >= lastposition)
		return;
	// 왼쪽 자식이 클 때
	if (array[left] > array[right] && array[parent] < array[left]) {
		swap(parent, left);
		trickleDown(left);
	}
	// 오른쪽 자식이 클 때
	else if (array[parent] < array[right]){
		swap(parent, right);
		trickleDown(right);
	}
}
```







