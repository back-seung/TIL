# 힙과 트리

> 참고
>
> - https://yoongrammer.tistory.com/68
> - https://www.boostcourse.org/cs204/joinLectures/212812?isDesc=false

## 트리

![image](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212012257672.png)

### 트리란

노드들이 나무 가지처럼 연결된 비선형 계층적 자료구조이다.

트리는 트리 내의 다른 하위 트리가 있고 그 하위 트리 안에는 또 다른 트리가 있는 재귀적 자료구조이다.

### 트리의 용어들

- 루트 노드(root node) - 부모가 없는 노드이다. 트리는 하나의 루트 노드를 가지고 있다. 최상위 레벨에 있다.
- 간선(edge, branch) - 각 노드를 잇는 연결 고리
- 단말 노드(leaf node) - 자식이 없는 노드이다. 최하위 레벨에 있다.
- 형제(sibling) - 같은 부모를 가지고 있는 노드들의 집합을 형제 관계라고 한다. 예를 들어 [A - B] [A -C]라는 관계에서 A가 부모 노드라면 B와 C는 형제 관계이다.
- 레벨(level) - 트리의 특정 깊이를 가지는 노드의 집합이다.
- 깊이(depth) - 루트에서 어떤 노드까지의 간선 수이다.
- 넓이(WIdth) - 어떠한 레벨에 있는 노드의 개수이다. 레벨 2의 넓이는 4이다. 
- 크기(size) - 자신을 포함한 모든 자식 노드의 개수이다.
- 높이(height) - 루트 노드부터 가장 먼 단말 노드까지 가는데 거치게 되는 간선의 개수이다. 높이는  전체 노드의 개수를 알고 있으면 log2(n+1) - 1의 공식으로 구할 수 있다.
  - 레벨 0에서의 노드는 1개이다. 위 식에 대입하면 log2(0 + 1) - 1 = 0이 된다. 따라서 높이는 0이다.
  - 레벨 1에서의 노드는 3개이다. 위 식에 대입하면 log2(3 + 1) - 1 = 1이 된다. 따라서 높이는 1이다.
  - ..
  - 레벨 3에서의 노드는 15개이다. 위 식에 대입하면 log2(15 + 1) -1 = 3이 된다. 따라서 높이는 3이다.
- 노드 차수(degree) - 각 노드의 자식 수(하위 트리 개수 / 간선 수)이다.
- 트리의 차수(degree of tree) - 트리의 최대 차수이다. 

### 트리의 특징

- 하나의 루트 노드와 0개 이상의 하위 트리로 구성된다.
- 데이터를 순차적으로 저장하지 않기 때문에 비선형 자료구조이다.
- 트리 내에 또 다른 트리가 있는 재귀적 자료구조이다.
- 단순 순환을 갖지 않고 연결된 무방향 그래프 구조이다.
  - 그래프의 한 종류로 '최소 연결 트리'라고도 부른다.
- 노드 간에 부모 자식 관계를 갖는 계층형 자료구조이다. 모든 자식은 하나의 부모 노드를 가진다.
- 노드가 n개인 트리는 항상 n -1개의 간선을 가진다.
- 순회는 Pre-order, In-order, Post-order로 이루어진다.
  - 전위 순회(Pre-order) - 루트 노드에서 시작하여 왼쪽 자식 노드에 갔다가 오른쪽 자식 노드로 가는 순회 방법이다. 다른 모든 노드를 지나기 전에 루트 노드를 방문하기 때문에 이름에 전(Pre)이 들어간다.
  - 중위 순회(In-order) - 왼쪽 자식 노드에서 시작하여 루트 노드에 갔다가 오른쪽 자식 노드로 가는 순회 방법이다.
  - 후위 순회(Post-order) - 왼쪽 자식 노드에서 시작하여 오른쪽 자식 노드에 갔다가 루트 노드로 가는 순회 방법이다. 

### 트리의 종류

- 이진 트리
  - 각 노드가 최대 두 개의 자식을 갖는 트리
- 이진 탐색 트리 (Binary Search Tree)
  - 순서화된 이진 트리 
  - 노드의 왼쪽 자식은 부모의 값보다 작은 값을 가지고, 오른쪽 자식 노드는 부모의 값보다 커야 한다.

- 편향 트리(Skew tree)
  - 모든 노드들이 자식을 하나만 가진다.
  - 왼쪽 방향으로만 하나씩만 가질 때 left skew tree, 마찬가지로 오른쪽으로만 하나씩 가질 때는 right skew tree이다.
- 균형 트리(Balanced Tree, B-Tree)
  - m원 탐색 트리에서 높이 균형을 유지하는 트리
  - height-balanced m-way tree라고도 한다.
- 원 탐색 트리(M-way Search Tree)
  - 최대 m개의 서브 트리를 가지는 탐색 트리
  - 이진 탐색 트리의 확장된 형태. 높이를 줄이기 위해 사용한다.

- 완전 이진 트리(Full Binary Tree)
  - 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리, 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.
  - 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
  - 마지막 레벨 h에서 (1 ~ 2h-1)개의 노드를 가질 수 있다. 
- 정 트리(Full Binary Tree) 
  - 모든 트리가 0개 또는 2개의 자식 노드를 갖는 트리
- 포화 이진 트리(Perfect Binary Tree)
  - 정 트리면서 완전 이지 트리인 경우
  - 모든 말단 노드는 같은 높이에 있어야 하며 마지막 레벨에서 노드 개수는 최대 개수여야 한다.
  - 리프를 제외한 모든 노드가 두개의 또 다른 자식 노드를 가져야 한다.
  - 모든 리프 노드는 같은 레벨에 있어야 한다.
  - 노드의 개수 = 2^(height -1)개여야 한다. 



### 중위 표기법, 후위 표기법

컴퓨터는 괄호, 연산자의 우선순위를 따로 처리하지 않고 왼쪽에서 오른쪽으로 표기된 순서대로 처리하면 결과가 올바르게 나오는 후위 표기법을 사용한다.

- 중위 표기법 : 연산자를 피연산자의 가운데에 표기한다.
  - 예) 2 + 3
- 후위 표기법 : 연산자를 피연산자의 뒤에 표기한다.
  - 예) 23 + 


## 힙(Heap)

힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리 기반의 자료구조이다.

힙은 규칙에 의해 느슨한 정렬 상태인 반정렬 상태를 유지한다.

> 완전 이진 트리란?
>
> 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 모든 노드는 가능한 한 가장 왼쪽에 있다. 마지막 레벨 h에서 1부터 2h-1 개의 노드를 가질 수 있다. 출처 : https://ko.wikipedia.org/wiki



### 힙의 종류

어떤 종류의 힙인지에 따라 두 가지의 다른 규칙이 존재한다.

1. 부모 노드가 자식 노드보다 크다. *MAX HEAP
2. 부모 노드가 자식 노드보다 작다 *MIN HEAP

가장 큰 숫자가 루트 노드가 되게 하려면 MAX HEAP의 규칙을, 가장 작은 숫자가 루트 노드가 되게 하려면 MIN HEAP의 규칙을 사용하면 된다.

### 힙의 추가와 제거

힙에 새로운 데이터를 추가하거나 제거할 때는 힙의 규칙을 지켜야 한다. 최대 힙이면 부모 노드가 자식 노드보다 커야 하고 최소 힙일 때는 자식 노드가 부모 노드보다 커야 한다.

#### 노드 추가(MAX HEAP)

- 완전 이진 트리이기 때문에 노드의 위치는 다음과 같은 성질을 가진다.
  - children : 2 * parent + 1 또는 2 * parent + 2
  - parent : floot((children-1)/2)
- 삽입 과정
  1. 비어있는 공간에 노드를 추가한다.
  1. 부모 노드보다 큰 숫자인지 확인하고 만약 그렇다면 두 노드를 바꾼다(TRICKLE UP)

- 삽입 구현

```java
int lastposition; // 어디까지 요소를 넣었는지 기록
E[] array = (E[]) new Object[size]; // 힙이 구현될 배열
public void add(E obj){ //
	array[++lastposition] = obj; // 1. 노드 추가
	trickleup(lastposition); // 2. trickle up
}
public void swap(int from, int to){ // 위치 변경
	E tmp = array[from];
	array[from] = array[to];
	array[to] = tmp;
}
public void trickleup(int position){
	if (position == 0) // 루트 노드일 때는 이미 작업이 모두 끝난 상태
		return;
	int parent = (int) Math.floor((position-1)/2); // 매개변수 포지션으로 부모 노드의 위치를 구함
	if (((Comparable<E>) array[position]).compareTo(array.parent)>0) { // 포지션 위치의 노드가 부모 노드 보다 값이 크다면 swap
		swap(position, parent);
		trickleup(parent); // 루트 값까지 비교할 수 있게 재귀 사용
	}
}
```



#### 노드 제거(MAX HEAP)

힙에서의 노드 제거는 무조건 루트를 제거해야 한다.

1. 루트를 제거한다.
2. 트리의 마지막 요소를 루트에 넣는다.
   - 마지막 요소를 루트에 넣지 않고 루트의 자식 중 값이 큰 노드로 바꿔주게 되면 최하위 레벨의 단말 노드까지 노드의 위치를 바꿔야 하기 때문에 마지막 요소를 루트에 넣는 것이다.
3. 루트에서 시작하여 두 자식 중 큰 노드와 위치를 바꿔주며 힙의 규칙을 만족하게 한다.(TRICKLE DOWN)

- 삭제 구현

```java
public E remove(){
	E tmp = array[0];
	swap(0, lastposition--); // 루트와 마지막 노드를 바꿔주고 lastposition을 줄여 배열에서 제거합니다.
	trickleDown(0);
	return tmp;
}
public void trickleDown(int parent){
	int left = 2*parent + 1;
	int right = 2*parent + 2;
	// 마지막에 왼쪽 자식이 클 때
	if (left==lastposition && (((Comparable<E>)array[parent]).compareTo(array[left])<0){
		swap(parent, left)
		return;
	}
	// 마지막에 오른쪽 자식이 클 때
	if (right==lastposition && (((Comparable<E>)array[parent]).compareTo(array[right])<0){
		swap(parent, right)
		return;
	}
	// 마지막에 부모가 클 때
	if (left >= lastposition || right >= lastposition)
		return;
	// 왼쪽 자식이 클 때
	if (array[left] > array[right] && array[parent] < array[left]) {
		swap(parent, left);
		trickleDown(left);
	}
	// 오른쪽 자식이 클 때
	else if (array[parent] < array[right]){
		swap(parent, right);
		trickleDown(right);
	}
}
```







