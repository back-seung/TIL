# 정렬

> Ref :
>
> 1. [실전 알고리즘 강좌 - 나동빈님 유튜브](https://www.youtube.com/playlist?list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz)
> 2. [gyogle](https://gyoogle.dev/)

### 정렬의 종류

- out-of-place 정렬 : 모든 데이터를 자료 구조의 복사본에 옮긴 후, 순서대로 배열하여 정렬한다.
- in-place 정렬 : 자료 구조를 그대로 두고 그 안에서 요소들의 위치를 바꾸어 정렬한다.
- 배열 `{1, 7, 1, 8, 9, 8}` 이 존재한다고 할 때 두 가지로 나누어 정렬의 종류를 말할 수 있다.
  - 안정 정렬 : `{1, 1, 7, 8, 8, 9}`,  중복된 요소를 포함하여 함께 순서대로 정렬한다.
  - 불안정 정렬 : 중복된 숫자의 순서를 보장할 수 없다.

 

## 선택 정렬

![스크린샷 2022-12-16 22.23.18](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212162223373.png)

### 개념 및 요약

선택 정렬은 버블 정렬과 유사한 알고리즘으로, 순서대로 리스트이 가장 작은 수를 찾고 그 수를 확정되지 않은 부분의 가장 앞 자리에 놓는 방법이다. 리스트 안에서 순서만바꿔주기 때문에 in-place 정렬이다.

선택 정렬과 삽입 정렬을 헷갈려하는 사람들이 종종 있는데, 선택 정렬은 배열에서 **해당 자리를 선택하고 그 자리에 오는 값을 찾는 것**이라고 생각하면 편하다.

### 시간 복잡도

- 최악 : O(N^2)
- 평균 : O(N^2)
- 최선 : O(N^2)

### 실행 순서

1. 주어진 배열 중 최소값을 찾는다.
2. 그 값을 맨 앞의 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 배열들을 같은 방법으로 교체한다.

### 소스 코드

```java
public static void main(String[] args) {
  final int[] nums = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
  int index = 0;
  int temp = 0;

  for (int i = 0; i < nums.length; i++) {
    int min = 9999;
    for (int j = i; j < nums.length; j++) {
      if (min > nums[j]) {
        min = nums[j]; 
        index = j; 
      }
    }
    temp = nums[i];
    nums[i] = nums[index];
    nums[index] = temp; 
  }
}
```



## 버블 정렬

### 개념 및 요약

선택 정렬과 유사한 알고리즘으로 **서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘**이다.

이름의 유래로는 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 한다.

### 실행 순서

1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를 ... 이런식으로 (마지막 번째  -1) 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
2. 1회전을 수행하고 나면 가장 큰 원소는 맨 뒤로 이동한다. 2회전에서는 끝에서 첫번째 위치는 제외하고 3회전에서는 끝에서 두 번째 위치는 제외하고 정렬이 이루어진다. 즉, 정렬을 1회차 수행할 때마다 정렬에서 제외되는 원소가 하나씩 늘어난다.

### 소스 코드

```java
public static void main(String[] args) {
  final int[] nums = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
  int temp = 0;

  for (int i = 0; i < nums.length; i++) {
    for (int j = i; j < (nums.length - 1) - i; j++) {
      if (nums[j] > nums[j + 1]) {
        temp = nums[j];
        nums[j] = nums[j + 1];
        nums[j + 1] = temp;
      }
    }
  }
}
```



## 삽입 정렬

![스크린샷 2022-12-16 22.35.39](https://raw.githubusercontent.com/back-seung/TIL/master/uPic/202212162235855.png)

### 개념 및 요약

 손 안의 카드르 정렬하는 방법과 유사하다.

선택 정렬과 유사하지만 좀 더 효율 적인 정렬 알고리즘이다.

삽입 정렬은 **2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입**하여 정렬하는 알고리즘이다.

삽입 정렬은 요소를 하나씩 꺼내서 그 요소 앞에 있는 다른 요소들과 모두 비교하는 방법이다. 리스트 안에서 순서만 바꿔주기 때문에 in-place 정렬이다.

최선의 경우 O(N)이라는 엄청나게 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘이다.

### 시간 복잡도

- 최악 : O(N^2)
- 평균 : O(N^2)
- 최선 : O(N)

### 실행 순서

1. 정렬은 첫번째 위치의 값을 temp에 저장한다.
2. temp와 다음에 있는 원소들과 비교하며 삽입해나간다.
3. 1번으로 돌아가 다음 위치의 값을 temp에 저장하고 반복한다. 



### 소스코드 

```java
public static void main(String[] args) {
  int temp = 0;
  int j = 0;
  final int[] nums = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
  for (int i = 0; i < nums.length - 1; i++) {
    j = i;
    while (nums[j] > nums[j + 1]) {
      temp = nums[j];
      nums[j] = nums[j + 1];
      nums[j + 1] = temp;
      j--;
    }
  }
}
```

